{"version":3,"file":"bounds.js","sources":["../src/AxisAlignedBounds.ts","../src/OrientedBounds.ts"],"sourcesContent":["/// <reference path=\"../node_modules/pixi.js/pixi.js.d.ts\" />\nimport { Point } from '@pixi/math';\n\n/**\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\n * point (x, y) and by its width and its height.\n *\n * @class\n * @memberof PIXI\n */\nexport class AxisAlignedBounds\n{\n    public currentID: number;\n    public dirtyID: number;\n\n    protected _x: number;\n    protected _y: number;\n    protected _width: number;\n    protected _height: number;\n    protected _hull: [Point, Point, Point, Point];\n\n    /**\n     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle\n     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle\n     * @param {number} [width=0] - The overall width of this rectangle\n     * @param {number} [height=0] - The overall height of this rectangle\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0)\n    {\n        this._x = Number(x);\n        this._y = Number(y);\n        this._width = Number(width);\n        this._height = Number(height);\n        this._hull = [new Point(), new Point(), new Point(), new Point()];\n\n        this.currentID = -1;\n        this.dirtyID = 0;\n    }\n\n    get x(): number\n    {\n        return this._x;\n    }\n    set x(value: number)\n    {\n        this._x = value;\n        this.dirtyID++;\n    }\n\n    get y(): number\n    {\n        return this._y;\n    }\n    set y(value: number)\n    {\n        this._y = value;\n        this.dirtyID++;\n    }\n\n    get width(): number\n    {\n        return this._width;\n    }\n    set width(value: number)\n    {\n        this._width = value;\n        this.dirtyID++;\n    }\n\n    get height(): number\n    {\n        return this._height;\n    }\n    set height(value: number)\n    {\n        this._height = value;\n        this.dirtyID++;\n    }\n\n    get hull(): Point[]\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull;\n    }\n\n    get topLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[0];\n    }\n\n    get topRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[1];\n    }\n\n    get bottomRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[2];\n    }\n\n    get bottomLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[3];\n    }\n\n    protected isDirty(): boolean\n    {\n        return this.currentID !== this.dirtyID;\n    }\n\n    protected update(): void\n    {\n        const [topLeft, topRight, bottomRight, bottomLeft] = this._hull;\n\n        topLeft.set(this._x, this._y);\n        topRight.set(this._x + this._width, this._y);\n        bottomRight.set(this._x + this._width, this._y + this._height);\n        bottomLeft.set(this._x, this._y + this._height);\n    }\n\n    /**\n     * returns the left edge of the rectangle\n     *\n     * @member {number}\n     */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /**\n     * returns the right edge of the rectangle\n     *\n     * @member {number}\n     */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /**\n     * returns the top edge of the rectangle\n     *\n     * @member {number}\n     */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /**\n     * returns the bottom edge of the rectangle\n     *\n     * @member {number}\n     */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     *\n     * @return {PIXI.Rectangle} a copy of the rectangle\n     */\n    clone(): AxisAlignedBounds\n    {\n        return new AxisAlignedBounds(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     *\n     * @param rectangle - The rectangle to copy from.\n     * @return Returns itself.\n     */\n    copyFrom(rectangle: AxisAlignedBounds): AxisAlignedBounds\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     *\n     * @param rectangle - The rectangle to copy to.\n     * @return Returns given parameter.\n     */\n    copyTo(rectangle: AxisAlignedBounds): AxisAlignedBounds\n    {\n        rectangle.x = this.x;\n        rectangle.y = this.y;\n        rectangle.width = this.width;\n        rectangle.height = this.height;\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     *\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @return Whether the x/y coordinates are within this Rectangle\n     */\n    contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the given {@link bounds} are equal to this.\n     *\n     * @param bounds\n     */\n    equals(bounds: AxisAlignedBounds): boolean\n    {\n        if (!bounds) return false;\n\n        return bounds.x === this.x\n            && bounds.y === this.y\n            && bounds.width === this.width\n            && bounds.height === this.height;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param [paddingX=0] - The horizontal padding amount.\n     * @param [paddingY=0] - The vertical padding amount.\n     * @return Returns itself.\n     */\n    pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     *\n     * @param rectangle - The rectangle to fit.\n     * @return Returns itself.\n     */\n    fit(rectangle: AxisAlignedBounds): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     *\n     * @param [resolution=1] resolution\n     * @param [eps=0.001] precision\n     * @return Returns itself.\n     */\n    ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     *\n     * @param rectangle - The rectangle to include.\n     * @return Returns itself.\n     */\n    enlarge(rectangle: AxisAlignedBounds): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n}\n","/// <reference path=\"../node_modules/pixi.js/pixi.js.d.ts\" />\nimport { AxisAlignedBounds } from './AxisAlignedBounds';\nimport { Matrix, ObservablePoint, Point } from '@pixi/math';\n\n/**\n * An oriented bounding box is a rotated rectangle.\n *\n * An oriented bounding box is modelled by rotating its (axis-aligned) {@link OrientedBounds#innerBounds}\n * by an angle {@link OrientedBounds#angle} around its center. The center of an oriented bounding box and\n * its axis-aligned inner-bounds coincide.\n */\nexport class OrientedBounds\n{\n    public innerBounds: AxisAlignedBounds;\n    public currentID: number;\n    public dirtyID: number;\n\n    protected _rotation: number;\n    protected _center: Point;\n    protected _hull: [Point, Point, Point, Point];\n    protected _matrix: Matrix;\n\n    /**\n     * @param innerBounds\n     * @param angle\n     */\n    constructor(innerBounds: AxisAlignedBounds, angle?: number);\n\n    /**\n     * @param x\n     * @param y\n     * @param width\n     * @param height\n     * @param angle\n     */\n    constructor(x?: number, y?: number, width?: number, height?: number, angle?: number);\n\n    constructor(x: number | AxisAlignedBounds = 0, y = 0, width = 0, height = 0, angle = 0)\n    {\n        if (x instanceof AxisAlignedBounds)\n        {\n            angle = y || 0;\n\n            y = x.y;\n            width = x.width;\n            height = x.height;\n\n            x = x.x;\n        }\n\n        /**\n         * The unrotated version of this bounding box.\n         */\n        this.innerBounds = new AxisAlignedBounds(x, y, width, height);\n\n        this._rotation = angle;\n        this._center = new ObservablePoint<OrientedBounds>(this.updateCenter, this);\n        this._hull = [new Point(), new Point(), new Point(), new Point()];\n        this._matrix = new Matrix();\n\n        this.currentID = -1;\n        this.dirtyID = 0;\n    }\n\n    /**\n     * The angle, in radians, by which this bounding box is tilted.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this._rotation = value;\n        this.dirtyID++;\n    }\n\n    /**\n     * The center of this bounding box.\n     *\n     * The center of this and {@code this.innerBounds} will always coincide.\n     */\n    get center(): ObservablePoint\n    {\n        if (this.isDirty()) this.update();\n\n        return this._center;\n    }\n\n    set center(value: Point)\n    {\n        // this.updateCenter will automatically be fired!\n        this.center.copyFrom(value);\n    }\n\n    /**\n     * The four-corners of this bounding, in clockwise order starting from the top-left.\n     *\n     * @readonly\n     */\n    get hull(): [Point, Point, Point, Point]\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull;\n    }\n\n    /**\n     * The top-left corner of this bounding box. The returned instance should not be modified directly.\n     *\n     * @readonly\n     */\n    get topLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[0];\n    }\n\n    /**\n     * The top-right corner of this bounding box. The returned instance should not be modified directly.\n     *\n     * @readonly\n     */\n    get topRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[1];\n    }\n\n    /**\n     * The bottom-right corner of this bounding box. The returned instance should not be modified directly.\n     */\n    get bottomRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[2];\n    }\n\n    /**\n     * The bottom-left corner of this bounding box. The returned instance should not be modified directly.\n     */\n    get bottomLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[3];\n    }\n\n    /**\n     * Checks whether the given {@code bounds} are equal to this.\n     *\n     * @param bounds\n     */\n    equals(bounds: OrientedBounds): boolean\n    {\n        if (!bounds) return false;\n\n        return this.innerBounds.equals(bounds.innerBounds)\n            && this.rotation === bounds.rotation;\n    }\n\n    /**\n     * Copies {@code bounds} into this instance.\n     *\n     * @param bounds\n     */\n    copyFrom(bounds: OrientedBounds): this\n    {\n        this.innerBounds.copyFrom(bounds.innerBounds);\n        this.rotation = bounds.rotation;\n        this.dirtyID++;\n\n        return this;\n    }\n\n    /**\n     * Whether any internal state needs to be recalculated.\n     */\n    protected isDirty(): boolean\n    {\n        return this.currentID !== this.dirtyID + this.innerBounds.dirtyID;\n    }\n\n    /**\n     * This will recalculate the center, orientation matrix, and the hull vertices. It should be called only if\n     * {@code this.isDirty} returns true.\n     */\n    protected update(): void\n    {\n        const innerBounds = this.innerBounds;\n        const angle = this._rotation;\n\n        const center = this._center;\n        const [topLeft, topRight, bottomRight, bottomLeft] = this._hull;\n        const matrix = this._matrix;\n\n        // Calculate center\n        // Do not set [x|y] so to prevent this.updateCenter from being fired!\n        center._x = innerBounds.x + (innerBounds.width / 2);\n        center._y = innerBounds.y + (innerBounds.height / 2);\n\n        // Calculate orientation matrix\n        matrix.identity()\n            .translate(-center.x, -center.y)\n            .rotate(angle)\n            .translate(center.x, center.y);\n\n        // Calculate hull vertices\n        matrix.apply(innerBounds.topLeft, topLeft);\n        matrix.apply(innerBounds.topRight, topRight);\n        matrix.apply(innerBounds.bottomRight, bottomRight);\n        matrix.apply(innerBounds.bottomLeft, bottomLeft);\n\n        // Update currentID so isDirty() is false\n        this.currentID = this.dirtyID + this.innerBounds.dirtyID;\n    }\n\n    /**\n     * This will translate {@link this.innerBounds} after {@link this.center} is changed to ensure consistency.\n     */\n    private updateCenter(): void\n    {\n        const center = this.center;\n        const innerBounds = this.innerBounds;\n\n        innerBounds.x = center.x - (innerBounds.width / 2);\n        innerBounds.y = center.y - (innerBounds.height / 2);\n    }\n}\n"],"names":["AxisAlignedBounds","[object Object]","x","y","width","height","this","_x","Number","_y","_width","_height","_hull","Point","currentID","dirtyID","value","hull","isDirty","update","topLeft","topRight","bottomRight","bottomLeft","set","left","right","top","bottom","rectangle","bounds","paddingX","paddingY","x1","Math","max","x2","min","y1","y2","resolution","eps","ceil","floor","angle","innerBounds","_rotation","_center","ObservablePoint","updateCenter","_matrix","Matrix","rotation","center","copyFrom","equals","matrix","identity","translate","rotate","apply"],"mappings":"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"}