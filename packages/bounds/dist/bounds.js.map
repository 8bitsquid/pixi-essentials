{"version":3,"file":"bounds.js","sources":["../src/AxisAlignedBounds.ts","../src/OrientedBounds.ts"],"sourcesContent":["/// <reference path=\"../node_modules/pixi.js/pixi.js.d.ts\" />\nimport { Point } from '@pixi/math';\n\n/**\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\n * point (x, y) and by its width and its height.\n *\n * @class\n * @memberof PIXI\n */\nexport class AxisAlignedBounds\n{\n    public currentID: number;\n    public dirtyID: number;\n\n    protected _x: number;\n    protected _y: number;\n    protected _width: number;\n    protected _height: number;\n    protected _hull: [Point, Point, Point, Point];\n\n    /**\n     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle\n     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle\n     * @param {number} [width=0] - The overall width of this rectangle\n     * @param {number} [height=0] - The overall height of this rectangle\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0)\n    {\n        this._x = Number(x);\n        this._y = Number(y);\n        this._width = Number(width);\n        this._height = Number(height);\n        this._hull = [new Point(), new Point(), new Point(), new Point()];\n\n        this.currentID = -1;\n        this.dirtyID = 0;\n    }\n\n    get x(): number\n    {\n        return this._x;\n    }\n    set x(value: number)\n    {\n        this._x = value;\n        this.dirtyID++;\n    }\n\n    get y(): number\n    {\n        return this._y;\n    }\n    set y(value: number)\n    {\n        this._y = value;\n        this.dirtyID++;\n    }\n\n    get width(): number\n    {\n        return this._width;\n    }\n    set width(value: number)\n    {\n        this._width = value;\n        this.dirtyID++;\n    }\n\n    get height(): number\n    {\n        return this._height;\n    }\n    set height(value: number)\n    {\n        this._height = value;\n        this.dirtyID++;\n    }\n\n    get topLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[0];\n    }\n\n    get topRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[1];\n    }\n\n    get bottomRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[2];\n    }\n\n    get bottomLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[3];\n    }\n\n    protected isDirty(): boolean\n    {\n        return this.currentID !== this.dirtyID;\n    }\n\n    protected update(): void\n    {\n        const [topLeft, topRight, bottomRight, bottomLeft] = this._hull;\n\n        topLeft.set(this._x, this._y);\n        topRight.set(this._x + this._width, this._y);\n        bottomRight.set(this._x + this._width, this._y + this._height);\n        bottomLeft.set(this._x, this._y + this._height);\n    }\n\n    /**\n     * returns the left edge of the rectangle\n     *\n     * @member {number}\n     */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /**\n     * returns the right edge of the rectangle\n     *\n     * @member {number}\n     */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /**\n     * returns the top edge of the rectangle\n     *\n     * @member {number}\n     */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /**\n     * returns the bottom edge of the rectangle\n     *\n     * @member {number}\n     */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     *\n     * @return {PIXI.Rectangle} a copy of the rectangle\n     */\n    clone(): AxisAlignedBounds\n    {\n        return new AxisAlignedBounds(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     *\n     * @param rectangle - The rectangle to copy from.\n     * @return Returns itself.\n     */\n    copyFrom(rectangle: AxisAlignedBounds): AxisAlignedBounds\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     *\n     * @param rectangle - The rectangle to copy to.\n     * @return Returns given parameter.\n     */\n    copyTo(rectangle: AxisAlignedBounds): AxisAlignedBounds\n    {\n        rectangle.x = this.x;\n        rectangle.y = this.y;\n        rectangle.width = this.width;\n        rectangle.height = this.height;\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     *\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @return Whether the x/y coordinates are within this Rectangle\n     */\n    contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param [paddingX=0] - The horizontal padding amount.\n     * @param [paddingY=0] - The vertical padding amount.\n     * @return Returns itself.\n     */\n    pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     *\n     * @param rectangle - The rectangle to fit.\n     * @return Returns itself.\n     */\n    fit(rectangle: AxisAlignedBounds): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     *\n     * @param [resolution=1] resolution\n     * @param [eps=0.001] precision\n     * @return Returns itself.\n     */\n    ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     *\n     * @param rectangle - The rectangle to include.\n     * @return Returns itself.\n     */\n    enlarge(rectangle: AxisAlignedBounds): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n}\n","/// <reference path=\"../node_modules/pixi.js/pixi.js.d.ts\" />\nimport { AxisAlignedBounds } from './AxisAlignedBounds';\nimport { Matrix, ObservablePoint, Point } from '@pixi/math';\n\n/**\n * An oriented bounding box is a rotated rectangle.\n *\n * An oriented bounding box is modelled by rotated its (axis-aligned) {@link OrientedBounds#innerBounds}\n * by an angle {@link OrientedBounds#angle} around its center. The center of an oriented bounding box and\n * its axis-aligned inner-bounds coincide.\n */\nexport class OrientedBounds\n{\n    public innerBounds: AxisAlignedBounds;\n    public currentID: number;\n    public dirtyID: number;\n\n    protected _angle: number;\n    protected _center: Point;\n    protected _hull: [Point, Point, Point, Point];\n    protected _matrix: Matrix;\n\n    /**\n     * @param innerBounds\n     * @param angle\n     */\n    constructor(innerBounds: AxisAlignedBounds, angle?: number);\n\n    /**\n     * @param x\n     * @param y\n     * @param width\n     * @param height\n     * @param angle\n     */\n    constructor(x: number, y: number, width: number, height: number, angle?: number);\n\n    constructor(x: number | AxisAlignedBounds, y?: number, width?: number, height?: number, angle = 0)\n    {\n        if (x instanceof AxisAlignedBounds)\n        {\n            angle = y || 0;\n\n            y = x.y;\n            width = x.width;\n            height = x.height;\n\n            x = x.x;\n        }\n\n        /**\n         * The unrotated version of this bounding box.\n         */\n        this.innerBounds = new AxisAlignedBounds(x, y, width, height);\n\n        this._angle = angle;\n        this._center = new ObservablePoint<OrientedBounds>(this.updateCenter, this);\n        this._hull = [new Point(), new Point(), new Point(), new Point()];\n        this._matrix = new Matrix();\n\n        this.currentID = -1;\n        this.dirtyID = 0;\n    }\n\n    /**\n     * The angle, in radians, by which this bounding box is tilted.\n     */\n    get angle(): number\n    {\n        return this._angle;\n    }\n\n    set angle(value: number)\n    {\n        this._angle = value;\n        this.dirtyID++;\n    }\n\n    /**\n     * The center of this bounding box.\n     *\n     * The center of this and {@code this.innerBounds} will always coincide.\n     */\n    get center(): ObservablePoint\n    {\n        return this._center;\n    }\n\n    set center(value: Point)\n    {\n        // this.updateCenter will automatically be fired!\n        this.center.copyFrom(value);\n    }\n\n    /**\n     * The top-left corner of this bounding box. The returned instance should not be modified directly.\n     *\n     * @readonly\n     */\n    get topLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[0];\n    }\n\n    /**\n     * The top-right corner of this bounding box. The returned instance should not be modified directly.\n     *\n     * @readonly\n     */\n    get topRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[1];\n    }\n\n    /**\n     * The bottom-right corner of this bounding box. The returned instance should not be modified directly.\n     */\n    get bottomRight(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[2];\n    }\n\n    /**\n     * The bottom-left corner of this bounding box. The returned instance should not be modified directly.\n     */\n    get bottomLeft(): Point\n    {\n        if (this.isDirty()) this.update();\n\n        return this._hull[3];\n    }\n\n    /**\n     * Whether any internal state needs to be recalculated.\n     */\n    protected isDirty(): boolean\n    {\n        return this.currentID !== this.dirtyID + this.innerBounds.dirtyID;\n    }\n\n    /**\n     * This will recalculate the center, orientation matrix, and the hull vertices. It should be called only if\n     * {@code this.isDirty} returns true.\n     */\n    protected update(): void\n    {\n        const innerBounds = this.innerBounds;\n        const angle = this._angle;\n\n        const center = this._center;\n        const [topLeft, topRight, bottomRight, bottomLeft] = this._hull;\n        const matrix = this._matrix;\n\n        // Calculate center\n        // Do not set [x|y] so to prevent this.updateCenter from being fired!\n        center._x = innerBounds.x + (innerBounds.width / 2);\n        center._y = innerBounds.y + (innerBounds.height / 2);\n\n        // Calculate orientation matrix\n        matrix.identity()\n            .translate(-center.x, -center.y)\n            .rotate(angle)\n            .translate(center.x, center.y);\n\n        // Calculate hull vertices\n        matrix.apply(innerBounds.topLeft, topLeft);\n        matrix.apply(innerBounds.topRight, topRight);\n        matrix.apply(innerBounds.bottomRight, bottomRight);\n        matrix.apply(innerBounds.bottomLeft, bottomLeft);\n\n        // Update currentID so isDirty() is false\n        this.currentID = this.dirtyID + this.innerBounds.dirtyID;\n    }\n\n    /**\n     * This will translate {@link this.innerBounds} after {@link this.center} is changed to ensure consistency.\n     */\n    private updateCenter(): void\n    {\n        const center = this.center;\n        const innerBounds = this.innerBounds;\n\n        innerBounds.x = center.x - (innerBounds.width / 2);\n        innerBounds.y = center.y - (innerBounds.height / 2);\n    }\n}\n"],"names":["AxisAlignedBounds","[object Object]","x","y","width","height","this","_x","Number","_y","_width","_height","_hull","Point","currentID","dirtyID","value","topLeft","isDirty","update","topRight","bottomRight","bottomLeft","set","left","right","top","bottom","rectangle","paddingX","paddingY","x1","Math","max","x2","min","y1","y2","resolution","eps","ceil","floor","angle","innerBounds","_angle","_center","ObservablePoint","updateCenter","_matrix","Matrix","center","copyFrom","matrix","identity","translate","rotate","apply"],"mappings":"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"}