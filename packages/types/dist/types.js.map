{"version":3,"file":"types.js","sources":["../src/LinkedList.ts"],"sourcesContent":["/**\n * A node in a linked-list data-structure.\n */\nexport interface ILinkedListNode\n{\n    /**\n     * The next node in the linked-list.\n     */\n    next: this;\n}\n\n/**\n * A node in a doubly linked-list data structure.\n */\nexport interface IDoublyLinkedListNode extends ILinkedListNode\n{\n    previous: this;\n}\n\n/**\n * Iterator for circular linked-lists\n *\n * @example\n * const iterator = new CircularLinkedListIterator<Node>(startNode);\n *\n * while (!iterator.done)\n * {\n *      // Each node will be assigned to \"value\", including startNode\n *      const { value } = iterator.next();\n * }\n */\nexport class CircularLinkedListIterator<Node extends ILinkedListNode> implements Iterator<Node, Node, Node>\n{\n    public current: Node;\n    public done: boolean;\n\n    protected start: Node;\n\n    constructor(node: Node)\n    {\n        /**\n         * The last node returned by {@code this.next}.\n         */\n        this.current = null;\n\n        /**\n         * Whether the iterator has finished iterating over all elements.\n         */\n        this.done = false;\n\n        /**\n         * The first node occurring in this iteration.\n         */\n        this.start = node;\n    }\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators\n     */\n    next(): IteratorResult<Node, Node>\n    {\n        if (this.current === null)\n        {\n            this.current = this.start;\n        }\n        else if (this.current.next !== this.start)\n        {\n            this.current = this.current.next;\n        }\n        else\n        {\n            // this.current.next === this.start, so we are done here\n            this.current = null;\n            this.done = true;\n        }\n\n        return {\n            value: this.current,\n            done: this.done,\n        };\n    }\n\n    /**\n     * Reset the iterator so it can be used again.\n     */\n    reset(start: Node = this.start): this\n    {\n        this.current = null;\n        this.done = false;\n        this.start = start;\n\n        return this;\n    }\n}\n\n/**\n * An iterable circular linked-list data structure.\n */\nexport class CircularLinkedList<Node extends ILinkedListNode> implements Iterable<Node>\n{\n    public head: Node;\n\n    private _sharedIterator: CircularLinkedListIterator<Node>;\n\n    constructor(head: Node)\n    {\n        this.head = head;\n    }\n\n    [Symbol.iterator](): Iterator<Node, Node, Node>\n    {\n        if (!this._sharedIterator)\n        {\n            this._sharedIterator = new CircularLinkedListIterator(this.head);\n        }\n\n        this._sharedIterator.reset(this.head);\n\n        return this._sharedIterator;\n    }\n}\n\nexport class CircularDoublyLinkedList<Node extends IDoublyLinkedListNode> implements Iterable<Node>\n{\n    public head: Node;\n    private _sharedIterator: CircularLinkedListIterator<Node>;\n\n    constructor(head: Node)\n    {\n        this.head = head;\n    }\n\n    /**\n     * Adds {@code node} into this list before {@code nodeAfter}.\n     *\n     * @param node - the node to be added to this list\n     * @param nodeAfter - the node that should come after the added node\n     */\n    add(node: Node, nodeAfter: Node = this.head): this\n    {\n        // Initialize node's pointers first!\n        node.next = nodeAfter;\n        node.previous = nodeAfter.previous;\n\n        nodeAfter.previous = node;\n\n        return this;\n    }\n\n    forEach(callback: (node: Node) => any): void\n    {\n        const head = this.head;\n        let current = head;\n\n        do\n        {\n            callback(current);\n            current = current.next;\n        } while (current !== head);\n    }\n\n    [Symbol.iterator](): Iterator<Node, Node, Node>\n    {\n        if (!this._sharedIterator)\n        {\n            this._sharedIterator = new CircularLinkedListIterator(this.head);\n        }\n\n        this._sharedIterator.reset(this.head);\n\n        return this._sharedIterator;\n    }\n}\n"],"names":["CircularLinkedListIterator","[object Object]","node","this","current","done","start","next","value","CircularLinkedList","head","Symbol","iterator","_sharedIterator","reset","CircularDoublyLinkedList","nodeAfter","previous","callback"],"mappings":";;;;;;;;;kFA+BaA,EAOTC,YAAYC,GAKRC,KAAKC,QAAU,KAKfD,KAAKE,MAAO,EAKZF,KAAKG,MAAQJ,EAMjBD,OAiBI,OAfqB,OAAjBE,KAAKC,QAELD,KAAKC,QAAUD,KAAKG,MAEfH,KAAKC,QAAQG,OAASJ,KAAKG,MAEhCH,KAAKC,QAAUD,KAAKC,QAAQG,MAK5BJ,KAAKC,QAAU,KACfD,KAAKE,MAAO,GAGT,CACHG,MAAOL,KAAKC,QACZC,KAAMF,KAAKE,MAOnBJ,MAAMK,EAAcH,KAAKG,OAMrB,OAJAH,KAAKC,QAAU,KACfD,KAAKE,MAAO,EACZF,KAAKG,MAAQA,EAENH,YAOFM,EAMTR,YAAYS,GAERP,KAAKO,KAAOA,EAGhBT,CAACU,OAAOC,YASJ,OAPKT,KAAKU,kBAENV,KAAKU,gBAAkB,IAAIb,EAA2BG,KAAKO,OAG/DP,KAAKU,gBAAgBC,MAAMX,KAAKO,MAEzBP,KAAKU,uBAIPE,EAKTd,YAAYS,GAERP,KAAKO,KAAOA,EAShBT,IAAIC,EAAYc,EAAkBb,KAAKO,MAQnC,OALAR,EAAKK,KAAOS,EACZd,EAAKe,SAAWD,EAAUC,SAE1BD,EAAUC,SAAWf,EAEdC,KAGXF,QAAQiB,GAEJ,MAAMR,EAAOP,KAAKO,KAClB,IAAIN,EAAUM,EAEd,GAEIQ,EAASd,GACTA,EAAUA,EAAQG,WACbH,IAAYM,GAGzBT,CAACU,OAAOC,YASJ,OAPKT,KAAKU,kBAENV,KAAKU,gBAAkB,IAAIb,EAA2BG,KAAKO,OAG/DP,KAAKU,gBAAgBC,MAAMX,KAAKO,MAEzBP,KAAKU"}