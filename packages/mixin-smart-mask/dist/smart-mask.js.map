{"version":3,"file":"smart-mask.js","sources":["../src/index.ts"],"sourcesContent":["import { Bounds, DisplayObject } from '@pixi/display';\nimport { Rectangle } from '@pixi/math';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\n\n// Shared rectangle pool\nconst rectanglePool = ObjectPoolFactory.build(Rectangle);\n\n// Temp bounds object to calculate the display-object's content bounds\nconst tempBounds = new Bounds();\n\n// Temp rect to store children bounds\nconst tempRect = new Rectangle();\n\n// Empty array to swap children\nconst EMPTY_ARRAY = [];\n\n/**\n * It enable smart-masking, set this property. Before rendering the scene graph, you must invoke\n * {@code updateSmartMask} on each display-object to enable masking.\n *\n * @type {PIXI.DisplayObject}\n */\nDisplayObject.prototype.smartMask = null;\n\n/**\n * Update the mask of the display-object based on whether its unmasked bounds are not a subset of the\n * smart-mask's bounds or are.\n *\n * NOTE: Setting the smart-mask to null will not remove the mask on the display-object, if it has already\n * been enabled.\n *\n * @method PIXI.DisplayObject#updateSmartMask\n * @param recursive - whether to update the smart-masks of the children as well. Traversing the scene\n *      graph on your own is less optimized due to bounds recalculations.\n * @param skipUpdate - whether to not recalculate the transforms of each display-object. This is false\n *      by default because it is expected you will do this on your own.\n */\nDisplayObject.prototype.updateSmartMask = function updateSmartMask(recursive = true, skipUpdate = true): Rectangle\n{\n    if (!this.smartMask)\n    {\n        if (recursive)\n        {\n            return this.getBounds(skipUpdate, rectanglePool.allocate());\n        }\n\n        return null;\n    }\n\n    const smartMask = this.smartMask;\n    const maskBounds = rectanglePool.allocate();\n    const unmaskedTargetBounds = rectanglePool.allocate();\n\n    smartMask.getBounds(skipUpdate, maskBounds);\n\n    if (!skipUpdate)\n    {\n        this._recursivePostUpdateTransform();\n\n        if (!this.parent)\n        {\n            this.parent = this._tempDisplayObjectParent;\n            this.displayObjectUpdateTransform();\n            this.parent = null;\n        }\n        else\n        {\n            this.displayObjectUpdateTransform();\n        }\n    }\n\n    // Match Container.calculateBounds except for not using the mask's bounds\n    if (this.filterArea)\n    {\n        unmaskedTargetBounds.copyFrom(this.filterArea);\n    }\n    else\n    {\n        const originalBounds = this._bounds;\n        const originalChildren = this.children;\n\n        tempBounds.clear();\n        this._bounds = tempBounds;\n        this.children = EMPTY_ARRAY;\n        this.calculateBounds();\n        this._bounds = originalBounds;\n        this.children = originalChildren;\n\n        // copyFrom needed if Rectangle.EMPTY is returned\n        unmaskedTargetBounds.copyFrom(tempBounds.getRectangle(unmaskedTargetBounds));\n    }\n\n    const children = this.children;\n\n    if (children && children.length)\n    {\n        // Use recursion to both update the smart-masks of children & calculate the unmasked target bounds\n        if (recursive)\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                const childBounds = child.updateSmartMask(true, skipUpdate);\n\n                unmaskedTargetBounds.enlarge(childBounds);\n                rectanglePool.release(childBounds);// Recursive updates require the caller to release the returned rectangle\n            }\n        }\n        else\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                unmaskedTargetBounds.enlarge(child.getBounds(skipUpdate, tempRect));\n            }\n        }\n    }\n\n    if (unmaskedTargetBounds.left < maskBounds.left\n            || unmaskedTargetBounds.top < maskBounds.top\n            || unmaskedTargetBounds.right > maskBounds.right\n            || unmaskedTargetBounds.bottom > maskBounds.bottom)\n    {\n        this.mask = smartMask;\n    }\n    else\n    {\n        this.mask = null;\n    }\n\n    if (recursive)\n    {\n        unmaskedTargetBounds.fit(maskBounds);\n        rectanglePool.release(maskBounds);\n\n        // NOTE: Recursive updates expect the caller to release to the child's calculated bounds rectangle.\n        return unmaskedTargetBounds;\n    }\n\n    rectanglePool.release(maskBounds);\n    rectanglePool.release(unmaskedTargetBounds);\n\n    return null;\n};\n"],"names":["ObjectPoolFactory","Rectangle","Bounds","DisplayObject"],"mappings":"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"}