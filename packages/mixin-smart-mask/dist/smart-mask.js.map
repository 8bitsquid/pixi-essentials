{"version":3,"file":"smart-mask.js","sources":["../src/index.ts"],"sourcesContent":["import { Bounds, DisplayObject } from '@pixi/display';\nimport { Rectangle } from '@pixi/math';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\n\n// Shared rectangle pool\nconst rectanglePool = ObjectPoolFactory.build(Rectangle);\n\n// Temp bounds object to calculate the display-object's content bounds\nconst tempBounds = new Bounds();\n\n// Temp rect to store children bounds\nconst tempRect = new Rectangle();\n\n// Empty array to swap children\nconst EMPTY_ARRAY = [];\n\n/**\n * It enable smart-masking, set this property. Before rendering the scene graph, you must invoke\n * {@code updateSmartMask} on each display-object to enable masking.\n *\n * @type {PIXI.DisplayObject}\n */\nDisplayObject.prototype.smartMask = null;\n\n/**\n * Update the mask of the display-object based on whether its unmasked bounds are not a subset of the\n * smart-mask's bounds or are.\n *\n * NOTE: Setting the smart-mask to null will not remove the mask on the display-object, if it has already\n * been enabled.\n *\n * @method PIXI.DisplayObject#updateSmartMask\n * @param recursive - whether to update the smart-masks of the children as well. Traversing the scene\n *      graph on your own is less optimized due to bounds recalculations.\n * @param skipUpdate - whether to not recalculate the transforms of each display-object. This is false\n *      by default because it is expected you will do this on your own.\n */\nDisplayObject.prototype.updateSmartMask = function updateSmartMask(recursive = true, skipUpdate = true): Rectangle\n{\n    if (!this.smartMask)\n    {\n        if (recursive)\n        {\n            return this.getBounds(skipUpdate, rectanglePool.allocate());\n        }\n\n        return null;\n    }\n\n    const smartMask = this.smartMask;\n    const maskBounds = rectanglePool.allocate();\n    const unmaskedTargetBounds = rectanglePool.allocate();\n\n    smartMask.getBounds(skipUpdate, maskBounds);\n\n    if (!skipUpdate)\n    {\n        this._recursivePostUpdateTransform();\n\n        if (!this.parent)\n        {\n            this.parent = this._tempDisplayObjectParent;\n            this.displayObjectUpdateTransform();\n            this.parent = null;\n        }\n        else\n        {\n            this.displayObjectUpdateTransform();\n        }\n    }\n\n    // Match Container.calculateBounds except for not using the mask's bounds\n    if (this.filterArea)\n    {\n        unmaskedTargetBounds.copyFrom(this.filterArea);\n    }\n    else\n    {\n        const originalBounds = this._bounds;\n        const originalChildren = this.children;\n\n        tempBounds.clear();\n        this._bounds = tempBounds;\n        this.children = EMPTY_ARRAY;\n        this.calculateBounds();\n        this._bounds = originalBounds;\n        this.children = originalChildren;\n\n        // copyFrom needed if Rectangle.EMPTY is returned\n        unmaskedTargetBounds.copyFrom(tempBounds.getRectangle(unmaskedTargetBounds));\n    }\n\n    const children = this.children;\n\n    if (children && children.length)\n    {\n        // Use recursion to both update the smart-masks of children & calculate the unmasked target bounds\n        if (recursive)\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                const childBounds = child.updateSmartMask(true, skipUpdate);\n\n                unmaskedTargetBounds.enlarge(childBounds);\n                rectanglePool.release(childBounds);// Recursive updates require the caller to release the returned rectangle\n            }\n        }\n        else\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                unmaskedTargetBounds.enlarge(child.getBounds(skipUpdate, tempRect));\n            }\n        }\n    }\n\n    if (unmaskedTargetBounds.left < maskBounds.left\n            || unmaskedTargetBounds.top < maskBounds.top\n            || unmaskedTargetBounds.right > maskBounds.right\n            || unmaskedTargetBounds.bottom > maskBounds.bottom)\n    {\n        this.mask = smartMask;\n    }\n    else\n    {\n        this.mask = null;\n    }\n\n    if (recursive)\n    {\n        unmaskedTargetBounds.fit(maskBounds);\n        rectanglePool.release(maskBounds);\n\n        // NOTE: Recursive updates expect the caller to release to the child's calculated bounds rectangle.\n        return unmaskedTargetBounds;\n    }\n\n    rectanglePool.release(maskBounds);\n    rectanglePool.release(unmaskedTargetBounds);\n\n    return null;\n};\n"],"names":["rectanglePool","ObjectPoolFactory","build","Rectangle","tempBounds","Bounds","tempRect","EMPTY_ARRAY","prototype","smartMask","updateSmartMask","recursive","skipUpdate","this","getBounds","allocate","maskBounds","unmaskedTargetBounds","_recursivePostUpdateTransform","parent","displayObjectUpdateTransform","_tempDisplayObjectParent","filterArea","copyFrom","originalBounds","_bounds","originalChildren","children","clear","calculateBounds","getRectangle","length","i","j","child","renderable","visible","childBounds","enlarge","release","left","top","right","bottom","mask","fit"],"mappings":";;;;;;;qDAKA,IAAMA,EAAgBC,oBAAkBC,MAAMC,aAGxCC,EAAa,IAAIC,SAGjBC,EAAW,IAAIH,YAGfI,EAAc,mBAQNC,UAAUC,UAAY,qBAetBD,UAAUE,gBAAkB,SAAyBC,EAAkBC,GAEjF,gBAF+DD,mBAAkBC,OAE5EC,KAAKJ,UAEN,OAAIE,EAEOE,KAAKC,UAAUF,EAAYZ,EAAce,YAG7C,KAGX,IAAMN,EAAYI,KAAKJ,UACjBO,EAAahB,EAAce,WAC3BE,EAAuBjB,EAAce,WAqB3C,GAnBAN,EAAUK,UAAUF,EAAYI,GAE3BJ,IAEDC,KAAKK,gCAEAL,KAAKM,OAQNN,KAAKO,gCANLP,KAAKM,OAASN,KAAKQ,yBACnBR,KAAKO,+BACLP,KAAKM,OAAS,OASlBN,KAAKS,WAELL,EAAqBM,SAASV,KAAKS,gBAGvC,CACI,IAAME,EAAiBX,KAAKY,QACtBC,EAAmBb,KAAKc,SAE9BvB,EAAWwB,QACXf,KAAKY,QAAUrB,EACfS,KAAKc,SAAWpB,EAChBM,KAAKgB,kBACLhB,KAAKY,QAAUD,EACfX,KAAKc,SAAWD,EAGhBT,EAAqBM,SAASnB,EAAW0B,aAAab,IAG1D,IAAMU,EAAWd,KAAKc,SAEtB,GAAIA,GAAYA,EAASI,OAGrB,GAAIpB,EAEA,IAAK,IAAIqB,EAAI,EAAGC,EAAIN,EAASI,OAAQC,EAAIC,EAAGD,IAC5C,CAGI,IAFME,EAAQP,EAASK,IAEZG,YAAeD,EAAME,QAAhC,CAKA,IAAMC,EAAcH,EAAMxB,iBAAgB,EAAME,GAEhDK,EAAqBqB,QAAQD,GAC7BrC,EAAcuC,QAAQF,SAK1B,IAASL,EAAI,EAAGC,EAAIN,EAASI,OAAQC,EAAIC,EAAGD,IAC5C,CACI,IAAME,GAAAA,EAAQP,EAASK,IAEZG,YAAeD,EAAME,SAKhCnB,EAAqBqB,QAAQJ,EAAMpB,UAAUF,EAAYN,IAiBrE,OAZIW,EAAqBuB,KAAOxB,EAAWwB,MAChCvB,EAAqBwB,IAAMzB,EAAWyB,KACtCxB,EAAqByB,MAAQ1B,EAAW0B,OACxCzB,EAAqB0B,OAAS3B,EAAW2B,OAEhD9B,KAAK+B,KAAOnC,EAIZI,KAAK+B,KAAO,KAGZjC,GAEAM,EAAqB4B,IAAI7B,GACzBhB,EAAcuC,QAAQvB,GAGfC,IAGXjB,EAAcuC,QAAQvB,GACtBhB,EAAcuC,QAAQtB,GAEf"}