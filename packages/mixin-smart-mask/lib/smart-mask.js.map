{"version":3,"file":"smart-mask.js","sources":["../src/index.ts"],"sourcesContent":["import { Bounds, DisplayObject } from '@pixi/display';\nimport { Rectangle } from '@pixi/math';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\n\n// Shared rectangle pool\nconst rectanglePool = ObjectPoolFactory.build(Rectangle);\n\n// Temp bounds object to calculate the display-object's content bounds\nconst tempBounds = new Bounds();\n\n// Temp rect to store children bounds\nconst tempRect = new Rectangle();\n\n// Empty array to swap children\nconst EMPTY_ARRAY = [];\n\n/**\n * It enable smart-masking, set this property. Before rendering the scene graph, you must invoke\n * {@code updateSmartMask} on each display-object to enable masking.\n *\n * @type {PIXI.DisplayObject}\n */\nDisplayObject.prototype.smartMask = null;\n\n/**\n * Update the mask of the display-object based on whether its unmasked bounds are not a subset of the\n * smart-mask's bounds or are.\n *\n * NOTE: Setting the smart-mask to null will not remove the mask on the display-object, if it has already\n * been enabled.\n *\n * @method PIXI.DisplayObject#updateSmartMask\n * @param recursive - whether to update the smart-masks of the children as well. Traversing the scene\n *      graph on your own is less optimized due to bounds recalculations.\n * @param skipUpdate - whether to not recalculate the transforms of each display-object. This is false\n *      by default because it is expected you will do this on your own.\n */\nDisplayObject.prototype.updateSmartMask = function updateSmartMask(recursive = true, skipUpdate = true): Rectangle\n{\n    if (!this.smartMask)\n    {\n        if (recursive)\n        {\n            return this.getBounds(skipUpdate, rectanglePool.allocate());\n        }\n\n        return null;\n    }\n\n    const smartMask = this.smartMask;\n    const maskBounds = rectanglePool.allocate();\n    const unmaskedTargetBounds = rectanglePool.allocate();\n\n    smartMask.getBounds(skipUpdate, maskBounds);\n\n    if (!skipUpdate)\n    {\n        this._recursivePostUpdateTransform();\n\n        if (!this.parent)\n        {\n            this.parent = this._tempDisplayObjectParent;\n            this.displayObjectUpdateTransform();\n            this.parent = null;\n        }\n        else\n        {\n            this.displayObjectUpdateTransform();\n        }\n    }\n\n    // Match Container.calculateBounds except for not using the mask's bounds\n    if (this.filterArea)\n    {\n        unmaskedTargetBounds.copyFrom(this.filterArea);\n    }\n    else\n    {\n        const originalBounds = this._bounds;\n        const originalChildren = this.children;\n\n        tempBounds.clear();\n        this._bounds = tempBounds;\n        this.children = EMPTY_ARRAY;\n        this.calculateBounds();\n        this._bounds = originalBounds;\n        this.children = originalChildren;\n\n        // copyFrom needed if Rectangle.EMPTY is returned\n        unmaskedTargetBounds.copyFrom(tempBounds.getRectangle(unmaskedTargetBounds));\n    }\n\n    const children = this.children;\n\n    if (children && children.length)\n    {\n        // Use recursion to both update the smart-masks of children & calculate the unmasked target bounds\n        if (recursive)\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                const childBounds = child.updateSmartMask(true, skipUpdate);\n\n                unmaskedTargetBounds.enlarge(childBounds);\n                rectanglePool.release(childBounds);// Recursive updates require the caller to release the returned rectangle\n            }\n        }\n        else\n        {\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                if (!child.renderable || !child.visible)\n                {\n                    continue;\n                }\n\n                unmaskedTargetBounds.enlarge(child.getBounds(skipUpdate, tempRect));\n            }\n        }\n    }\n\n    if (unmaskedTargetBounds.left < maskBounds.left\n            || unmaskedTargetBounds.top < maskBounds.top\n            || unmaskedTargetBounds.right > maskBounds.right\n            || unmaskedTargetBounds.bottom > maskBounds.bottom)\n    {\n        this.mask = smartMask;\n    }\n    else\n    {\n        this.mask = null;\n    }\n\n    if (recursive)\n    {\n        unmaskedTargetBounds.fit(maskBounds);\n        rectanglePool.release(maskBounds);\n\n        // NOTE: Recursive updates expect the caller to release to the child's calculated bounds rectangle.\n        return unmaskedTargetBounds;\n    }\n\n    rectanglePool.release(maskBounds);\n    rectanglePool.release(unmaskedTargetBounds);\n\n    return null;\n};\n"],"names":["ObjectPoolFactory","Rectangle","Bounds","DisplayObject"],"mappings":"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"}