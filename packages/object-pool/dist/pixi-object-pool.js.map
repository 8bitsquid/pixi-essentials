{"version":3,"file":"pixi-object-pool.js","sources":["../src/AverageProvider.ts","../src/ObjectPool.ts","../src/ObjectPoolFactory.ts"],"sourcesContent":["/**\n * Provides the exponential moving average of a sequence.\n *\n * Ignored because not directly exposed.\n *\n * @internal\n * @ignore\n * @class\n */\nexport class AverageProvider\n{\n    private _history: number[];\n    private _decayRatio: number;\n\n    private _currentIndex: number;\n    private _average: number;\n\n    /**\n     * @ignore\n     * @param {number} windowSize - no. of inputs used to calculate window\n     * @param {number} decayRatio - quantifies the weight of previous values (b/w 0 and 1)\n     */\n    constructor(windowSize: number, decayRatio: number)\n    {\n        this._history = new Array(windowSize);\n        this._decayRatio = decayRatio;\n\n        this._currentIndex = 0;\n\n        for (let i = 0; i < windowSize; i++)\n        {\n            this._history[i] = 0;\n        }\n    }\n\n    /**\n     * @ignore\n     * @param {number} input - the next value in the sequence\n     * @returns {number} - the moving average\n     */\n    next(input: number): number\n    {\n        const { _history: history, _decayRatio: decayRatio } = this;\n        const historyLength = history.length;\n\n        this._currentIndex = this._currentIndex < historyLength - 1 ? this._currentIndex + 1 : 0;\n        history[this._currentIndex] = input;\n\n        let weightedSum = 0;\n        let weight = 0;\n\n        for (let i = this._currentIndex + 1; i < historyLength; i++)\n        {\n            weightedSum = (weightedSum + history[i]) * decayRatio;\n            weight = (weight + 1) * decayRatio;\n        }\n        for (let i = 0; i <= this._currentIndex; i++)\n        {\n            weightedSum = (weightedSum + history[i]) * decayRatio;\n            weight = (weight + 1) * decayRatio;\n        }\n\n        this._average = weightedSum / weight;\n\n        return this._average;\n    }\n\n    absDev(): number\n    {\n        let errSum = 0;\n\n        for (let i = 0, j = this._history.length; i < j; i++)\n        {\n            errSum += Math.abs(this._history[i] - this._average);\n        }\n\n        return errSum / this._history.length;\n    }\n}\n","import { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { AverageProvider } from './AverageProvider';\n\n/**\n * @interface\n * @public\n */\nexport interface IObjectPoolOptions\n{\n    capacityRatio?: number;\n    decayRatio?: number;\n    reserve?: number;\n}\n\n/**\n * `ObjectPool` provides the framework necessary for pooling minus the object instantiation\n * method. You can use `ObjectPoolFactory` for objects that can be created using a default\n * constructor.\n *\n * @template T\n * @class\n * @public\n */\nexport abstract class ObjectPool<T extends typeof Object>\n{\n    protected _freeList: Array<T>;\n    protected _freeCount: number;\n    protected _reserveCount: number;\n\n    protected _borrowRate: number;\n    protected _returnRate: number;\n    protected _flowRate: number;\n    protected _borrowRateAverage: number;\n    protected _marginAverage: number;\n\n    private _capacityRatio: number;\n    private _decayRatio: number;\n    private _borrowRateAverageProvider: AverageProvider;\n    private _marginAverageProvider: AverageProvider;\n\n    /**\n     * @param {IObjectPoolOptions} options\n     */\n    constructor(options: IObjectPoolOptions = {})\n    {\n        /**\n         * Supply pool of objects that can be used to immediately lend.\n         *\n         * @member {Array<T>}\n         * @protected\n         */\n        this._freeList = [];\n\n        /**\n         * Number of objects in the pool. This is less than or equal to `_pool.length`.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._freeCount = 0;\n\n        this._borrowRate = 0;\n        this._returnRate = 0;\n        this._flowRate = 0;\n        this._borrowRateAverage = 0;\n\n        this._reserveCount = options.reserve || 0;\n        this._capacityRatio = options.capacityRatio || 1.2;\n        this._decayRatio = options.decayRatio || 0.67;\n        this._marginAverage = 0;\n        this._borrowRateAverageProvider = new AverageProvider(128, this._decayRatio);\n        this._marginAverageProvider = new AverageProvider(128, this._decayRatio);\n    }\n\n    /**\n     * Instantiates a new object of type `T`.\n     *\n     * @abstract\n     * @returns {T}\n     */\n    abstract create(): T;\n\n    // TODO: Support object destruction. It might not be so good for perf tho.\n    // /**\n    // * Destroys the object before discarding it.\n    // *\n    // * @param {T} object\n    //  */\n    // abstract destroyObject(object: T): void;\n\n    /**\n     * The number of objects that can be stored in the pool without allocating more space.\n     *\n     * @member {number}\n     */\n    protected get capacity(): number\n    {\n        return this._freeList.length;\n    }\n    protected set capacity(cp: number)\n    {\n        this._freeList.length = Math.ceil(cp);\n    }\n\n    /**\n     * Obtains an instance from this pool.\n     *\n     * @returns {T}\n     */\n    allocate(): T\n    {\n        ++this._borrowRate;\n\n        ++this._flowRate;\n\n        if (this._freeCount > 0)\n        {\n            return this._freeList[--this._freeCount];\n        }\n\n        return this.create();\n    }\n\n    /**\n     * Obtains an array of instances from this pool. This is faster than allocating multiple objects\n     * separately from this pool.\n     *\n     * @param {number | T[]} lengthOrArray - no. of objects to allocate OR the array itself into which\n     *      objects are inserted. The amount to allocate is inferred from the array's length.\n     * @returns {T[]} array of allocated objects\n     */\n    allocateArray(lengthOrArray: number | T[]): T[]\n    {\n        let array: T[];\n        let length: number;\n\n        if (Array.isArray(lengthOrArray))\n        {\n            array = lengthOrArray;\n            length = lengthOrArray.length;\n        }\n        else\n        {\n            length = lengthOrArray;\n            array = new Array(length);\n        }\n\n        this._borrowRate += length;\n        this._flowRate += length;\n\n        let filled = 0;\n\n        // Allocate as many objects from the existing pool\n        if (this._freeCount > 0)\n        {\n            const pool = this._freeList;\n            const poolFilled = Math.min(this._freeCount, length);\n            let poolSize = this._freeCount;\n\n            for (let i = 0; i < poolFilled; i++)\n            {\n                array[filled] = pool[poolSize - 1];\n                ++filled;\n                --poolSize;\n            }\n\n            this._freeCount = poolSize;\n        }\n\n        // Construct the rest of the allocation\n        while (filled < length)\n        {\n            array[filled] = this.create();\n            ++filled;\n        }\n\n        return array;\n    }\n\n    /**\n     * Returns the object to the pool.\n     *\n     * @param {T} object\n     */\n    release(object: T): void\n    {\n        ++this._returnRate;\n        --this._flowRate;\n\n        if (this._freeCount === this.capacity)\n        {\n            this.capacity *= this._capacityRatio;\n        }\n\n        this._freeList[this._freeCount] = object;\n        ++this._freeCount;\n    }\n\n    /**\n     * Releases all of the objects in the passed array. These need not be allocated using `allocateArray`, however.\n     *\n     * @param {T[]} array\n     */\n    releaseArray(array: T[]): void\n    {\n        this._returnRate += array.length;\n        this._flowRate -= array.length;\n\n        if (this._freeCount + array.length > this.capacity)\n        {\n            // Ensure we have enough capacity to insert the release objects\n            this.capacity = Math.max(this.capacity * this._capacityRatio, this._freeCount + array.length);\n        }\n\n        // Place objects into pool list\n        for (let i = 0, j = array.length; i < j; i++)\n        {\n            this._freeList[this._freeCount] = array[i];\n            ++this._freeCount;\n        }\n    }\n\n    /**\n     * Preallocates objects so that the pool size is at least `count`.\n     *\n     * @param {number} count\n     */\n    reserve(count: number): void\n    {\n        this._reserveCount = count;\n\n        if (this._freeCount < count)\n        {\n            const diff = this._freeCount - count;\n\n            for (let i = 0; i < diff; i++)\n            {\n                this._freeList[this._freeCount] = this.create();\n                ++this._freeCount;\n            }\n        }\n    }\n\n    /**\n     * Dereferences objects for the GC to collect and brings the pool size down to `count`.\n     *\n     * @param {number} count\n     */\n    limit(count: number): void\n    {\n        if (this._freeCount > count)\n        {\n            const oldCapacity = this.capacity;\n\n            if (oldCapacity > count * this._capacityRatio)\n            {\n                this.capacity = count * this._capacityRatio;\n            }\n\n            const excessBound = Math.min(this._freeCount, this.capacity);\n\n            for (let i = count; i < excessBound; i++)\n            {\n                this._freeList[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Install the GC on the shared ticker.\n     *\n     * @param {Ticker}[ticker=Ticker.shared]\n     */\n    startGC(ticker: Ticker = Ticker.shared): void\n    {\n        ticker.add(this._gcTick, null, UPDATE_PRIORITY.UTILITY);\n    }\n\n    /**\n     * Stops running the GC on the pool.\n     *\n     * @param {Ticker}[ticker=Ticker.shared]\n     */\n    stopGC(ticker: Ticker = Ticker.shared): void\n    {\n        ticker.remove(this._gcTick);\n    }\n\n    private _gcTick = (): void =>\n    {\n        this._borrowRateAverage = this._borrowRateAverageProvider.next(this._borrowRate);\n        this._marginAverage = this._marginAverageProvider.next(this._freeCount - this._borrowRate);\n\n        const absDev = this._borrowRateAverageProvider.absDev();\n\n        this._flowRate = 0;\n        this._borrowRate = 0;\n        this._returnRate = 0;\n\n        const poolSize = this._freeCount;\n        const poolCapacity = this._freeList.length;\n\n        // If the pool is small enough, it shouldn't really matter\n        if (poolSize < 128 && this._borrowRateAverage < 128 && poolCapacity < 128)\n        {\n            return;\n        }\n\n        // If pool is say, 2x, larger than borrowing rate on average (adjusted for variance/abs-dev), then downsize.\n        const threshold = Math.max(this._borrowRateAverage * (this._capacityRatio - 1), this._reserveCount);\n\n        if (this._freeCount > threshold + absDev)\n        {\n            const newCap = threshold + absDev;\n\n            this.capacity = Math.min(this._freeList.length, Math.ceil(newCap));\n            this._freeCount = this._freeList.length;\n        }\n    };\n}\n","import { ObjectPool } from './ObjectPool';\n\nconst poolMap: Map<typeof Object, ObjectPool<any>> = new Map();\n\n/**\n * Factory for creating pools of objects with default constructors. It will store the pool of\n * a given type and reuse it on further builds.\n *\n * @class\n * @public\n * @example\n * ```js\n * import { ObjectPool, ObjectPoolFactory } from 'pixi-object-pool';\n *\n * class AABB {}\n *\n * const opool: ObjectPool<AABB> = ObjectPoolFactory.build(AABB) as ObjectPool<AABB>;\n *\n * const temp = opool.borrowObject();\n * // do something\n * opool.returnObject(temp);\n * ```\n */\nexport class ObjectPoolFactory\n{\n    /**\n     * @param {Class} Type\n     */\n    static build(Type: typeof Object): ObjectPool<any>\n    {\n        let pool = poolMap.get(Type);\n\n        if (pool)\n        {\n            return pool;\n        }\n\n        pool = new (class DefaultObjectPool extends ObjectPool<any>\n        {\n            create(): any\n            {\n                return new Type();\n            }\n        })();\n\n        poolMap.set(Type, pool);\n\n        return pool;\n    }\n}\n"],"names":["AverageProvider","[object Object]","windowSize","decayRatio","this","_history","Array","_decayRatio","_currentIndex","i","input","history","historyLength","length","weightedSum","weight","_average","errSum","j","Math","abs","ObjectPool","options","_borrowRateAverage","_borrowRateAverageProvider","next","_borrowRate","_marginAverage","_marginAverageProvider","_freeCount","absDev","_flowRate","_returnRate","poolSize","poolCapacity","_freeList","threshold","max","_capacityRatio","_reserveCount","newCap","capacity","min","ceil","reserve","capacityRatio","cp","create","lengthOrArray","array","isArray","filled","pool","poolFilled","object","count","diff","excessBound","ticker","Ticker","shared","add","_gcTick","UPDATE_PRIORITY","UTILITY","remove","poolMap","Map","Type","get","set"],"mappings":"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"}