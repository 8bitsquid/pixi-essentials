{"version":3,"file":"pixi-object-pool.js","sources":["../src/AverageProvider.ts","../src/ObjectPool.ts","../src/ObjectPoolFactory.ts"],"sourcesContent":["/**\n * Provides the exponential moving average of a sequence.\n *\n * Ignored because not directly exposed.\n *\n * @internal\n * @ignore\n * @class\n */\nexport class AverageProvider\n{\n    private _history: number[];\n    private _decayRatio: number;\n\n    private _currentIndex: number;\n    private _average: number;\n\n    /**\n     * @ignore\n     * @param {number} windowSize - no. of inputs used to calculate window\n     * @param {number} decayRatio - quantifies the weight of previous values (b/w 0 and 1)\n     */\n    constructor(windowSize: number, decayRatio: number)\n    {\n        this._history = new Array(windowSize);\n        this._decayRatio = decayRatio;\n\n        this._currentIndex = 0;\n\n        for (let i = 0; i < windowSize; i++)\n        {\n            this._history[i] = 0;\n        }\n    }\n\n    /**\n     * @ignore\n     * @param {number} input - the next value in the sequence\n     * @returns {number} - the moving average\n     */\n    next(input: number): number\n    {\n        const { _history: history, _decayRatio: decayRatio } = this;\n        const historyLength = history.length;\n\n        this._currentIndex = this._currentIndex < historyLength - 1 ? this._currentIndex + 1 : 0;\n        history[this._currentIndex] = input;\n\n        let weightedSum = 0;\n        let weight = 0;\n\n        for (let i = this._currentIndex + 1; i < historyLength; i++)\n        {\n            weightedSum = (weightedSum + history[i]) * decayRatio;\n            weight = (weight + 1) * decayRatio;\n        }\n        for (let i = 0; i <= this._currentIndex; i++)\n        {\n            weightedSum = (weightedSum + history[i]) * decayRatio;\n            weight = (weight + 1) * decayRatio;\n        }\n\n        this._average = weightedSum / weight;\n\n        return this._average;\n    }\n\n    absDev(): number\n    {\n        let errSum = 0;\n\n        for (let i = 0, j = this._history.length; i < j; i++)\n        {\n            errSum += Math.abs(this._history[i] - this._average);\n        }\n\n        return errSum / this._history.length;\n    }\n}\n","import { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { AverageProvider } from './AverageProvider';\n\n/**\n * @interface\n * @public\n */\nexport interface IObjectPoolOptions\n{\n    capacityRatio?: number;\n    decayRatio?: number;\n    reserve?: number;\n}\n\n/**\n * `ObjectPool` provides the framework necessary for pooling minus the object instantiation\n * method. You can use `ObjectPoolFactory` for objects that can be created using a default\n * constructor.\n *\n * @template T\n * @class\n * @public\n */\nexport abstract class ObjectPool<T extends typeof Object>\n{\n    protected _freeList: Array<T>;\n    protected _freeCount: number;\n    protected _reserveCount: number;\n\n    protected _borrowRate: number;\n    protected _returnRate: number;\n    protected _flowRate: number;\n    protected _borrowRateAverage: number;\n    protected _marginAverage: number;\n\n    private _capacityRatio: number;\n    private _decayRatio: number;\n    private _borrowRateAverageProvider: AverageProvider;\n    private _marginAverageProvider: AverageProvider;\n\n    /**\n     * @param {IObjectPoolOptions} options\n     */\n    constructor(options: IObjectPoolOptions = {})\n    {\n        /**\n         * Supply pool of objects that can be used to immediately lend.\n         *\n         * @member {Array<T>}\n         * @protected\n         */\n        this._freeList = [];\n\n        /**\n         * Number of objects in the pool. This is less than or equal to `_pool.length`.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._freeCount = 0;\n\n        this._borrowRate = 0;\n        this._returnRate = 0;\n        this._flowRate = 0;\n        this._borrowRateAverage = 0;\n\n        this._reserveCount = options.reserve || 0;\n        this._capacityRatio = options.capacityRatio || 1.2;\n        this._decayRatio = options.decayRatio || 0.67;\n        this._marginAverage = 0;\n        this._borrowRateAverageProvider = new AverageProvider(128, this._decayRatio);\n        this._marginAverageProvider = new AverageProvider(128, this._decayRatio);\n    }\n\n    /**\n     * Instantiates a new object of type `T`.\n     *\n     * @abstract\n     * @returns {T}\n     */\n    abstract create(): T;\n\n    // TODO: Support object destruction. It might not be so good for perf tho.\n    // /**\n    // * Destroys the object before discarding it.\n    // *\n    // * @param {T} object\n    //  */\n    // abstract destroyObject(object: T): void;\n\n    /**\n     * The number of objects that can be stored in the pool without allocating more space.\n     *\n     * @member {number}\n     */\n    protected get capacity(): number\n    {\n        return this._freeList.length;\n    }\n    protected set capacity(cp: number)\n    {\n        this._freeList.length = Math.ceil(cp);\n    }\n\n    /**\n     * Obtains an instance from this pool.\n     *\n     * @returns {T}\n     */\n    allocate(): T\n    {\n        ++this._borrowRate;\n\n        ++this._flowRate;\n\n        if (this._freeCount > 0)\n        {\n            return this._freeList[--this._freeCount];\n        }\n\n        return this.create();\n    }\n\n    /**\n     * Obtains an array of instances from this pool. This is faster than allocating multiple objects\n     * separately from this pool.\n     *\n     * @param {number | T[]} lengthOrArray - no. of objects to allocate OR the array itself into which\n     *      objects are inserted. The amount to allocate is inferred from the array's length.\n     * @returns {T[]} array of allocated objects\n     */\n    allocateArray(lengthOrArray: number | T[]): T[]\n    {\n        let array: T[];\n        let length: number;\n\n        if (Array.isArray(lengthOrArray))\n        {\n            array = lengthOrArray;\n            length = lengthOrArray.length;\n        }\n        else\n        {\n            length = lengthOrArray;\n            array = new Array(length);\n        }\n\n        this._borrowRate += length;\n        this._flowRate += length;\n\n        let filled = 0;\n\n        // Allocate as many objects from the existing pool\n        if (this._freeCount > 0)\n        {\n            const pool = this._freeList;\n            const poolFilled = Math.min(this._freeCount, length);\n            let poolSize = this._freeCount;\n\n            for (let i = 0; i < poolFilled; i++)\n            {\n                array[filled] = pool[poolSize - 1];\n                ++filled;\n                --poolSize;\n            }\n\n            this._freeCount = poolSize;\n        }\n\n        // Construct the rest of the allocation\n        while (filled < length)\n        {\n            array[filled] = this.create();\n            ++filled;\n        }\n\n        return array;\n    }\n\n    /**\n     * Returns the object to the pool.\n     *\n     * @param {T} object\n     */\n    release(object: T): void\n    {\n        ++this._returnRate;\n        --this._flowRate;\n\n        if (this._freeCount === this.capacity)\n        {\n            this.capacity *= this._capacityRatio;\n        }\n\n        this._freeList[this._freeCount] = object;\n        ++this._freeCount;\n    }\n\n    /**\n     * Releases all of the objects in the passed array. These need not be allocated using `allocateArray`, however.\n     *\n     * @param {T[]} array\n     */\n    releaseArray(array: T[]): void\n    {\n        this._returnRate += array.length;\n        this._flowRate -= array.length;\n\n        if (this._freeCount + array.length > this.capacity)\n        {\n            // Ensure we have enough capacity to insert the release objects\n            this.capacity = Math.max(this.capacity * this._capacityRatio, this._freeCount + array.length);\n        }\n\n        // Place objects into pool list\n        for (let i = 0, j = array.length; i < j; i++)\n        {\n            this._freeList[this._freeCount] = array[i];\n            ++this._freeCount;\n        }\n    }\n\n    /**\n     * Preallocates objects so that the pool size is at least `count`.\n     *\n     * @param {number} count\n     */\n    reserve(count: number): void\n    {\n        this._reserveCount = count;\n\n        if (this._freeCount < count)\n        {\n            const diff = this._freeCount - count;\n\n            for (let i = 0; i < diff; i++)\n            {\n                this._freeList[this._freeCount] = this.create();\n                ++this._freeCount;\n            }\n        }\n    }\n\n    /**\n     * Dereferences objects for the GC to collect and brings the pool size down to `count`.\n     *\n     * @param {number} count\n     */\n    limit(count: number): void\n    {\n        if (this._freeCount > count)\n        {\n            const oldCapacity = this.capacity;\n\n            if (oldCapacity > count * this._capacityRatio)\n            {\n                this.capacity = count * this._capacityRatio;\n            }\n\n            const excessBound = Math.min(this._freeCount, this.capacity);\n\n            for (let i = count; i < excessBound; i++)\n            {\n                this._freeList[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Install the GC on the shared ticker.\n     *\n     * @param {Ticker}[ticker=Ticker.shared]\n     */\n    startGC(ticker: Ticker = Ticker.shared): void\n    {\n        ticker.add(this._gcTick, null, UPDATE_PRIORITY.UTILITY);\n    }\n\n    /**\n     * Stops running the GC on the pool.\n     *\n     * @param {Ticker}[ticker=Ticker.shared]\n     */\n    stopGC(ticker: Ticker = Ticker.shared): void\n    {\n        ticker.remove(this._gcTick);\n    }\n\n    private _gcTick = (): void =>\n    {\n        this._borrowRateAverage = this._borrowRateAverageProvider.next(this._borrowRate);\n        this._marginAverage = this._marginAverageProvider.next(this._freeCount - this._borrowRate);\n\n        const absDev = this._borrowRateAverageProvider.absDev();\n\n        this._flowRate = 0;\n        this._borrowRate = 0;\n        this._returnRate = 0;\n\n        const poolSize = this._freeCount;\n        const poolCapacity = this._freeList.length;\n\n        // If the pool is small enough, it shouldn't really matter\n        if (poolSize < 128 && this._borrowRateAverage < 128 && poolCapacity < 128)\n        {\n            return;\n        }\n\n        // If pool is say, 2x, larger than borrowing rate on average (adjusted for variance/abs-dev), then downsize.\n        const threshold = Math.max(this._borrowRateAverage * (this._capacityRatio - 1), this._reserveCount);\n\n        if (this._freeCount > threshold + absDev)\n        {\n            const newCap = threshold + absDev;\n\n            this.capacity = Math.min(this._freeList.length, Math.ceil(newCap));\n            this._freeCount = this._freeList.length;\n        }\n    };\n}\n","import { ObjectPool } from './ObjectPool';\n\nconst poolMap: Map<typeof Object, ObjectPool<any>> = new Map();\n\n/**\n * Factory for creating pools of objects with default constructors. It will store the pool of\n * a given type and reuse it on further builds.\n *\n * @class\n * @public\n * @example\n * ```js\n * import { ObjectPool, ObjectPoolFactory } from 'pixi-object-pool';\n *\n * class AABB {}\n *\n * const opool: ObjectPool<AABB> = ObjectPoolFactory.build(AABB) as ObjectPool<AABB>;\n *\n * const temp = opool.borrowObject();\n * // do something\n * opool.returnObject(temp);\n * ```\n */\nexport class ObjectPoolFactory\n{\n    /**\n     * @param {Class} Type\n     */\n    static build(Type: typeof Object): ObjectPool<any>\n    {\n        let pool = poolMap.get(Type);\n\n        if (pool)\n        {\n            return pool;\n        }\n\n        pool = new (class DefaultObjectPool extends ObjectPool<any>\n        {\n            create(): any\n            {\n                return new Type();\n            }\n        })();\n\n        poolMap.set(Type, pool);\n\n        return pool;\n    }\n}\n"],"names":["windowSize","decayRatio","this","_history","Array","_decayRatio","_currentIndex","i","AverageProvider","input","history","historyLength","length","weightedSum","weight","_average","errSum","j","Math","abs","options","_this","_borrowRateAverage","_borrowRateAverageProvider","next","_borrowRate","_marginAverage","_marginAverageProvider","_freeCount","absDev","_flowRate","_returnRate","poolSize","poolCapacity","_freeList","threshold","max","_capacityRatio","_reserveCount","newCap","capacity","min","ceil","reserve","capacityRatio","Object","ObjectPool","cp","create","lengthOrArray","array","isArray","filled","pool","poolFilled","object","count","diff","excessBound","ticker","Ticker","shared","add","_gcTick","UPDATE_PRIORITY","UTILITY","remove","poolMap","Map","ObjectPoolFactory","Type","get","__extends","DefaultObjectPool","set"],"mappings":";;;;;;;;;;;;;;;;;;;;;4QASA,iBAaI,WAAYA,EAAoBC,GAE5BC,KAAKC,SAAW,IAAIC,MAAMJ,GAC1BE,KAAKG,YAAcJ,EAEnBC,KAAKI,cAAgB,EAErB,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAYO,IAE5BL,KAAKC,SAASI,GAAK,EA+C/B,OAtCIC,iBAAA,SAAKC,GAEK,IAAYC,EAAqCR,cAAfD,EAAeC,iBACjDS,EAAgBD,EAAQE,OAE9BV,KAAKI,cAAgBJ,KAAKI,cAAgBK,EAAgB,EAAIT,KAAKI,cAAgB,EAAI,EACvFI,EAAQR,KAAKI,eAAiBG,EAK9B,IAHA,IAAII,EAAc,EACdC,EAAS,EAEJP,EAAIL,KAAKI,cAAgB,EAAGC,EAAII,EAAeJ,IAEpDM,GAAeA,EAAcH,EAAQH,IAAMN,EAC3Ca,GAAUA,EAAS,GAAKb,EAE5B,IAASM,EAAI,EAAGA,GAAKL,KAAKI,cAAeC,IAErCM,GAAeA,EAAcH,EAAQH,IAAMN,EAC3Ca,GAAUA,EAAS,GAAKb,EAK5B,OAFAC,KAAKa,SAAWF,EAAcC,EAEvBZ,KAAKa,UAGhBP,mBAAA,WAII,IAFA,IAAIQ,EAAS,EAEJT,EAAI,EAAGU,EAAIf,KAAKC,SAASS,OAAQL,EAAIU,EAAGV,IAE7CS,GAAUE,KAAKC,IAAIjB,KAAKC,SAASI,GAAKL,KAAKa,UAG/C,OAAOC,EAASd,KAAKC,SAASS,0BCjClC,WAAYQ,GAAZ,wBAAYA,MAqPJlB,aAAU,WAEdmB,EAAKC,mBAAqBD,EAAKE,2BAA2BC,KAAKH,EAAKI,aACpEJ,EAAKK,eAAiBL,EAAKM,uBAAuBH,KAAKH,EAAKO,WAAaP,EAAKI,aAE9E,IAAMI,EAASR,EAAKE,2BAA2BM,SAE/CR,EAAKS,UAAY,EACjBT,EAAKI,YAAc,EACnBJ,EAAKU,YAAc,EAEnB,IAAMC,EAAWX,EAAKO,WAChBK,EAAeZ,EAAKa,UAAUtB,OAGpC,KAAIoB,EAAW,KAAOX,EAAKC,mBAAqB,KAAOW,EAAe,KAAtE,CAMA,IAAME,EAAYjB,KAAKkB,IAAIf,EAAKC,oBAAsBD,EAAKgB,eAAiB,GAAIhB,EAAKiB,eAErF,GAAIjB,EAAKO,WAAaO,EAAYN,EAClC,CACI,IAAMU,EAASJ,EAAYN,EAE3BR,EAAKmB,SAAWtB,KAAKuB,IAAIpB,EAAKa,UAAUtB,OAAQM,KAAKwB,KAAKH,IAC1DlB,EAAKO,WAAaP,EAAKa,UAAUtB,UAzQrCV,KAAKgC,UAAY,GAQjBhC,KAAK0B,WAAa,EAElB1B,KAAKuB,YAAc,EACnBvB,KAAK6B,YAAc,EACnB7B,KAAK4B,UAAY,EACjB5B,KAAKoB,mBAAqB,EAE1BpB,KAAKoC,cAAgBlB,EAAQuB,SAAW,EACxCzC,KAAKmC,eAAiBjB,EAAQwB,eAAiB,IAC/C1C,KAAKG,YAAce,EAAQnB,YAAc,IACzCC,KAAKwB,eAAiB,EACtBxB,KAAKqB,2BAA6B,IAAIf,EAAgB,IAAKN,KAAKG,aAChEH,KAAKyB,uBAAyB,IAAInB,EAAgB,IAAKN,KAAKG,aAwPpE,OAhOIwC,sBAAcC,4BAAd,WAEI,OAAO5C,KAAKgC,UAAUtB,YAE1B,SAAuBmC,GAEnB7C,KAAKgC,UAAUtB,OAASM,KAAKwB,KAAKK,oCAQtCD,qBAAA,WAMI,QAJE5C,KAAKuB,cAELvB,KAAK4B,UAEH5B,KAAK0B,WAAa,EAEX1B,KAAKgC,YAAYhC,KAAK0B,YAG1B1B,KAAK8C,UAWhBF,0BAAA,SAAcG,GAEV,IAAIC,EACAtC,EAEAR,MAAM+C,QAAQF,IAEdC,EAAQD,EACRrC,EAASqC,EAAcrC,SAIvBA,EAASqC,EACTC,EAAQ,IAAI9C,MAAMQ,IAGtBV,KAAKuB,aAAeb,EACpBV,KAAK4B,WAAalB,EAElB,IAAIwC,EAAS,EAGb,GAAIlD,KAAK0B,WAAa,EACtB,CAKI,IAJA,IAAMyB,EAAOnD,KAAKgC,UACZoB,EAAapC,KAAKuB,IAAIvC,KAAK0B,WAAYhB,GACzCoB,EAAW9B,KAAK0B,WAEXrB,EAAI,EAAGA,EAAI+C,EAAY/C,IAE5B2C,EAAME,GAAUC,EAAKrB,EAAW,KAC9BoB,IACApB,EAGN9B,KAAK0B,WAAaI,EAItB,KAAOoB,EAASxC,GAEZsC,EAAME,GAAUlD,KAAK8C,WACnBI,EAGN,OAAOF,GAQXJ,oBAAA,SAAQS,KAEFrD,KAAK6B,cACL7B,KAAK4B,UAEH5B,KAAK0B,aAAe1B,KAAKsC,WAEzBtC,KAAKsC,UAAYtC,KAAKmC,gBAG1BnC,KAAKgC,UAAUhC,KAAK0B,YAAc2B,IAChCrD,KAAK0B,YAQXkB,yBAAA,SAAaI,GAEThD,KAAK6B,aAAemB,EAAMtC,OAC1BV,KAAK4B,WAAaoB,EAAMtC,OAEpBV,KAAK0B,WAAasB,EAAMtC,OAASV,KAAKsC,WAGtCtC,KAAKsC,SAAWtB,KAAKkB,IAAIlC,KAAKsC,SAAWtC,KAAKmC,eAAgBnC,KAAK0B,WAAasB,EAAMtC,SAI1F,IAAK,IAAIL,EAAI,EAAGU,EAAIiC,EAAMtC,OAAQL,EAAIU,EAAGV,IAErCL,KAAKgC,UAAUhC,KAAK0B,YAAcsB,EAAM3C,KACtCL,KAAK0B,YASfkB,oBAAA,SAAQU,GAIJ,GAFAtD,KAAKoC,cAAgBkB,EAEjBtD,KAAK0B,WAAa4B,EAIlB,IAFA,IAAMC,EAAOvD,KAAK0B,WAAa4B,EAEtBjD,EAAI,EAAGA,EAAIkD,EAAMlD,IAEtBL,KAAKgC,UAAUhC,KAAK0B,YAAc1B,KAAK8C,WACrC9C,KAAK0B,YAUnBkB,kBAAA,SAAMU,GAEF,GAAItD,KAAK0B,WAAa4B,EACtB,CACwBtD,KAAKsC,SAEPgB,EAAQtD,KAAKmC,iBAE3BnC,KAAKsC,SAAWgB,EAAQtD,KAAKmC,gBAKjC,IAFA,IAAMqB,EAAcxC,KAAKuB,IAAIvC,KAAK0B,WAAY1B,KAAKsC,UAE1CjC,EAAIiD,EAAOjD,EAAImD,EAAanD,IAEjCL,KAAKgC,UAAU3B,GAAK,OAUhCuC,oBAAA,SAAQa,gBAAAA,EAAiBC,SAAOC,QAE5BF,EAAOG,IAAI5D,KAAK6D,QAAS,KAAMC,kBAAgBC,UAQnDnB,mBAAA,SAAOa,gBAAAA,EAAiBC,SAAOC,QAE3BF,EAAOO,OAAOhE,KAAK6D,eC3RrBI,EAA+C,IAAIC,iBAqBzD,cA0BA,OArBWC,QAAP,SAAaC,GAET,IAAIjB,EAAOc,EAAQI,IAAID,GAEvB,OAAIjB,IAKJA,EAAO,gBAAK,4DAMZ,kIAN4CmB,MAExCC,mBAAA,WAEI,OAAO,IAAIH,MAJyBxB,IAQ5CqB,EAAQO,IAAIJ,EAAMjB,GAEXA"}