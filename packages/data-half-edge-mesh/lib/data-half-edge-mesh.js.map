{"version":3,"file":"data-half-edge-mesh.js","sources":["../src/Face.ts","../src/HalfEdge.ts","../src/Vertex.ts"],"sourcesContent":["import { HalfEdge } from './HalfEdge';\n\nimport type { IDoublyLinkedListNode } from '@pixi-essentials/types';\n\n/**\n * Iterator for traversing over the edges forming a loop around a face. It loops in the counterclockwise\n * direction.\n *\n * In order to guarantee that each edge is encountered only once, the face's edge list not be modified.\n *\n * You can get the shared iterator of a {@code Face}: `face[Symbol.iterator]`\n */\nexport class EdgeLoopIterator<V, E, F> implements Iterator<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n{\n    protected current: HalfEdge;\n    protected face: Face;\n    protected done: boolean;\n\n    /**\n     * @param face - the face around which to iterate\n     */\n    constructor(face: Face<V, E, F>)\n    {\n        /**\n         * The last half-edge returned by {@code this.next}.\n         */\n        this.current = null;\n\n        /**\n         * The face this iterator will iterate over.\n         */\n        this.face = face;\n\n        /**\n         * Whether this iterator has looped over all the edges of {@code this.face}.\n         */\n        this.done = false;\n    }\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators\n     */\n    next(): IteratorResult<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n    {\n        if (!this.current)\n        {\n            this.current = this.face.anEdge;\n        }\n        else if (this.current.next !== this.face.anEdge)\n        {\n            this.current = this.current.next;\n        }\n        else\n        {\n            this.current = null;\n            this.done = true;\n        }\n\n        return {\n            value: this.current,\n            done: this.done,\n        };\n    }\n\n    /**\n     * Reset this iterator so it can be used from start.\n     */\n    reset(): this\n    {\n        this.current = null;\n        this.done = false;\n\n        return this;\n    }\n}\n\n/**\n * A face is bounded by a loop of edges.\n *\n * You can use a for..of loop to iterate over the edges looping around this face:\n * ```js\n * // Loops in counterclockwise direction\n * for (const edge of face)\n * {\n *     assert(edge.leftFace === face);\n * }\n * ```\n */\nexport class Face<V = any, E = any, F = any> implements IDoublyLinkedListNode, Iterable<HalfEdge<V, E, F>>\n{\n    public next: this;\n    public previous: this;\n\n    anEdge: HalfEdge<V, E, F>;\n\n    data: F;\n\n    private _edgeLoopIterator: EdgeLoopIterator<V, E, F>;\n\n    constructor(data?: F)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n\n    [Symbol.iterator](): Iterator<HalfEdge<V, E, F>, any, undefined>\n    {\n        if (!this._edgeLoopIterator)\n        {\n            this._edgeLoopIterator = new EdgeLoopIterator(this);\n        }\n\n        return this._edgeLoopIterator;\n    }\n}\n","import type { ILinkedListNode } from '@pixi-essentials/types';\nimport type { Vertex } from './Vertex';\nimport type { Face } from './Face';\n\n/**\n * A directed edge from its origin to destination.\n *\n * {@code HalfEdge} is a node of the following circular linked-lists:\n *  + the list of edges in the whole mesh: {@link HalfEdge#next}\n *  + the list of edges around its left face: {@link HalfEdge#lnext}\n *  + the list of edges directed from its origin vertex: {@link HalfEdge#onext}\n *  + the list of edges directed to its destination vertex: {@link HalfEdge#dnext}\n *  + the list of edges around its right face: {@link HalfEdge#rnext}\n */\nexport class HalfEdge<V = any, E = any, F = any> implements ILinkedListNode\n{\n    next: this;\n\n    _lnext: this;\n    _onext: this;\n\n    _origin: Vertex<V, E, F>;\n    _twin: HalfEdge<V, E, F>;\n    _leftFace: Face<V, E, F>;\n\n    data: E;\n\n    constructor(data?: E)\n    {\n        this.data = data;\n\n        this._onext = this;\n    }\n\n    connect(origin: Vertex<V, E, F>, twin: HalfEdge, leftFace?: Face): this\n    {\n        this._origin = origin;\n        this._twin = twin;\n        this._leftFace = leftFace;\n\n        return this;\n    }\n\n    get previous(): HalfEdge<V, E, F>\n    {\n        return this._twin.next;\n    }\n\n    /**\n     * The origin vertex\n     */\n    get org(): Vertex<V, E, F>\n    {\n        return this._origin;\n    }\n\n    /**\n     * The destination vertex\n     */\n    get dst(): Vertex<V, E, F>\n    {\n        return this._twin._origin;\n    }\n\n    /**\n     * The next edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dnext(): HalfEdge<V, E, F>\n    {\n        return this.rnext.twin;\n    }\n\n    /**\n     * The last edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dlast(): HalfEdge<V, E, F>\n    {\n        return this.lnext.twin;\n    }\n\n    /**\n     * The next edge sharing {@code this.org} in the counterclockwise direction.\n     */\n    get onext(): HalfEdge<V, E, F>\n    {\n        return this._onext;\n    }\n\n    /**\n     * The previous edge sharing {@code this.org} in the counterclockwise direction. It is also\n     * the next edge in the clockwise direction.\n     */\n    get oprev(): HalfEdge<V, E, F>\n    {\n        return this.twin.lnext;\n    }\n\n    /**\n     * The next edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lnext}'s origin vertex is this edge's destination vertex.\n     */\n    get lnext(): HalfEdge<V, E, F>\n    {\n        return this._lnext;\n    }\n\n    /**\n     * The previous edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lprev}'s destination vertex is this edge's origin vertex.\n     */\n    get lprev(): HalfEdge<V, E, F>\n    {\n        return this._onext.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rnext}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rnext}'s destination vertex is this edge's origin vertex.\n     */\n    get rnext(): HalfEdge<V, E, F>\n    {\n        return this.oprev.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rlast}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rlast}'s origin vertex is this edge's destination vertex.\n     */\n    get rlast(): HalfEdge<V, E, F>\n    {\n        return this.twin.onext;\n    }\n\n    /**\n     * The half-edge directed from {@code this.dst}.\n     */\n    get twin(): HalfEdge<V, E, F>\n    {\n        return this._twin;\n    }\n\n    /**\n     * The face on the left side of this edge. This edge is oriented counterclockwise to its left face.\n     */\n    get leftFace(): Face<V, E, F>\n    {\n        return this._leftFace;\n    }\n\n    /**\n     * The face on the right side of this edge. This edge is oriented clockwise to its right face.\n     */\n    get rightFace(): Face<V, E, F>\n    {\n        return this._twin.leftFace;\n    }\n}\n","import type { IDoublyLinkedListNode } from '@pixi-essentials/types';\nimport type { HalfEdge } from './HalfEdge';\n\n/**\n *\n */\nexport class Vertex<V = any, E = any, F = any> implements IDoublyLinkedListNode\n{\n    public next: this;\n    public previous: this;\n\n    public anEdge: HalfEdge<V, E, F>;\n\n    public data: V;\n\n    constructor(data?: V)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n}\n"],"names":[],"mappings":"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"}