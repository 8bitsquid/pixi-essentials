{"version":3,"file":"data-half-edge.mesh.js","sources":["../src/Face.ts","../src/HalfEdge.ts","../src/Vertex.ts"],"sourcesContent":["import { HalfEdge } from './HalfEdge';\n\nimport type { IDoublyLinkedListNode } from '@pixi-essentials/types';\n\n/**\n * Iterator for traversing over the edges forming a loop around a face. It loops in the counterclockwise\n * direction.\n *\n * In order to guarantee that each edge is encountered only once, the face's edge list not be modified.\n *\n * You can get the shared iterator of a {@code Face}: `face[Symbol.iterator]`\n */\nexport class EdgeLoopIterator<V, E, F> implements Iterator<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n{\n    protected current: HalfEdge;\n    protected face: Face;\n    protected done: boolean;\n\n    /**\n     * @param face - the face around which to iterate\n     */\n    constructor(face: Face<V, E, F>)\n    {\n        /**\n         * The last half-edge returned by {@code this.next}.\n         */\n        this.current = null;\n\n        /**\n         * The face this iterator will iterate over.\n         */\n        this.face = face;\n\n        /**\n         * Whether this iterator has looped over all the edges of {@code this.face}.\n         */\n        this.done = false;\n    }\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators\n     */\n    next(): IteratorResult<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n    {\n        if (!this.current)\n        {\n            this.current = this.face.anEdge;\n        }\n        else if (this.current.next !== this.face.anEdge)\n        {\n            this.current = this.current.next;\n        }\n        else\n        {\n            this.current = null;\n            this.done = true;\n        }\n\n        return {\n            value: this.current,\n            done: this.done,\n        };\n    }\n\n    /**\n     * Reset this iterator so it can be used from start.\n     */\n    reset(): this\n    {\n        this.current = null;\n        this.done = false;\n\n        return this;\n    }\n}\n\n/**\n * A face is bounded by a loop of edges.\n *\n * You can use a for..of loop to iterate over the edges looping around this face:\n * ```js\n * // Loops in counterclockwise direction\n * for (const edge of face)\n * {\n *     assert(edge.leftFace === face);\n * }\n * ```\n */\nexport class Face<V = any, E = any, F = any> implements IDoublyLinkedListNode, Iterable<HalfEdge<V, E, F>>\n{\n    public next: this;\n    public previous: this;\n\n    anEdge: HalfEdge<V, E, F>;\n\n    data: F;\n\n    private _edgeLoopIterator: EdgeLoopIterator<V, E, F>;\n\n    constructor(data?: F)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n\n    [Symbol.iterator](): Iterator<HalfEdge<V, E, F>, any, undefined>\n    {\n        if (!this._edgeLoopIterator)\n        {\n            this._edgeLoopIterator = new EdgeLoopIterator(this);\n        }\n\n        return this._edgeLoopIterator;\n    }\n}\n","import type { ILinkedListNode } from '@pixi-essentials/types';\nimport type { Vertex } from './Vertex';\nimport type { Face } from './Face';\n\n/**\n * A directed edge from its origin to destination.\n *\n * {@code HalfEdge} is a node of the following circular linked-lists:\n *  + the list of edges in the whole mesh: {@link HalfEdge#next}\n *  + the list of edges around its left face: {@link HalfEdge#lnext}\n *  + the list of edges directed from its origin vertex: {@link HalfEdge#onext}\n *  + the list of edges directed to its destination vertex: {@link HalfEdge#dnext}\n *  + the list of edges around its right face: {@link HalfEdge#rnext}\n */\nexport class HalfEdge<V = any, E = any, F = any> implements ILinkedListNode\n{\n    next: this;\n\n    _lnext: this;\n    _onext: this;\n\n    _origin: Vertex<V, E, F>;\n    _twin: HalfEdge<V, E, F>;\n    _leftFace: Face<V, E, F>;\n\n    data: E;\n\n    constructor(data?: E)\n    {\n        this.data = data;\n\n        this._onext = this;\n    }\n\n    connect(origin: Vertex<V, E, F>, twin: HalfEdge, leftFace?: Face): this\n    {\n        this._origin = origin;\n        this._twin = twin;\n        this._leftFace = leftFace;\n\n        return this;\n    }\n\n    get previous(): HalfEdge<V, E, F>\n    {\n        return this._twin.next;\n    }\n\n    /**\n     * The origin vertex\n     */\n    get org(): Vertex<V, E, F>\n    {\n        return this._origin;\n    }\n\n    /**\n     * The destination vertex\n     */\n    get dst(): Vertex<V, E, F>\n    {\n        return this._twin._origin;\n    }\n\n    /**\n     * The next edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dnext(): HalfEdge<V, E, F>\n    {\n        return this.rnext.twin;\n    }\n\n    /**\n     * The last edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dlast(): HalfEdge<V, E, F>\n    {\n        return this.lnext.twin;\n    }\n\n    /**\n     * The next edge sharing {@code this.org} in the counterclockwise direction.\n     */\n    get onext(): HalfEdge<V, E, F>\n    {\n        return this._onext;\n    }\n\n    /**\n     * The previous edge sharing {@code this.org} in the counterclockwise direction. It is also\n     * the next edge in the clockwise direction.\n     */\n    get oprev(): HalfEdge<V, E, F>\n    {\n        return this.twin.lnext;\n    }\n\n    /**\n     * The next edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lnext}'s origin vertex is this edge's destination vertex.\n     */\n    get lnext(): HalfEdge<V, E, F>\n    {\n        return this._lnext;\n    }\n\n    /**\n     * The previous edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lprev}'s destination vertex is this edge's origin vertex.\n     */\n    get lprev(): HalfEdge<V, E, F>\n    {\n        return this._onext.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rnext}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rnext}'s destination vertex is this edge's origin vertex.\n     */\n    get rnext(): HalfEdge<V, E, F>\n    {\n        return this.oprev.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rlast}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rlast}'s origin vertex is this edge's destination vertex.\n     */\n    get rlast(): HalfEdge<V, E, F>\n    {\n        return this.twin.onext;\n    }\n\n    /**\n     * The half-edge directed from {@code this.dst}.\n     */\n    get twin(): HalfEdge<V, E, F>\n    {\n        return this._twin;\n    }\n\n    /**\n     * The face on the left side of this edge. This edge is oriented counterclockwise to its left face.\n     */\n    get leftFace(): Face<V, E, F>\n    {\n        return this._leftFace;\n    }\n\n    /**\n     * The face on the right side of this edge. This edge is oriented clockwise to its right face.\n     */\n    get rightFace(): Face<V, E, F>\n    {\n        return this._twin.leftFace;\n    }\n}\n","import type { IDoublyLinkedListNode } from '@pixi-essentials/types';\nimport type { HalfEdge } from './HalfEdge';\n\n/**\n *\n */\nexport class Vertex<V = any, E = any, F = any> implements IDoublyLinkedListNode\n{\n    public next: this;\n    public previous: this;\n\n    public anEdge: HalfEdge<V, E, F>;\n\n    public data: V;\n\n    constructor(data?: V)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;IAIA;;;;;;;;UAQa,gBAAgB;;;;QASzB,YAAY,IAAmB;;;;YAK3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;;;;YAKpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;;;;YAKjB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;SACrB;;;;QAKD,IAAI;YAEA,IAAI,CAAC,IAAI,CAAC,OAAO,EACjB;gBACI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;aACnC;iBACI,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,EAC/C;gBACI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;aACpC;iBAED;gBACI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;gBACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;aACpB;YAED,OAAO;gBACH,KAAK,EAAE,IAAI,CAAC,OAAO;gBACnB,IAAI,EAAE,IAAI,CAAC,IAAI;aAClB,CAAC;SACL;;;;QAKD,KAAK;YAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;YAElB,OAAO,IAAI,CAAC;SACf;KACJ;IAED;;;;;;;;;;;;UAYa,IAAI;QAWb,YAAY,IAAQ;YAEhB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACpB;QAED,OAAO,CAAC,IAAuB;YAE3B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YAEnB,OAAO,IAAI,CAAC;SACf;QAED,CAAC,MAAM,CAAC,QAAQ,CAAC;YAEb,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAC3B;gBACI,IAAI,CAAC,iBAAiB,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;aACvD;YAED,OAAO,IAAI,CAAC,iBAAiB,CAAC;SACjC;;;ICnHL;;;;;;;;;;UAUa,QAAQ;QAajB,YAAY,IAAQ;YAEhB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YAEjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACtB;QAED,OAAO,CAAC,MAAuB,EAAE,IAAc,EAAE,QAAe;YAE5D,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YACtB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;YAClB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;YAE1B,OAAO,IAAI,CAAC;SACf;QAED,IAAI,QAAQ;YAER,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;SAC1B;;;;QAKD,IAAI,GAAG;YAEH,OAAO,IAAI,CAAC,OAAO,CAAC;SACvB;;;;QAKD,IAAI,GAAG;YAEH,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;SAC7B;;;;QAKD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;SAC1B;;;;QAKD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;SAC1B;;;;QAKD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,MAAM,CAAC;SACtB;;;;;QAMD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;SAC1B;;;;;;QAOD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,MAAM,CAAC;SACtB;;;;;;QAOD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;SAC3B;;;;;;;QAQD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;SAC1B;;;;;;;QAQD,IAAI,KAAK;YAEL,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;SAC1B;;;;QAKD,IAAI,IAAI;YAEJ,OAAO,IAAI,CAAC,KAAK,CAAC;SACrB;;;;QAKD,IAAI,QAAQ;YAER,OAAO,IAAI,CAAC,SAAS,CAAC;SACzB;;;;QAKD,IAAI,SAAS;YAET,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;SAC9B;;;IC9JL;;;UAGa,MAAM;QASf,YAAY,IAAQ;YAEhB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACpB;QAED,OAAO,CAAC,IAAuB;YAE3B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YAEnB,OAAO,IAAI,CAAC;SACf;;;;;;;;;;;;;;;;;;;"}