{"version":3,"file":"data-half-edge.mesh.js","sources":["../src/Face.ts","../src/HalfEdge.ts","../src/Vertex.ts"],"sourcesContent":["import { HalfEdge } from './HalfEdge';\n\nimport type { IDoublyLinkedListNode } from '@pixi-essentials/types';\n\n/**\n * Iterator for traversing over the edges forming a loop around a face. It loops in the counterclockwise\n * direction.\n *\n * In order to guarantee that each edge is encountered only once, the face's edge list not be modified.\n *\n * You can get the shared iterator of a {@code Face}: `face[Symbol.iterator]`\n */\nexport class EdgeLoopIterator<V, E, F> implements Iterator<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n{\n    protected current: HalfEdge;\n    protected face: Face;\n    protected done: boolean;\n\n    /**\n     * @param face - the face around which to iterate\n     */\n    constructor(face: Face<V, E, F>)\n    {\n        /**\n         * The last half-edge returned by {@code this.next}.\n         */\n        this.current = null;\n\n        /**\n         * The face this iterator will iterate over.\n         */\n        this.face = face;\n\n        /**\n         * Whether this iterator has looped over all the edges of {@code this.face}.\n         */\n        this.done = false;\n    }\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators\n     */\n    next(): IteratorResult<HalfEdge<V, E, F>, HalfEdge<V, E, F>>\n    {\n        if (!this.current)\n        {\n            this.current = this.face.anEdge;\n        }\n        else if (this.current.next !== this.face.anEdge)\n        {\n            this.current = this.current.next;\n        }\n        else\n        {\n            this.current = null;\n            this.done = true;\n        }\n\n        return {\n            value: this.current,\n            done: this.done,\n        };\n    }\n\n    /**\n     * Reset this iterator so it can be used from start.\n     */\n    reset(): this\n    {\n        this.current = null;\n        this.done = false;\n\n        return this;\n    }\n}\n\n/**\n * A face is bounded by a loop of edges.\n *\n * You can use a for..of loop to iterate over the edges looping around this face:\n * ```js\n * // Loops in counterclockwise direction\n * for (const edge of face)\n * {\n *     assert(edge.leftFace === face);\n * }\n * ```\n */\nexport class Face<V = any, E = any, F = any> implements IDoublyLinkedListNode, Iterable<HalfEdge<V, E, F>>\n{\n    public next: this;\n    public previous: this;\n\n    anEdge: HalfEdge<V, E, F>;\n\n    data: F;\n\n    private _edgeLoopIterator: EdgeLoopIterator<V, E, F>;\n\n    constructor(data?: F)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n\n    [Symbol.iterator](): Iterator<HalfEdge<V, E, F>, any, undefined>\n    {\n        if (!this._edgeLoopIterator)\n        {\n            this._edgeLoopIterator = new EdgeLoopIterator(this);\n        }\n\n        return this._edgeLoopIterator;\n    }\n}\n","import type { ILinkedListNode } from '@pixi-essentials/types';\nimport type { Vertex } from './Vertex';\nimport type { Face } from './Face';\n\n/**\n * A directed edge from its origin to destination.\n *\n * {@code HalfEdge} is a node of the following circular linked-lists:\n *  + the list of edges in the whole mesh: {@link HalfEdge#next}\n *  + the list of edges around its left face: {@link HalfEdge#lnext}\n *  + the list of edges directed from its origin vertex: {@link HalfEdge#onext}\n *  + the list of edges directed to its destination vertex: {@link HalfEdge#dnext}\n *  + the list of edges around its right face: {@link HalfEdge#rnext}\n */\nexport class HalfEdge<V = any, E = any, F = any> implements ILinkedListNode\n{\n    next: this;\n\n    _lnext: this;\n    _onext: this;\n\n    _origin: Vertex<V, E, F>;\n    _twin: HalfEdge<V, E, F>;\n    _leftFace: Face<V, E, F>;\n\n    data: E;\n\n    constructor(data?: E)\n    {\n        this.data = data;\n\n        this._onext = this;\n    }\n\n    connect(origin: Vertex<V, E, F>, twin: HalfEdge, leftFace?: Face): this\n    {\n        this._origin = origin;\n        this._twin = twin;\n        this._leftFace = leftFace;\n\n        return this;\n    }\n\n    get previous(): HalfEdge<V, E, F>\n    {\n        return this._twin.next;\n    }\n\n    /**\n     * The origin vertex\n     */\n    get org(): Vertex<V, E, F>\n    {\n        return this._origin;\n    }\n\n    /**\n     * The destination vertex\n     */\n    get dst(): Vertex<V, E, F>\n    {\n        return this._twin._origin;\n    }\n\n    /**\n     * The next edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dnext(): HalfEdge<V, E, F>\n    {\n        return this.rnext.twin;\n    }\n\n    /**\n     * The last edge sharing {@code this.dst} in the counterclockwise direction.\n     */\n    get dlast(): HalfEdge<V, E, F>\n    {\n        return this.lnext.twin;\n    }\n\n    /**\n     * The next edge sharing {@code this.org} in the counterclockwise direction.\n     */\n    get onext(): HalfEdge<V, E, F>\n    {\n        return this._onext;\n    }\n\n    /**\n     * The previous edge sharing {@code this.org} in the counterclockwise direction. It is also\n     * the next edge in the clockwise direction.\n     */\n    get oprev(): HalfEdge<V, E, F>\n    {\n        return this.twin.lnext;\n    }\n\n    /**\n     * The next edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lnext}'s origin vertex is this edge's destination vertex.\n     */\n    get lnext(): HalfEdge<V, E, F>\n    {\n        return this._lnext;\n    }\n\n    /**\n     * The previous edge on the left face (pointing counterclockwise direction).\n     *\n     * {@code this.lprev}'s destination vertex is this edge's origin vertex.\n     */\n    get lprev(): HalfEdge<V, E, F>\n    {\n        return this._onext.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rnext}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rnext}'s destination vertex is this edge's origin vertex.\n     */\n    get rnext(): HalfEdge<V, E, F>\n    {\n        return this.oprev.twin;\n    }\n\n    /**\n     * The next edge on the right face in counterclockwise direction; however, this and {@code this.rlast}\n     * are directed in the clockwise direction of the right face.\n     *\n     * {@code this.rlast}'s origin vertex is this edge's destination vertex.\n     */\n    get rlast(): HalfEdge<V, E, F>\n    {\n        return this.twin.onext;\n    }\n\n    /**\n     * The half-edge directed from {@code this.dst}.\n     */\n    get twin(): HalfEdge<V, E, F>\n    {\n        return this._twin;\n    }\n\n    /**\n     * The face on the left side of this edge. This edge is oriented counterclockwise to its left face.\n     */\n    get leftFace(): Face<V, E, F>\n    {\n        return this._leftFace;\n    }\n\n    /**\n     * The face on the right side of this edge. This edge is oriented clockwise to its right face.\n     */\n    get rightFace(): Face<V, E, F>\n    {\n        return this._twin.leftFace;\n    }\n}\n","import type { IDoublyLinkedListNode } from '@pixi-essentials/types';\nimport type { HalfEdge } from './HalfEdge';\n\n/**\n *\n */\nexport class Vertex<V = any, E = any, F = any> implements IDoublyLinkedListNode\n{\n    public next: this;\n    public previous: this;\n\n    public anEdge: HalfEdge<V, E, F>;\n\n    public data: V;\n\n    constructor(data?: V)\n    {\n        this.data = data;\n    }\n\n    connect(edge: HalfEdge<V, E, F>): this\n    {\n        this.anEdge = edge;\n\n        return this;\n    }\n}\n"],"names":["EdgeLoopIterator","[object Object]","face","this","current","done","next","anEdge","value","Face","data","edge","Symbol","iterator","_edgeLoopIterator","_onext","origin","twin","leftFace","_origin","_twin","_leftFace","previous","org","dst","dnext","rnext","dlast","lnext","onext","oprev","_lnext","lprev","rlast","rightFace"],"mappings":";;;;;;;;;gGAYaA,EASTC,YAAYC,GAKRC,KAAKC,QAAU,KAKfD,KAAKD,KAAOA,EAKZC,KAAKE,MAAO,EAMhBJ,OAgBI,OAdKE,KAAKC,QAIDD,KAAKC,QAAQE,OAASH,KAAKD,KAAKK,OAErCJ,KAAKC,QAAUD,KAAKC,QAAQE,MAI5BH,KAAKC,QAAU,KACfD,KAAKE,MAAO,GATZF,KAAKC,QAAUD,KAAKD,KAAKK,OAYtB,CACHC,MAAOL,KAAKC,QACZC,KAAMF,KAAKE,MAOnBJ,QAKI,OAHAE,KAAKC,QAAU,KACfD,KAAKE,MAAO,EAELF,YAgBFM,EAWTR,YAAYS,GAERP,KAAKO,KAAOA,EAGhBT,QAAQU,GAIJ,OAFAR,KAAKI,OAASI,EAEPR,KAGXF,CAACW,OAAOC,YAOJ,OALKV,KAAKW,oBAENX,KAAKW,kBAAoB,IAAId,EAAiBG,OAG3CA,KAAKW,yEC3FhBb,YAAYS,GAERP,KAAKO,KAAOA,EAEZP,KAAKY,OAASZ,KAGlBF,QAAQe,EAAyBC,EAAgBC,GAM7C,OAJAf,KAAKgB,QAAUH,EACfb,KAAKiB,MAAQH,EACbd,KAAKkB,UAAYH,EAEVf,KAGXmB,eAEI,OAAOnB,KAAKiB,MAAMd,KAMtBiB,UAEI,OAAOpB,KAAKgB,QAMhBK,UAEI,OAAOrB,KAAKiB,MAAMD,QAMtBM,YAEI,OAAOtB,KAAKuB,MAAMT,KAMtBU,YAEI,OAAOxB,KAAKyB,MAAMX,KAMtBY,YAEI,OAAO1B,KAAKY,OAOhBe,YAEI,OAAO3B,KAAKc,KAAKW,MAQrBA,YAEI,OAAOzB,KAAK4B,OAQhBC,YAEI,OAAO7B,KAAKY,OAAOE,KASvBS,YAEI,OAAOvB,KAAK2B,MAAMb,KAStBgB,YAEI,OAAO9B,KAAKc,KAAKY,MAMrBZ,WAEI,OAAOd,KAAKiB,MAMhBF,eAEI,OAAOf,KAAKkB,UAMhBa,gBAEI,OAAO/B,KAAKiB,MAAMF,0BCjJtBjB,YAAYS,GAERP,KAAKO,KAAOA,EAGhBT,QAAQU,GAIJ,OAFAR,KAAKI,OAASI,EAEPR"}