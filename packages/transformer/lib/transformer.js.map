{"version":3,"file":"transformer.js","sources":["../src/TransformerHandle.ts","../src/utils/skewTransform.ts","../src/utils/decomposeTransform.ts","../src/utils/multiplyTransform.ts","../src/Transformer.ts"],"sourcesContent":["/// <reference path=\"./types.d.ts\" />\n\nimport { Graphics } from '@pixi/graphics';\nimport { Point } from '@pixi/math';\n\nimport { InteractionEvent } from '@pixi/interaction';\n\n/**\n * @ignore\n */\nexport interface ITransformerHandleStyle\n{\n    color: number;\n    outlineColor: number;\n    outlineThickness: number;\n    radius: number;\n    shape: string;\n}\n\n/**\n * The default transformer handle style.\n *\n * @ignore\n */\nconst DEFAULT_HANDLE_STYLE = {\n    color: 0xffffff,\n    outlineColor: 0x000000,\n    outlineThickness: 1,\n    radius: 8,\n    shape: 'square',\n};\n\nconst tempPoint = new Point();\nconst tempDelta = new Point();\n\n/**\n * The transfomer handle base implementation.\n */\nexport class TransformerHandle extends Graphics\n{\n    onHandleDelta: (origin: Point, delta: Point) => void;\n    onHandleCommit: () => void;\n\n    protected _style: ITransformerHandleStyle;\n\n    private _pointerDown: boolean;\n    private _pointerDragging: boolean;\n    private _pointerPosition: Point;\n\n    constructor(styleOpts: Partial<ITransformerHandleStyle> = {},\n        handler?: (origin: Point, delta: Point) => void,\n        commit?: () => void,\n        cursor?: string)\n    {\n        super();\n\n        const style: ITransformerHandleStyle = Object.assign({}, DEFAULT_HANDLE_STYLE, styleOpts);\n\n        this._style = style;\n        this.cursor = cursor || 'move';\n        this.onHandleDelta = handler;\n        this.onHandleCommit = commit;\n\n        this.lineStyle(style.outlineThickness, style.outlineColor)\n            .beginFill(style.color);\n\n        if (style.shape === 'square')\n        {\n            this.drawRect(-style.radius / 2, -style.radius / 2, style.radius, style.radius);\n        }\n        else\n        {\n            this.drawCircle(0, 0, style.radius);\n        }\n\n        this.endFill();\n\n        this._pointerDown = false;\n        this._pointerDragging = false;\n        this._pointerPosition = new Point();\n\n        this.interactive = true;\n\n        this.on('mousedown', this.onPointerDown, this);\n        this.on('mousemove', this.onPointerMove, this);\n        this.on('mouseup', this.onPointerUp, this);\n        this.on('mouseupoutside', this.onPointerUp, this);\n    }\n\n    get style(): Partial<ITransformerHandleStyle>\n    {\n        return this._style;\n    }\n    set style(value: Partial<ITransformerHandleStyle>)\n    {\n        this._style = Object.assign({}, DEFAULT_HANDLE_STYLE, value);\n    }\n\n    protected onPointerDown(e: InteractionEvent): void\n    {\n        this._pointerDown = true;\n        this._pointerDragging = false;\n\n        e.stopPropagation();\n    }\n\n    protected onPointerMove(e: InteractionEvent): void\n    {\n        if (!this._pointerDown)\n        {\n            return;\n        }\n\n        if (this._pointerDragging)\n        {\n            this.onDrag(e);\n        }\n        else\n        {\n            this.onDragStart(e);\n        }\n\n        e.stopPropagation();\n    }\n\n    protected onPointerUp(e: InteractionEvent): void\n    {\n        if (this._pointerDragging)\n        {\n            this.onDragEnd(e);\n        }\n\n        this._pointerDown = false;\n    }\n\n    protected onDragStart(e: InteractionEvent): void\n    {\n        e.data.getLocalPosition(this.parent, this._pointerPosition);\n\n        this._pointerDragging = true;\n    }\n\n    protected onDrag(e: InteractionEvent): void\n    {\n        const lastPosition = this._pointerPosition;\n        const currentPosition = e.data.getLocalPosition(this.parent, tempPoint);\n\n        // Callback handles the rest!\n        if (this.onHandleDelta)\n        {\n            tempDelta.x = currentPosition.x - lastPosition.x;\n            tempDelta.y = currentPosition.y - lastPosition.y;\n\n            this.onHandleDelta(lastPosition, tempDelta);\n        }\n\n        this._pointerPosition.copyFrom(tempPoint);\n    }\n\n    protected onDragEnd(_: InteractionEvent): void\n    {\n        this._pointerDragging = false;\n\n        if (this.onHandleCommit)\n        {\n            this.onHandleCommit();\n        }\n    }\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\n\nconst tempMatrix = new Matrix();\n\n/**\n * @param angle\n * @returns a horizontal skew matrix\n */\nexport function createHorizontalSkew(angle: number): Matrix\n{\n    const matrix = tempMatrix.identity();\n\n    matrix.c = Math.tan(angle);\n\n    return matrix;\n}\n\n/**\n * @param angle\n * @returns a vertical skew matrix\n */\nexport function createVerticalSkew(angle: number): Matrix\n{\n    const matrix = tempMatrix.identity();\n\n    matrix.b = Math.tan(angle);\n\n    return matrix;\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport type { Transform, Matrix } from '@pixi/math';\n\n/**\n * Decomposes the matrix into transform, while preserving rotation & the pivot.\n *\n * @ignore\n * @param transform\n * @param matrix\n * @param rotation\n * @param pivot\n */\nexport function decomposeTransform(\n    transform: Transform,\n    matrix: Matrix,\n    rotation?: number,\n    pivot = transform.pivot,\n): Transform\n{\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n\n    rotation = rotation !== undefined && rotation !== null ? rotation : skewY;\n\n    // set pivot\n    transform.pivot.set(pivot.x, pivot.y);\n\n    // next set rotation, skew angles\n    transform.rotation = rotation;\n    transform.skew.x = rotation + skewX;\n    transform.skew.y = -rotation + skewY;\n\n    // next set scale\n    transform.scale.x = Math.sqrt((a * a) + (b * b));\n    transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n    // next set position\n    transform.position.x = matrix.tx + ((pivot.x * matrix.a) + (pivot.y * matrix.c));\n    transform.position.y = matrix.ty + ((pivot.x * matrix.b) + (pivot.y * matrix.d));\n\n    return transform;\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\nimport { decomposeTransform } from './decomposeTransform';\n\nimport type { DisplayObject } from '@pixi/display';\n\nconst tempMatrix = new Matrix();\nconst tempParentMatrix = new Matrix();\n\n/**\n * Multiplies the transformation matrix {@code transform} to the display-object's transform.\n *\n * @param displayObject\n * @param transform\n * @param skipUpdate\n */\nexport function multiplyTransform(displayObject: DisplayObject, transform: Matrix, skipUpdate?: boolean): void\n{\n    if (!skipUpdate)\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n    }\n\n    const worldTransform = displayObject.worldTransform;\n    const parentTransform = displayObject.parent\n        ? tempParentMatrix.copyFrom(displayObject.parent.worldTransform)\n        : Matrix.IDENTITY;\n\n    tempMatrix.copyFrom(worldTransform);\n    tempMatrix.prepend(transform);\n    tempMatrix.prepend(parentTransform.invert());// gets new \"local\" transform\n\n    decomposeTransform(displayObject.transform, tempMatrix);\n}\n","/// <reference path=\"./types.d.ts\" />\n\nimport { Renderer } from '@pixi/core';\nimport { DisplayObject, Container } from '@pixi/display';\nimport { Point, Matrix, Transform, Rectangle } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\nimport { AxisAlignedBounds, OrientedBounds } from '@pixi-essentials/bounds';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\nimport { TransformerHandle } from './TransformerHandle';\nimport { createHorizontalSkew, createVerticalSkew } from './utils/skewTransform';\nimport { decomposeTransform } from './utils/decomposeTransform';\nimport { multiplyTransform } from './utils/multiplyTransform';\n\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { ITransformerHandleStyle } from './TransformerHandle';\n\n// Preallocated objects\nconst tempTransform = new Transform();\nconst tempCorners: [Point, Point, Point, Point] = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempBounds = new OrientedBounds();\nconst tempRect = new Rectangle();\n\n// Pool for allocating an arbitrary number of points\nconst pointPool = ObjectPoolFactory.build(Point as any);\n\n/**\n * The handles used for rotation.\n *\n * @internal\n * @ignore\n */\ntype RotatorHandle = 'rotator';\n\n/**\n * The handles used for scaling.\n *\n * @internal\n * @ignore\n */\ntype ScaleHandle = 'topLeft' |\n    'topCenter' |\n    'topRight' |\n    'middleLeft' |\n    'middleCenter' |\n    'middleRight' |\n    'bottomLeft' |\n    'bottomCenter' |\n    'bottomRight';\n/**\n * The handles used for skewing\n *\n * @internal\n * @ignore\n */\ntype SkewHandle = 'skewHorizontal' | 'skewVertical';\n\n/**\n * All the handles provided by {@link Transformer}.\n *\n * @internal\n * @ignore\n */\ntype Handle = RotatorHandle | ScaleHandle | SkewHandle;\n\n/**\n * Specific cursors for each handle\n *\n * @internal\n * @ignore\n */\nconst HANDLE_TO_CURSOR: { [H in Handle]?: string } = {\n    topLeft: 'nw-resize',\n    topCenter: 'n-resize',\n    topRight: 'ne-resize',\n    middleLeft: 'w-resize',\n    middleRight: 'e-resize',\n    bottomLeft: 'sw-resize',\n    bottomCenter: 's-resize',\n    bottomRight: 'se-resize',\n};\n\n/**\n * An array of all {@link ScaleHandle} values.\n *\n * @internal\n * @ignore\n */\nconst SCALE_HANDLES = [\n    'topLeft',\n    'topCenter',\n    'topRight',\n    'middleLeft',\n    'middleCenter',\n    'middleRight',\n    'bottomLeft',\n    'bottomCenter',\n    'bottomRight',\n];\n\n/**\n * This maps each scaling handle to the directions in which the x, y components are outward. A value of\n * zero means that no scaling occurs along that component's axis.\n *\n * @internal\n * @ignore\n */\nconst SCALE_COMPONENTS: {\n    [H in ScaleHandle]: { x: (-1 | 0 | 1); y: (-1 | 0 | 1) };\n } = {\n     topLeft: { x: -1, y: -1 },\n     topCenter: { x: 0, y: -1 },\n     topRight: { x: 1, y: -1 },\n     middleLeft: { x: -1, y: 0 },\n     middleCenter: { x: 0, y: 0 },\n     middleRight: { x: 1, y: 0 },\n     bottomLeft: { x: -1, y: 1 },\n     bottomCenter: { x: 0, y: 1 },\n     bottomRight: { x: 1, y: 1 },\n };\n\n/**\n * @ignore\n */\nexport interface ITransformerStyle\n{\n    color: number;\n    thickness: number;\n}\n\n/**\n * The default wireframe style for {@link Transformer}.\n *\n * @ignore\n */\nconst DEFAULT_WIREFRAME_STYLE: ITransformerStyle = {\n    color: 0x000000,\n    thickness: 2,\n};\n\n/**\n * @ignore\n */\nexport interface ITransformerOptions\n{\n    group: DisplayObject[];\n    handleConstructor: typeof DisplayObject;\n    handleStyle: Partial<ITransformerHandleStyle>;\n    skewRadius: number;\n    skewTransform: boolean;\n    transientGroupTilt: boolean;\n    wireframeStyle: Partial<ITransformerStyle>;\n}\n\n/**\n * {@code Transformer} provides an interactive interface for editing the transforms in a group. It supports translating,\n * scaling, rotating, and skewing display-objects both through interaction and code.\n *\n * NOTE: The transformer needs to capture all interaction events that would otherwise go to the display-objects in the\n * group. Hence, it must be placed after them in the scene graph.\n */\nexport class Transformer extends Container\n{\n    public group: DisplayObject[];\n    public skewRadius: number;\n    public transientGroupTilt: boolean;\n\n    protected groupBounds: OrientedBounds;\n    protected handles: { [H in Handle]: TransformerHandle };\n    protected wireframe: Graphics;\n    protected _skewTransform: boolean;\n    protected _skewX: number;\n    protected _skewY: number;\n    protected _handleStyle: Partial<ITransformerHandleStyle>;\n    protected _wireframeStyle: Partial<ITransformerStyle>;\n\n    private _pointerDown: boolean;\n    private _pointerDragging: boolean;\n    private _pointerPosition: Point;\n\n    /**\n     * @param {object}[options]\n     * @param {DisplayObject[]}[options.group] - the group of display-objects being transformed\n     * @param {typeof TransformerHandle}[options.handleConstructor] - a custom transformer-handle class\n     * @param {object}[options.handleStyle] - styling options for the handle. These cannot be modified afterwards!\n     * @param {number}[options.handleStyle.color] - handle color\n     * @param {string}[options.handleStyle.outlineColor] - color of the handle outline (stroke)\n     * @param {string}[options.handleStyle.outlineThickness] - thickness of the handle outline (stroke)\n     * @param {number}[options.handleStyle.radius] - dimensions of the handle\n     * @param {string}[options.handleStyle.shape] - 'circle' or 'square'\n     * @param {number}[options.skewRadius] - distance of skew handles from center of transformer box\n     *  (`skewTransform` should be enabled)\n     * @param {number}[options.skewTransform] - whether to enable skewing\n     * @param {boolean}[options.transientGroupTilt=true] - whether the transformer should reset the wireframe's rotation\n     *      after a rotator handle is \"defocused\".\n     * @param {object}[options.wireframeStyle] - styling options for the wireframe.\n     * @param {number}[options.wireframeStyle.color] - color of the lines\n     * @param {number}[options.wireframeStyle.thickness] - thickness of the lines\n     */\n    constructor(options: Partial<ITransformerOptions> = {})\n    {\n        super();\n\n        this.interactive = true;\n        this.cursor = 'move';\n\n        this.group = options.group || [];\n        this.skewRadius = options.skewRadius || 64;\n        this._skewTransform = options.skewTransform !== undefined ? options.skewTransform : false;\n        this.transientGroupTilt = options.transientGroupTilt !== undefined ? options.transientGroupTilt : true;\n\n        /**\n         * Draws the bounding boxes\n         */\n        this.wireframe = this.addChild(new Graphics());\n\n        /**\n         * The horizontal skew value. Rotating the group by 𝜽 will also change this value by 𝜽.\n         */\n        this._skewX = 0;\n\n        /**\n         * The vertical skew value. Rotating the group by 𝜽 will also change this value by 𝜽.\n         */\n        this._skewY = 0;\n\n        /**\n         * The wireframe style applied on the transformer\n         */\n        this._wireframeStyle = Object.assign({}, DEFAULT_WIREFRAME_STYLE, options.wireframeStyle || {});\n\n        const HandleConstructor = options.handleConstructor || TransformerHandle;\n        const handleStyle = options.handleStyle || {};\n\n        this._handleStyle = handleStyle;\n\n        // Initialize transformer handles\n        const rotatorHandles = {\n            rotator: this.addChild(\n                new HandleConstructor(\n                    handleStyle,\n                    (origin: Point, delta: Point) => { this.rotateGroup('rotator', origin, delta); },\n                    this.commitGroup,\n                )),\n        };\n        const scaleHandles = SCALE_HANDLES.reduce((scaleHandles, handleKey) =>\n        {\n            const handleDelta = (_: Point, delta: Point): void =>\n            {\n                this.scaleGroup(handleKey as ScaleHandle, delta);\n            };\n\n            scaleHandles[handleKey] = new HandleConstructor(\n                handleStyle,\n                handleDelta,\n                this.commitGroup,\n                HANDLE_TO_CURSOR[handleKey]);\n            this.addChild(scaleHandles[handleKey]);\n\n            return scaleHandles;\n        }, {});\n        const skewHandles = {\n            skewHorizontal: this.addChild(\n                new HandleConstructor(\n                    handleStyle,\n                    (origin: Point, delta: Point) => { this.skewGroup('skewHorizontal', origin, delta); },\n                    this.commitGroup,\n                    'pointer',\n                )),\n            skewVertical: this.addChild(\n                new HandleConstructor(\n                    handleStyle,\n                    (origin: Point, delta: Point) => { this.skewGroup('skewVertical', origin, delta); },\n                    this.commitGroup,\n                    'pointer',\n                )),\n        };\n\n        this.handles = Object.assign({}, rotatorHandles, scaleHandles, skewHandles) as { [H in Handle]: TransformerHandle };\n        this.handles.middleCenter.visible = false;\n        this.handles.skewHorizontal.visible = this._skewTransform;\n        this.handles.skewVertical.visible = this._skewTransform;\n\n        // Update groupBounds immediately. This is because mouse events can propagate before the next animation frame.\n        this.groupBounds = new OrientedBounds();\n        this.updateGroupBounds();\n\n        // Pointer events\n        this._pointerDown = false;\n        this._pointerDragging = false;\n        this._pointerPosition = new Point();\n        this.on('pointerdown', this.onPointerDown, this);\n        this.on('pointermove', this.onPointerMove, this);\n        this.on('pointerup', this.onPointerUp, this);\n        this.on('pointerupoutside', this.onPointerUp, this);\n    }\n\n    /**\n     * The currently applied handle style. If you have edited the transformer handles directly, this may be inaccurate.\n     */\n    get handleStyle(): Partial<ITransformerHandleStyle>\n    {\n        return this._handleStyle;\n    }\n    set handleStyle(value: Partial<ITransformerHandleStyle>)\n    {\n        const handles = this.handles;\n\n        for (const handleKey in handles)\n        {\n            (handles[handleKey] as TransformerHandle).style = value;\n        }\n\n        this._handleStyle = value;\n    }\n\n    /**\n     * This will enable the skewing handles.\n     */\n    get skewTransform(): boolean\n    {\n        return this._skewTransform;\n    }\n    set skewTransform(value: boolean)\n    {\n        if (this._skewTransform !== value)\n        {\n            this._skewTransform = value;\n\n            this.handles.skewHorizontal.visible = value;\n            this.handles.skewVertical.visible = value;\n        }\n    }\n\n    /**\n     * The currently applied wireframe style.\n     */\n    get wireframeStyle(): Partial<ITransformerStyle>\n    {\n        return this._wireframeStyle;\n    }\n    set wireframeStyle(value: Partial<ITransformerStyle>)\n    {\n        this._wireframeStyle = Object.assign({}, DEFAULT_WIREFRAME_STYLE, value);\n    }\n\n    /**\n     * This will translate the group by {@code delta}.\n     *\n     * NOTE: There is no handle that provides translation. The user drags the transformer directly.\n     *\n     * @param delta\n     */\n    translateGroup = (delta: Point): void =>\n    {\n        // Translation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(delta.x, delta.y);\n\n        this.prependTransform(matrix);\n    };\n\n    /**\n     * This will rotate the group such that the {@code origin} point will move by {@code delta}.\n     *\n     * @param handle - the rotator handle was dragged\n     * @param origin - the original pointer position (before dragging)\n     * @param delta - the difference in pointer position (after dragging)\n     */\n    rotateGroup = (_: RotatorHandle, origin: Point, delta: Point): void =>\n    {\n        const bounds = this.groupBounds;\n        const destination = tempPoint.set(origin.x + delta.x, origin.y + delta.y);\n\n        // Center of rotation - does not change in transformation\n        const rOrigin = bounds.center;\n\n        // Original angle subtended by pointer\n        const orgAngle = Math.atan2(origin.y - rOrigin.y, origin.x - rOrigin.x);\n\n        // Final angle subtended by pointer\n        const dstAngle = Math.atan2(destination.y - rOrigin.y, destination.x - rOrigin.x);\n\n        // The angle by which bounds should be rotated\n        const deltaAngle = dstAngle - orgAngle;\n\n        // Rotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-rOrigin.x, -rOrigin.y)\n            .rotate(deltaAngle)\n            .translate(rOrigin.x, rOrigin.y);\n\n        this.prependTransform(matrix, true);\n        this.updateGroupBounds(bounds.rotation + deltaAngle);\n\n        // Rotation moves both skew.x & skew.y\n        this._skewX += deltaAngle;\n        this._skewY += deltaAngle;\n    };\n\n    /**\n     * This will scale the group such that the handle will move by {@code delta}.\n     *\n     * @param handle - the scaling handle that was dragged\n     * @param delta - the change in pointer position since the last event\n     */\n    scaleGroup = (handle: ScaleHandle, delta: Point): void =>\n    {\n        // Directions along x,y axes that will produce positive scaling\n        const xDir = SCALE_COMPONENTS[handle].x;\n        const yDir = SCALE_COMPONENTS[handle].y;\n\n        const bounds = this.groupBounds;\n        const angle = bounds.rotation;\n        const innerBounds = bounds.innerBounds;\n\n        // Delta vector in world frame\n        const dx = delta.x;\n        const dy = delta.y;\n\n        // Unit vector along u-axis (horizontal axis after rotation) of bounds\n        const uxvec = (bounds.topRight.x - bounds.topLeft.x) / innerBounds.width;\n        const uyvec = (bounds.topRight.y - bounds.topLeft.y) / innerBounds.width;\n\n        // Unit vector along v-axis (vertical axis after rotation) of bounds\n        const vxvec = (bounds.bottomLeft.x - bounds.topLeft.x) / innerBounds.height;\n        const vyvec = (bounds.bottomLeft.y - bounds.topLeft.y) / innerBounds.height;\n\n        // Delta vector in rotated frame of bounds\n        const du = (dx * uxvec) + (dy * uyvec);\n        const dv = (dx * vxvec) + (dy * vyvec);\n\n        // Scaling factors along x,y axes\n        const sx = 1 + (du * xDir / innerBounds.width);\n        const sy = 1 + (dv * yDir / innerBounds.height);\n\n        const matrix = tempMatrix.identity();\n\n        if (xDir !== 0)\n        {\n            // Origin of horizontal scaling - a point which does not move after applying the transform\n            const hsOrigin = xDir === 1 ? bounds.topLeft : bounds.topRight;\n\n            matrix.translate(-hsOrigin.x, -hsOrigin.y)\n                .rotate(-angle)\n                .scale(sx, 1)\n                .rotate(angle)\n                .translate(hsOrigin.x, hsOrigin.y);\n        }\n\n        if (yDir !== 0)\n        {\n            // Origin of vertical scaling - a point which does not move after applying the transform\n            const vsOrigin = yDir === 1 ? bounds.topLeft : bounds.bottomLeft;\n\n            matrix.translate(-vsOrigin.x, -vsOrigin.y)\n                .rotate(-angle)\n                .scale(1, sy)\n                .rotate(angle)\n                .translate(vsOrigin.x, vsOrigin.y);\n        }\n\n        this.prependTransform(matrix);\n    };\n\n    /**\n     * This will skew the group such that the skew handle would move to the destination {@code origin + delta}.\n     *\n     * @param handle\n     * @param delta\n     */\n    skewGroup = (handle: SkewHandle, origin: Point, delta: Point): void =>\n    {\n        const bounds = this.groupBounds;\n\n        // Destination point\n        const dst = tempPoint.set(origin.x + delta.x, origin.y + delta.y);\n\n        // Center of skew (same as center of rotation!)\n        const sOrigin = bounds.center;\n\n        // Skew matrix\n        const matrix = tempMatrix.identity()\n            .translate(-sOrigin.x, -sOrigin.y);\n        let rotation = this.groupBounds.rotation;\n\n        if (handle === 'skewHorizontal')\n        {\n            const oldSkew = this._skewX;\n\n            // Calculate new skew\n            this._skewX = Math.atan2(dst.y - sOrigin.y, dst.x - sOrigin.x);\n\n            // Skew by new skew.x\n            matrix.prepend(createVerticalSkew(-oldSkew));\n            matrix.prepend(createVerticalSkew(this._skewX));\n        }\n        else // skewVertical\n        {\n            const oldSkew = this._skewY;\n\n            // Calculate new skew\n            const newSkew = Math.atan2(dst.y - sOrigin.y, dst.x - sOrigin.x) - (Math.PI / 2);\n\n            this._skewY = newSkew;\n\n            // HINT: skewY is applied negatively b/c y-axis is flipped\n            matrix.prepend(createHorizontalSkew(oldSkew));\n            matrix.prepend(createHorizontalSkew(-this._skewY));\n\n            rotation -= newSkew - oldSkew;\n        }\n\n        matrix.translate(sOrigin.x, sOrigin.y);\n\n        this.prependTransform(matrix, true);\n        this.updateGroupBounds(rotation);\n    };\n\n    /**\n     * This is called after the user finishes dragging a handle. If {@link this.transientGroupTilt} is enabled, it will\n     * reset the rotation of this group (if more than one display-object is grouped).\n     */\n    commitGroup = (): void =>\n    {\n        if (this.transientGroupTilt !== false && this.group.length > 1)\n        {\n            this.updateGroupBounds(0);\n        }\n    };\n\n    /**\n     * This will update the transformer's geometry and render it to the canvas.\n     *\n     * @override\n     * @param renderer\n     */\n    render(renderer: Renderer): void\n    {\n        this.draw();\n\n        super.render(renderer);\n    }\n\n    /**\n     * Recalculates the transformer's geometry. This is called on each render.\n     */\n    protected draw(): void\n    {\n        const targets = this.group;\n        const { color, thickness } = this._wireframeStyle;\n\n        // Updates occur right here!\n        this.wireframe.clear()\n            .lineStyle(thickness, color);\n\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this.drawBounds(Transformer.calculateOrientedBounds(targets[i], tempBounds));\n        }\n\n        // groupBounds may change on each render-loop b/c of any ongoing animation\n        const groupBounds = targets.length !== 1\n            ? Transformer.calculateGroupOrientedBounds(targets, this.groupBounds.rotation, tempBounds, true)\n            : Transformer.calculateOrientedBounds(targets[0], tempBounds);// Auto-detect rotation\n\n        // Redraw skeleton and position handles\n        this.drawBounds(groupBounds);\n        this.drawHandles(groupBounds);\n\n        // Update cached groupBounds\n        this.groupBounds.copyFrom(groupBounds);\n    }\n\n    /**\n     * Draws the bounding box into {@code this.skeleton}.\n     *\n     * @param bounds\n     */\n    protected drawBounds(bounds: OrientedBounds | AxisAlignedBounds): void\n    {\n        // Fill polygon with ultra-low alpha to capture pointer events.\n        this.wireframe\n            .beginFill(0xffffff, 1e-4)\n            .drawPolygon(bounds.hull)\n            .endFill();\n    }\n\n    /**\n     * Draw the handles and any remaining parts of the skeleton\n     *\n     * @param groupBounds\n     */\n    protected drawHandles(groupBounds: OrientedBounds): void\n    {\n        const handles = this.handles;\n\n        const { topLeft, topRight, bottomLeft, bottomRight, center } = groupBounds;\n\n        // Scale handles\n        handles.topLeft.position.copyFrom(topLeft);\n        handles.topCenter.position.set((topLeft.x + topRight.x) / 2, (topLeft.y + topRight.y) / 2);\n        handles.topRight.position.copyFrom(topRight);\n        handles.middleLeft.position.set((topLeft.x + bottomLeft.x) / 2, (topLeft.y + bottomLeft.y) / 2);\n        handles.middleCenter.position.set((topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);\n        handles.middleRight.position.set((topRight.x + bottomRight.x) / 2, (topRight.y + bottomRight.y) / 2);\n        handles.bottomLeft.position.copyFrom(bottomLeft);\n        handles.bottomCenter.position.set((bottomLeft.x + bottomRight.x) / 2, (bottomLeft.y + bottomRight.y) / 2);\n        handles.bottomRight.position.copyFrom(bottomRight);\n\n        // Skew handles\n        handles.skewHorizontal.position.set(\n            center.x + (Math.cos(this._skewX) * this.skewRadius),\n            center.y + (Math.sin(this._skewX) * this.skewRadius));\n        // HINT: Slope = skew.y + Math.PI / 2\n        handles.skewVertical.position.set(\n            center.x + (-Math.sin(this._skewY) * this.skewRadius),\n            center.y + (Math.cos(this._skewY) * this.skewRadius));\n\n        groupBounds.innerBounds.pad(32);\n\n        handles.rotator.position.x = (groupBounds.topLeft.x + groupBounds.topRight.x) / 2;\n        handles.rotator.position.y = (groupBounds.topLeft.y + groupBounds.topRight.y) / 2;\n\n        groupBounds.innerBounds.pad(-32);\n\n        const bx = (groupBounds.topLeft.x + groupBounds.topRight.x) / 2;\n        const by = (groupBounds.topLeft.y + groupBounds.topRight.y) / 2;\n\n        this.wireframe.moveTo(bx, by)\n            .lineTo(handles.rotator.position.x, handles.rotator.position.y);\n\n        if (this._skewTransform)\n        {\n            this.wireframe\n                .beginFill(this.wireframeStyle.color)\n                .drawCircle(center.x, center.y, this.wireframeStyle.thickness * 2)\n                .endFill();\n            this.wireframe\n                .moveTo(center.x, center.y)\n                .lineTo(handles.skewHorizontal.x, handles.skewHorizontal.y)\n                .moveTo(center.x, center.y)\n                .lineTo(handles.skewVertical.x, handles.skewVertical.y);\n        }\n\n        // Update transforms\n        for (const handleName in handles)\n        {\n            let rotation = this.groupBounds.rotation;\n\n            if (handleName === 'skewHorizontal')\n            {\n                rotation = this._skewX;\n            }\n            else if (handleName === 'skewVertical')\n            {\n                rotation = this._skewY;\n            }\n\n            const handle: TransformerHandle = handles[handleName];\n\n            handle.rotation = rotation;\n            handle.getBounds(false, tempRect);\n        }\n    }\n\n    /**\n     * Called on the `pointerdown` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerDown(e: InteractionEvent): void\n    {\n        this._pointerDown = true;\n        this._pointerDragging = false;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Called on the `pointermove` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerMove(e: InteractionEvent): void\n    {\n        if (!this._pointerDown)\n        {\n            return;\n        }\n\n        const lastPointerPosition = this._pointerPosition;\n        const currentPointerPosition = e.data.getLocalPosition(this, tempPoint);\n\n        const cx = currentPointerPosition.x;\n        const cy = currentPointerPosition.y;\n\n        // Translate group by difference\n        if (this._pointerDragging)\n        {\n            const delta = currentPointerPosition;\n\n            delta.x -= lastPointerPosition.x;\n            delta.y -= lastPointerPosition.y;\n\n            this.translateGroup(delta);\n        }\n\n        this._pointerPosition.x = cx;\n        this._pointerPosition.y = cy;\n        this._pointerDragging = true;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Called on the `pointerup` and `pointerupoutside` events. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerUp(e: InteractionEvent): void\n    {\n        this._pointerDragging = false;\n        this._pointerDown = false;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Applies the given transformation matrix {@code delta} to all the display-objects in the group.\n     *\n     * @param delta - transformation matrix\n     * @param skipUpdate - whether to skip updating the group-bounds after applying the transform\n     */\n    private prependTransform(delta: Matrix, skipUpdate = false): void\n    {\n        const group = this.group;\n\n        for (let i = 0, j = group.length; i < j; i++)\n        {\n            multiplyTransform(group[i], delta, false);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateGroupBounds();\n        }\n    }\n\n    /**\n     * Recalculates {@code this.groupBounds} at the same angle.\n     *\n     * @param rotation - override the group's rotation\n     */\n    private updateGroupBounds(rotation: number = this.groupBounds.rotation): void\n    {\n        Transformer.calculateGroupOrientedBounds(this.group, rotation, this.groupBounds);\n    }\n\n    /**\n     * Calculates the positions of the four corners of the display-object. The quadrilateral formed by\n     * these points will be the tightest fit around it.\n     *\n     * @param displayObject - The display object whose corners are to be calculated\n     * @param transform - The transform applied on the display-object. By default, this is its world-transform\n     * @param corners - Optional array of four points to put the result into\n     * @param index - Optional index into \"corners\"\n     */\n    static calculateTransformedCorners(\n        displayObject: DisplayObject,\n        transform: Matrix = displayObject.worldTransform,\n        corners?: Point[],\n        index = 0,\n    ): Point[]\n    {\n        const localBounds = displayObject.getLocalBounds();\n\n        // Don't modify transforms\n        displayObject.getBounds();\n\n        corners = corners || [new Point(), new Point(), new Point(), new Point()];\n        corners[index].set(localBounds.x, localBounds.y);\n        corners[index + 1].set(localBounds.x + localBounds.width, localBounds.y);\n        corners[index + 2].set(localBounds.x + localBounds.width, localBounds.y + localBounds.height);\n        corners[index + 3].set(localBounds.x, localBounds.y + localBounds.height);\n\n        transform.apply(corners[index], corners[index]);\n        transform.apply(corners[index + 1], corners[index + 1]);\n        transform.apply(corners[index + 2], corners[index + 2]);\n        transform.apply(corners[index + 3], corners[index + 3]);\n\n        return corners;\n    }\n\n    /**\n     * Calculates the oriented bounding box of the display-object. This would not bending with any skew\n     * applied on the display-object, i.e. it is guaranteed to be rectangular.\n     *\n     * @param displayObject\n     * @param bounds - the bounds instance to set\n     */\n    static calculateOrientedBounds(displayObject: DisplayObject, bounds?: OrientedBounds): OrientedBounds\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n\n        // Decompose displayObject.worldTransform to get its (world) rotation\n        decomposeTransform(tempTransform, displayObject.worldTransform);\n\n        tempTransform.updateLocalTransform();\n\n        const angle = tempTransform.rotation;\n        const corners = Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, tempCorners);\n\n        // Calculate centroid, which is our center of rotatation\n        const cx = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;\n        const cy = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-cx, -cy)\n            .rotate(-tempTransform.rotation)\n            .translate(cx, cy);\n\n        // Calculate unrotated corners\n        matrix.apply(corners[0], corners[0]);\n        matrix.apply(corners[1], corners[1]);\n        matrix.apply(corners[2], corners[2]);\n        matrix.apply(corners[3], corners[3]);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.rotation = angle;\n        bounds.innerBounds.x = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        bounds.innerBounds.y = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        bounds.innerBounds.width = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x) - bounds.innerBounds.x;\n        bounds.innerBounds.height = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y) - bounds.innerBounds.y;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the oriented bounding box of a group of display-objects at a specific angle.\n     *\n     * @param group\n     * @param rotation\n     * @param bounds\n     * @param skipUpdate\n     */\n    static calculateGroupOrientedBounds(\n        group: DisplayObject[],\n        rotation: number,\n        bounds?: OrientedBounds,\n        skipUpdate = false,\n    ): OrientedBounds\n    {\n        const groupLength = group.length;\n        const frames = pointPool.allocateArray(groupLength * 4);// Zero allocations!\n\n        // Calculate display-object frame vertices\n        for (let i = 0; i < groupLength; i++)\n        {\n            const displayObject = group[i];\n\n            // Update worldTransform\n            if (!skipUpdate)\n            {\n                const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n                displayObject.updateTransform();\n                displayObject.disableTempParent(parent);\n            }\n\n            Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, frames, i * 4);\n        }\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .rotate(-rotation);\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = -Number.MAX_VALUE;\n        let maxY = -Number.MAX_VALUE;\n\n        // Unrotate all frame vertices, calculate minX, minY, maxX, maxY for innerBounds\n        for (let i = 0, j = frames.length; i < j; i++)\n        {\n            const point = frames[i];\n\n            matrix.apply(point, point);\n\n            const x = point.x;\n            const y = point.y;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        pointPool.releaseArray(frames);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.innerBounds.x = minX;\n        bounds.innerBounds.y = minY;\n        bounds.innerBounds.width = maxX - minX;\n        bounds.innerBounds.height = maxY - minY;\n        bounds.rotation = rotation;\n\n        matrix.applyInverse(bounds.center, tempPoint);\n        bounds.center.copyFrom(tempPoint);\n\n        return bounds;\n    }\n}\n"],"names":["Point","Graphics","Matrix","tempMatrix","Transform","tempPoint","OrientedBounds","Rectangle","ObjectPoolFactory","Container","bounds"],"mappings":"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"}