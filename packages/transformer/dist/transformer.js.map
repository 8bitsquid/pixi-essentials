{"version":3,"file":"transformer.js","sources":["../src/TransformerHandle.ts","../src/utils/skewTransform.ts","../src/utils/decomposeTransform.ts","../src/utils/multiplyTransform.ts","../src/Transformer.ts"],"sourcesContent":["/// <reference path=\"./types.d.ts\" />\n\nimport { Graphics } from '@pixi/graphics';\nimport { Point } from '@pixi/math';\nimport { Renderer } from '@pixi/core';\n\nimport { InteractionEvent } from '@pixi/interaction';\nimport type { Handle } from './Transformer';\n\n/**\n * @see TransformerHandle#style\n */\nexport interface ITransformerHandleStyle\n{\n    /**\n     * Fill color of the handle\n     */\n    color: number;\n\n    /**\n     * Outline color of the handle\n     */\n    outlineColor: number;\n\n    /**\n     * Outline thickness around the handle\n     */\n    outlineThickness: number;\n\n    /**\n     * Radius (or size for non-circular handles) of the handle\n     */\n    radius: number;\n\n    /**\n     * {@link TransformerHandle} provides three types of handle shapes - 'circle', 'square', 'tooth'.\n     */\n    shape: string;\n}\n\n/**\n * The default transformer handle style.\n *\n * @ignore\n */\nconst DEFAULT_HANDLE_STYLE: ITransformerHandleStyle = {\n    color: 0xffffff,\n    outlineColor: 0x000000,\n    outlineThickness: 1,\n    radius: 8,\n    shape: 'tooth',\n};\n\n/**\n * The transfomer handle base implementation.\n */\nexport class TransformerHandle extends Graphics\n{\n    onHandleDelta: (pointerPosition: Point) => void;\n    onHandleCommit: () => void;\n\n    protected _handle: Handle;\n    protected _style: ITransformerHandleStyle;\n    protected _dirty: boolean;\n\n    private _pointerDown: boolean;\n    private _pointerDragging: boolean;\n    private _pointerPosition: Point;\n\n    /**\n     * @param {string} handle - the type of handle being drawn\n     * @param {object} styleOpts - styling options passed by the user\n     * @param {function} handler - handler for drag events, it receives the pointer position; used by {@code onDrag}.\n     * @param {function} commit - handler for drag-end events.\n     * @param {string}[cursor='move'] - a custom cursor to be applied on this handle\n     */\n    constructor(\n        handle: Handle,\n        styleOpts: Partial<ITransformerHandleStyle> = {},\n        handler: (pointerPosition: Point) => void,\n        commit: () => void,\n        cursor?: string)\n    {\n        super();\n\n        const style: ITransformerHandleStyle = Object.assign({}, DEFAULT_HANDLE_STYLE, styleOpts);\n\n        this._handle = handle;\n        this._style = style;\n        this.onHandleDelta = handler;\n        this.onHandleCommit = commit;\n\n        /**\n         * This flags whether this handle should be redrawn in the next frame due to style changes.\n         */\n        this._dirty = true;\n\n        // Pointer events\n        this.interactive = true;\n        this.cursor = cursor || 'move';\n        this._pointerDown = false;\n        this._pointerDragging = false;\n        this._pointerPosition = new Point();\n        this.on('mousedown', this.onPointerDown, this);\n        this.on('mousemove', this.onPointerMove, this);\n        this.on('mouseup', this.onPointerUp, this);\n        this.on('mouseupoutside', this.onPointerUp, this);\n    }\n\n    /**\n     * The currently applied handle style.\n     */\n    get style(): Partial<ITransformerHandleStyle>\n    {\n        return this._style;\n    }\n    set style(value: Partial<ITransformerHandleStyle>)\n    {\n        this._style = Object.assign({}, DEFAULT_HANDLE_STYLE, value);\n        this._dirty = true;\n    }\n\n    render(renderer: Renderer): void\n    {\n        if (this._dirty)\n        {\n            this.draw();\n\n            this._dirty = false;\n        }\n\n        super.render(renderer);\n    }\n\n    /**\n     * Redraws the handle's geometry. This is called on a `render` if {@code this._dirty} is true.\n     */\n    protected draw(): void\n    {\n        const handle = this._handle;\n        const style = this._style;\n\n        const radius = style.radius;\n\n        this.lineStyle(style.outlineThickness, style.outlineColor)\n            .beginFill(style.color);\n\n        if (style.shape === 'square')\n        {\n            this.drawRect(-radius / 2, -radius / 2, radius, radius);\n        }\n        else if (style.shape === 'tooth')\n        {\n            switch (handle)\n            {\n                case 'middleLeft':\n                    this.drawPolygon([\n                        -radius / 2, -radius / 2,\n                        -radius / 2, radius / 2,\n                        radius / 2, radius / 2,\n                        radius * 1.1, 0,\n                        radius / 2, -radius / 2,\n                    ]);\n                    break;\n                case 'topCenter':\n                    this.drawPolygon([\n                        -radius / 2, -radius / 2,\n                        radius / 2, -radius / 2,\n                        radius / 2, radius / 2,\n                        0, radius * 1.1,\n                        -radius / 2, radius / 2,\n                    ]);\n                    break;\n                case 'middleRight':\n                    this.drawPolygon([\n                        -radius / 2, radius / 2,\n                        -radius * 1.1, 0,\n                        -radius / 2, -radius / 2,\n                        radius / 2, -radius / 2,\n                        radius / 2, radius / 2,\n                    ]);\n                    break;\n                case 'bottomCenter':\n                    this.drawPolygon([\n                        0, -radius * 1.1,\n                        radius / 2, -radius / 2,\n                        radius / 2, radius / 2,\n                        -radius / 2, radius / 2,\n                        -radius / 2, -radius / 2,\n                    ]);\n                    break;\n                case 'rotator':\n                    this.drawCircle(0, 0, radius / Math.sqrt(2));\n                    break;\n                default:\n                    this.drawRect(-radius / 2, -radius / 2, radius, radius);\n                    break;\n            }\n        }\n        else\n        {\n            this.drawCircle(0, 0, radius);\n        }\n\n        this.endFill();\n    }\n\n    /**\n     * Handles the `pointerdown` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerDown(e: InteractionEvent): void\n    {\n        this._pointerDown = true;\n        this._pointerDragging = false;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Handles the `pointermove` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerMove(e: InteractionEvent): void\n    {\n        if (!this._pointerDown)\n        {\n            return;\n        }\n\n        if (this._pointerDragging)\n        {\n            this.onDrag(e);\n        }\n        else\n        {\n            this.onDragStart(e);\n        }\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Handles the `pointerup` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerUp(e: InteractionEvent): void\n    {\n        if (this._pointerDragging)\n        {\n            this.onDragEnd(e);\n        }\n\n        this._pointerDown = false;\n    }\n\n    /**\n     * Called on the first `pointermove` when {@code this._pointerDown} is true. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onDragStart(e: InteractionEvent): void\n    {\n        this._pointerPosition.copyFrom(e.data.global);\n\n        this._pointerDragging = true;\n    }\n\n    /**\n     * Called on a `pointermove` when {@code this._pointerDown} & {@code this._pointerDragging}.\n     *\n     * @param e\n     */\n    protected onDrag(e: InteractionEvent): void\n    {\n        const currentPosition = e.data.global;\n\n        // Callback handles the rest!\n        if (this.onHandleDelta)\n        {\n            this.onHandleDelta(currentPosition);\n        }\n\n        this._pointerPosition.copyFrom(currentPosition);\n    }\n\n    /**\n     * Called on a `pointerup` or `pointerupoutside` & {@code this._pointerDragging} was true.\n     *\n     * @param _\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected onDragEnd(_: InteractionEvent): void\n    {\n        this._pointerDragging = false;\n\n        if (this.onHandleCommit)\n        {\n            this.onHandleCommit();\n        }\n    }\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\n\nconst tempMatrix = new Matrix();\n\n/**\n * @param angle\n * @returns a horizontal skew matrix\n */\nexport function createHorizontalSkew(angle: number): Matrix\n{\n    const matrix = tempMatrix.identity();\n\n    matrix.c = Math.tan(angle);\n\n    return matrix;\n}\n\n/**\n * @param angle\n * @returns a vertical skew matrix\n */\nexport function createVerticalSkew(angle: number): Matrix\n{\n    const matrix = tempMatrix.identity();\n\n    matrix.b = Math.tan(angle);\n\n    return matrix;\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport type { Transform, Matrix } from '@pixi/math';\n\n/**\n * Decomposes the matrix into transform, while preserving rotation & the pivot.\n *\n * @ignore\n * @param transform\n * @param matrix\n * @param rotation\n * @param pivot\n */\nexport function decomposeTransform(\n    transform: Transform,\n    matrix: Matrix,\n    rotation?: number,\n    pivot = transform.pivot,\n): Transform\n{\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n\n    rotation = rotation !== undefined && rotation !== null ? rotation : skewY;\n\n    // set pivot\n    transform.pivot.set(pivot.x, pivot.y);\n\n    // next set rotation, skew angles\n    transform.rotation = rotation;\n    transform.skew.x = rotation + skewX;\n    transform.skew.y = -rotation + skewY;\n\n    // next set scale\n    transform.scale.x = Math.sqrt((a * a) + (b * b));\n    transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n    // next set position\n    transform.position.x = matrix.tx + ((pivot.x * matrix.a) + (pivot.y * matrix.c));\n    transform.position.y = matrix.ty + ((pivot.x * matrix.b) + (pivot.y * matrix.d));\n\n    return transform;\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\nimport { decomposeTransform } from './decomposeTransform';\n\nimport type { DisplayObject } from '@pixi/display';\n\nconst tempMatrix = new Matrix();\nconst tempParentMatrix = new Matrix();\n\n/**\n * Multiplies the transformation matrix {@code transform} to the display-object's transform.\n *\n * @param displayObject\n * @param transform\n * @param skipUpdate\n */\nexport function multiplyTransform(displayObject: DisplayObject, transform: Matrix, skipUpdate?: boolean): void\n{\n    if (!skipUpdate)\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n    }\n\n    const worldTransform = displayObject.worldTransform;\n    const parentTransform = displayObject.parent\n        ? tempParentMatrix.copyFrom(displayObject.parent.worldTransform)\n        : Matrix.IDENTITY;\n\n    tempMatrix.copyFrom(worldTransform);\n    tempMatrix.prepend(transform);\n    tempMatrix.prepend(parentTransform.invert());// gets new \"local\" transform\n\n    decomposeTransform(displayObject.transform, tempMatrix);\n}\n","/// <reference path=\"./types.d.ts\" />\n\nimport { Renderer } from '@pixi/core';\nimport { DisplayObject, Container } from '@pixi/display';\nimport { Point, Matrix, Transform, Rectangle } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\nimport { AxisAlignedBounds, OrientedBounds } from '@pixi-essentials/bounds';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\nimport { TransformerHandle } from './TransformerHandle';\nimport { createHorizontalSkew, createVerticalSkew } from './utils/skewTransform';\nimport { decomposeTransform } from './utils/decomposeTransform';\nimport { multiplyTransform } from './utils/multiplyTransform';\n\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { ITransformerHandleStyle } from './TransformerHandle';\n\n// Preallocated objects\nconst tempTransform = new Transform();\nconst tempCorners: [Point, Point, Point, Point] = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempBounds = new OrientedBounds();\nconst tempRect = new Rectangle();\nconst tempHull = [new Point(), new Point(), new Point(), new Point()];\nconst tempPointer = new Point();\n\n// Pool for allocating an arbitrary number of points\nconst pointPool = ObjectPoolFactory.build(Point as any);\n\n/**\n * The handles used for rotation.\n *\n * @internal\n * @ignore\n */\ntype RotateHandle = 'rotator';\n\n/**\n * The handles used for scaling.\n *\n * @internal\n * @ignore\n */\ntype ScaleHandle = 'topLeft' |\n    'topCenter' |\n    'topRight' |\n    'middleLeft' |\n    'middleCenter' |\n    'middleRight' |\n    'bottomLeft' |\n    'bottomCenter' |\n    'bottomRight';\n\n/**\n * The handles used for skewing\n *\n * @internal\n * @ignore\n */\ntype SkewHandle = 'skewHorizontal' | 'skewVertical';\n\n/**\n * All the handles provided by {@link Transformer}.\n *\n * @internal\n * @ignore\n */\nexport type Handle = RotateHandle | ScaleHandle | SkewHandle;\n\n/**\n * Specific cursors for each handle\n *\n * @internal\n * @ignore\n */\nconst HANDLE_TO_CURSOR: { [H in Handle]?: string } = {\n    topLeft: 'nw-resize',\n    topCenter: 'n-resize',\n    topRight: 'ne-resize',\n    middleLeft: 'w-resize',\n    middleRight: 'e-resize',\n    bottomLeft: 'sw-resize',\n    bottomCenter: 's-resize',\n    bottomRight: 'se-resize',\n};\n\n/**\n * An array of all {@link ScaleHandle} values.\n *\n * @internal\n * @ignore\n */\nconst SCALE_HANDLES: ScaleHandle[] = [\n    'topLeft',\n    'topCenter',\n    'topRight',\n    'middleLeft',\n    'middleCenter',\n    'middleRight',\n    'bottomLeft',\n    'bottomCenter',\n    'bottomRight',\n];\n\n/**\n * This maps each scaling handle to the directions in which the x, y components are outward. A value of\n * zero means that no scaling occurs along that component's axis.\n *\n * @internal\n * @ignore\n */\nconst SCALE_COMPONENTS: {\n    [H in ScaleHandle]: { x: (-1 | 0 | 1); y: (-1 | 0 | 1) };\n } = {\n     topLeft: { x: -1, y: -1 },\n     topCenter: { x: 0, y: -1 },\n     topRight: { x: 1, y: -1 },\n     middleLeft: { x: -1, y: 0 },\n     middleCenter: { x: 0, y: 0 },\n     middleRight: { x: 1, y: 0 },\n     bottomLeft: { x: -1, y: 1 },\n     bottomCenter: { x: 0, y: 1 },\n     bottomRight: { x: 1, y: 1 },\n };\n\n/**\n * All possible values of {@link Handle}.\n *\n * @ignore\n */\nconst HANDLES = [\n    ...SCALE_HANDLES,\n    'rotator',\n    'skewHorizontal',\n    'skewVertical',\n];\n\n/**\n * The default snap angles for rotation, in radians.\n *\n * @ignore\n */\nconst DEFAULT_ROTATION_SNAPS = [\n    Math.PI / 4,\n    Math.PI / 2,\n    Math.PI * 3 / 4,\n    Math.PI,\n    -Math.PI / 4,\n    -Math.PI / 2,\n    -Math.PI * 3 / 4,\n    -Math.PI,\n];\n\n/**\n * The default snap tolerance, i.e. the maximum angle b/w the pointer & nearest snap ray for snapping.\n *\n * @ignore\n */\nconst DEFAULT_ROTATION_SNAP_TOLERANCE = Math.PI / 90;\n\n/**\n * The default snap angles for skewing, in radians.\n *\n * @ignore\n */\nconst DEFAULT_SKEW_SNAPS = [\n    Math.PI / 4,\n    -Math.PI / 4,\n];\n\n/**\n * The default snap tolerance for skewing.\n *\n * @ignore\n */\nconst DEFAULT_SKEW_SNAP_TOLERANCE = Math.PI / 90;\n\n/**\n * @ignore\n */\nexport interface ITransformerStyle\n{\n    color: number;\n    thickness: number;\n}\n\n/**\n * The default wireframe style for {@link Transformer}.\n *\n * @ignore\n */\nconst DEFAULT_WIREFRAME_STYLE: ITransformerStyle = {\n    color: 0x000000,\n    thickness: 2,\n};\n\n/**\n * @ignore\n */\nexport interface ITransformerOptions\n{\n    centeredScaling: boolean;\n    enabledHandles?: Array<Handle>;\n    group: DisplayObject[];\n    handleConstructor: typeof DisplayObject;\n    handleStyle: Partial<ITransformerHandleStyle>;\n    rotateEnabled?: boolean;\n    rotationSnaps?: number[];\n    rotationSnapTolerance?: number;\n    scaleEnabled?: boolean;\n    skewEnabled?: boolean;\n    skewRadius?: number;\n    skewSnaps?: number[];\n    skewSnapTolerance?: number;\n    translateEnabled?: boolean;\n    transientGroupTilt?: boolean;\n    wireframeStyle: Partial<ITransformerStyle>;\n}\n\n/**\n * {@code Transformer} provides an interactive interface for editing the transforms in a group. It supports translating,\n * scaling, rotating, and skewing display-objects both through interaction and code.\n *\n * A transformer operates in world-space, and it is best to not to position, scale, rotate, or skew one. If you do so, the\n * wireframe itself will not distort (i.e. will adapt _against_ your transforms). However, the wireframe may become\n * thinner/thicker and the handles will scale & rotate. For example, setting `transformer.scale.set(2)` will make the handles\n * twice as big, but will not scale the wireframe (assuming the display-object group itself has not been\n * scaled up).\n *\n * NOTE: The transformer needs to capture all interaction events that would otherwise go to the display-objects in the\n * group. Hence, it must be placed after them in the scene graph.\n */\nexport class Transformer extends Container\n{\n    public group: DisplayObject[];\n\n    public centeredScaling: boolean;\n    public projectionTransform: Matrix;\n    public rotationSnaps: number[];\n    public rotationSnapTolerance: number;\n    public skewRadius: number;\n    public skewSnaps: number[];\n    public skewSnapTolerance: number;\n    public translateEnabled: boolean;\n    public transientGroupTilt: boolean;\n\n    protected groupBounds: OrientedBounds;\n    protected handles: { [H in Handle]: TransformerHandle };\n    protected wireframe: Graphics;\n\n    protected _enabledHandles: Handle[];\n    protected _rotateEnabled: boolean;\n    protected _scaleEnabled: boolean;\n    protected _skewEnabled: boolean;\n    protected _skewX: number;\n    protected _skewY: number;\n    protected _transformType: 'translate' | 'scale' | 'rotate' | 'skew' | 'none';\n    protected _handleStyle: Partial<ITransformerHandleStyle>;\n    protected _wireframeStyle: Partial<ITransformerStyle>;\n\n    private _pointerDown: boolean;\n    private _pointerDragging: boolean;\n    private _pointerPosition: Point;\n\n    /* eslint-disable max-len */\n    /**\n     * | Handle                | Type                     | Notes |\n     * | --------------------- | ------------------------ | ----- |\n     * | rotator               | Rotate                   | |\n     * | topLeft               | Scale                    | |\n     * | topCenter             | Scale                    | |\n     * | topRight              | Scale                    | |\n     * | middleLeft            | Scale                    | |\n     * | middleCenter          | Scale                    | This cannot be enabled!                                             |\n     * | middleRight           | Scale                    | |\n     * | bottomLeft            | Scale                    | |\n     * | bottomCenter          | Scale                    | |\n     * | bottomRight           | Scale                    | |\n     * | skewHorizontal        | Skew                     | Applies vertical shear. Handle segment is horizontal at skew.y = 0! |\n     * | skewVertical          | Skew                     | Applied horizontal shear. Handle segment is vertical at skew.x = 0! |\n     *\n     * @param {object}[options]\n     * @param {DisplayObject[]}[options.group] - the group of display-objects being transformed\n     * @param {boolean}[options.enabledHandles] - specifically define which handles are to be enabled\n     * @param {typeof TransformerHandle}[options.handleConstructor] - a custom transformer-handle class\n     * @param {object}[options.handleStyle] - styling options for the handle. These cannot be modified afterwards!\n     * @param {number}[options.handleStyle.color=0xffffff] - handle color\n     * @param {string}[options.handleStyle.outlineColor=0x000000] - color of the handle outline (stroke)\n     * @param {string}[options.handleStyle.outlineThickness=1] - thickness of the handle outline (stroke)\n     * @param {number}[options.handleStyle.radius=8] - dimensions of the handle\n     * @param {string}[options.handleStyle.shape='tooth'] - 'circle', 'tooth', or 'square'\n     * @param {boolean}[options.handleStyle.scaleInvariant] - whether the handles should not become bigger when the whole scene\n     *  is scaled up.\n     * @param {boolean}[options.rotateEnabled=true] - whether rotate handles are enabled\n     * @param {number[]}[options.rotationSnaps] - the rotation snap angles, in radians. By default, transformer will\n     *      snap for each 1/8th of a revolution.\n     * @param {number}[options.rotationSnapTolerance] - the snap tolerance for rotation in radians\n     * @param {boolean}[options.scaleEnabled=true] - whether scale handles are enabled\n     * @param {boolean}[options.skewEnabled=true] - whether skew handles are enabled\n     * @param {number}[options.skewRadius] - distance of skew handles from center of transformer box\n     *      (`skewTransform` should be enabled)\n     * @param {number[]}[options.skewSnaps] - the skew snap angles, in radians.\n     * @param {number}[options.skewSnapTolerance] - the skew snap tolerance angle.\n     * @param {boolean}[options.translateEnabled=true] - whether dragging the transformer should move the group\n     * @param {boolean}[options.transientGroupTilt=true] - whether the transformer should reset the wireframe's rotation\n     *      after a rotator handle is \"defocused\".\n     * @param {object}[options.wireframeStyle] - styling options for the wireframe.\n     * @param {number}[options.wireframeStyle.color] - color of the lines\n     * @param {number}[options.wireframeStyle.thickness] - thickness of the lines\n     */\n    constructor(options: Partial<ITransformerOptions> = {})\n    {\n    /* eslint-enable max-len */\n        super();\n\n        this.interactive = true;\n        this.cursor = 'move';\n\n        /**\n         * The group of display-objects under transformation.\n         */\n        this.group = options.group || [];\n\n        /**\n         * This will prevent the wireframe's center from shifting on scaling.\n         */\n        this.centeredScaling = !!options.centeredScaling;\n\n        /**\n         * This is used when the display-object group are rendered through a projection transformation (i.e. are disconnected\n         * from the transformer in the scene graph). The transformer project itself into their frame-of-reference using this\n         * transform.\n         *\n         * Specifically, the projection-transform converts points from the group's world space to the transformer's world\n         * space. If you are not applying a projection on the transformer itself, this means it is the group's\n         * world-to-screen transformation.\n         */\n        this.projectionTransform = new Matrix();\n\n        /**\n         * The angles at which rotation should snap.\n         */\n        this.rotationSnaps = options.rotationSnaps || DEFAULT_ROTATION_SNAPS;\n\n        /**\n         * The maximum angular difference for snapping rotation.\n         */\n        this.rotationSnapTolerance = options.rotationSnapTolerance !== undefined\n            ? options.rotationSnapTolerance\n            : DEFAULT_ROTATION_SNAP_TOLERANCE;\n\n        /**\n         * The distance of skewing handles from the group's center.\n         */\n        this.skewRadius = options.skewRadius || 64;\n\n        /**\n         * The angles at which both the horizontal & vertical skew handles should snap.\n         */\n        this.skewSnaps = options.skewSnaps || DEFAULT_SKEW_SNAPS;\n\n        /**\n         * The maximum angular difference for snapping skew handles.\n         */\n        this.skewSnapTolerance = options.skewSnapTolerance !== undefined\n            ? options.skewSnapTolerance\n            : DEFAULT_SKEW_SNAP_TOLERANCE;\n\n        this._rotateEnabled = options.rotateEnabled !== false;\n        this._scaleEnabled = options.scaleEnabled !== false;\n        this._skewEnabled = options.skewEnabled === true;\n\n        /**\n         * This will enable translation on dragging the transformer. By default, it is turned on.\n         *\n         * @default true\n         */\n        this.translateEnabled = options.translateEnabled !== false;\n\n        /**\n         * This will reset the rotation angle after the user finishes rotating a group with more than one display-object.\n         *\n         * @default true\n         */\n        this.transientGroupTilt = options.transientGroupTilt !== undefined ? options.transientGroupTilt : true;\n\n        /**\n         * Draws the bounding boxes\n         */\n        this.wireframe = this.addChild(new Graphics());\n\n        /**\n         * The horizontal skew value. Rotating the group by 𝜽 will also change this value by 𝜽.\n         */\n        this._skewX = 0;\n\n        /**\n         * The vertical skew value. Rotating the group by 𝜽 will also change this value by 𝜽.\n         */\n        this._skewY = 0;\n\n        /**\n         * The current type of transform being applied by the user.\n         */\n        this._transformType = 'none';\n\n        /**\n         * The wireframe style applied on the transformer\n         */\n        this._wireframeStyle = Object.assign({}, DEFAULT_WIREFRAME_STYLE, options.wireframeStyle || {});\n\n        const HandleConstructor = options.handleConstructor || TransformerHandle;\n        const handleStyle = options.handleStyle || {};\n\n        this._handleStyle = handleStyle;\n\n        // Initialize transformer handles\n        const rotatorHandles = {\n            rotator: this.addChild(\n                new HandleConstructor(\n                    'rotator',\n                    handleStyle,\n                    (pointerPosition) =>\n                    {\n                        // The origin is the rotator handle's position, yes.\n                        this.rotateGroup('rotator', pointerPosition);\n                    },\n                    this.commitGroup,\n                )),\n        };\n        const scaleHandles = SCALE_HANDLES.reduce((scaleHandles, handleKey: ScaleHandle) =>\n        {\n            const handleDelta = (pointerPosition: Point): void =>\n            {\n                this.scaleGroup(handleKey as ScaleHandle, pointerPosition);\n            };\n\n            scaleHandles[handleKey] = new HandleConstructor(\n                handleKey,\n                handleStyle,\n                handleDelta,\n                this.commitGroup,\n                HANDLE_TO_CURSOR[handleKey]);\n            scaleHandles[handleKey].visible = this._scaleEnabled;\n            this.addChild(scaleHandles[handleKey]);\n\n            return scaleHandles;\n        }, {});\n        const skewHandles = {\n            skewHorizontal: this.addChild(\n                new HandleConstructor(\n                    'skewHorizontal',\n                    handleStyle,\n                    (pointerPosition: Point) => { this.skewGroup('skewHorizontal', pointerPosition); },\n                    this.commitGroup,\n                    'pointer',\n                )),\n            skewVertical: this.addChild(\n                new HandleConstructor(\n                    'skewVertical',\n                    handleStyle,\n                    (pointerPosition: Point) => { this.skewGroup('skewVertical', pointerPosition); },\n                    this.commitGroup,\n                    'pointer',\n                )),\n        };\n\n        /**\n         * Object mapping handle-names to the handle display-objects.\n         */\n        this.handles = Object.assign({}, rotatorHandles, scaleHandles, skewHandles) as { [H in Handle]: TransformerHandle };\n        this.handles.middleCenter.visible = false;\n        this.handles.skewHorizontal.visible = this._skewEnabled;\n        this.handles.skewVertical.visible = this._skewEnabled;\n\n        // Update groupBounds immediately. This is because mouse events can propagate before the next animation frame.\n        this.groupBounds = new OrientedBounds();\n        this.updateGroupBounds();\n\n        // Pointer events\n        this._pointerDown = false;\n        this._pointerDragging = false;\n        this._pointerPosition = new Point();\n        this.on('pointerdown', this.onPointerDown, this);\n        this.on('pointermove', this.onPointerMove, this);\n        this.on('pointerup', this.onPointerUp, this);\n        this.on('pointerupoutside', this.onPointerUp, this);\n    }\n\n    /**\n     * The list of enabled handles, if applied manually.\n     */\n    get enabledHandles(): Array<Handle>\n    {\n        return this._enabledHandles;\n    }\n    set enabledHandles(value: Array<Handle>)\n    {\n        if (!this._enabledHandles && !value)\n        {\n            return;\n        }\n\n        this._enabledHandles = value;\n\n        HANDLES.forEach((handleKey) => { this.handles[handleKey].visible = false; });\n\n        if (value)\n        {\n            value.forEach((handleKey) => { this.handles[handleKey].visible = true; });\n        }\n        else\n        {\n            this.handles.rotator.visible = this._rotateEnabled;\n            this.handles.skewHorizontal.visible = this._skewEnabled;\n            this.handles.skewVertical.visible = this._skewEnabled;\n\n            SCALE_HANDLES.forEach((handleKey) =>\n            {\n                if (handleKey === 'middleCenter') return;\n\n                this.handles[handleKey].visible = this._scaleEnabled;\n            });\n        }\n    }\n\n    /**\n     * The currently applied handle style. If you have edited the transformer handles directly, this may be inaccurate.\n     */\n    get handleStyle(): Partial<ITransformerHandleStyle>\n    {\n        return this._handleStyle;\n    }\n    set handleStyle(value: Partial<ITransformerHandleStyle>)\n    {\n        const handles = this.handles;\n\n        for (const handleKey in handles)\n        {\n            (handles[handleKey] as TransformerHandle).style = value;\n        }\n\n        this._handleStyle = value;\n    }\n\n    /**\n     * This will enable the rotate handles.\n     */\n    get rotateEnabled(): boolean\n    {\n        return this._rotateEnabled;\n    }\n    set rotateEnabled(value: boolean)\n    {\n        if (!this._rotateEnabled !== value)\n        {\n            this._rotateEnabled = value;\n\n            if (this._enabledHandles)\n            {\n                return;\n            }\n\n            this.handles.rotator.visible = value;\n        }\n    }\n\n    /**\n     * This will enable the scale handles.\n     */\n    get scaleEnabled(): boolean\n    {\n        return this._scaleEnabled;\n    }\n    set scaleEnabled(value: boolean)\n    {\n        if (!this._scaleEnabled !== value)\n        {\n            this._scaleEnabled = value;\n\n            if (this._enabledHandles)\n            {\n                return;\n            }\n\n            SCALE_HANDLES.forEach((handleKey) =>\n            {\n                if (handleKey === 'middleCenter')\n                {\n                    return;\n                }\n\n                this.handles[handleKey].visible = value;\n            });\n        }\n    }\n\n    /**\n     * This will enable the skew handles.\n     */\n    get skewEnabled(): boolean\n    {\n        return this._skewEnabled;\n    }\n    set skewEnabled(value: boolean)\n    {\n        if (this._skewEnabled !== value)\n        {\n            this._skewEnabled = value;\n\n            if (this._enabledHandles)\n            {\n                return;\n            }\n\n            this.handles.skewHorizontal.visible = value;\n            this.handles.skewVertical.visible = value;\n        }\n    }\n\n    /**\n     * This is the type of transformation being applied by the user on the group. It can be inaccurate if you call one of\n     * `translateGroup`, `scaleGroup`, `rotateGroup`, `skewGroup` without calling `commitGroup` afterwards.\n     *\n     * @readonly\n     */\n    get transformType(): 'translate' | 'scale' | 'rotate' | 'skew' | 'none'\n    {\n        return this._transformType;\n    }\n\n    /**\n     * The currently applied wireframe style.\n     */\n    get wireframeStyle(): Partial<ITransformerStyle>\n    {\n        return this._wireframeStyle;\n    }\n    set wireframeStyle(value: Partial<ITransformerStyle>)\n    {\n        this._wireframeStyle = Object.assign({}, DEFAULT_WIREFRAME_STYLE, value);\n    }\n\n    /**\n     * @param forceUpdate - forces a recalculation of the group bounds\n     * @returns the oriented bounding box of the wireframe\n     */\n    getGroupBounds(forceUpdate = false): OrientedBounds\n    {\n        if (forceUpdate)\n        {\n            this.updateGroupBounds();\n        }\n\n        return this.groupBounds;\n    }\n\n    /**\n     * This will translate the group by {@code delta} in their world-space.\n     *\n     * NOTE: There is no handle that provides translation. The user drags the transformer directly.\n     *\n     * @param delta\n     */\n    translateGroup = (delta: Point): void =>\n    {\n        this._transformType = 'translate';\n\n        // Translation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(delta.x, delta.y);\n\n        this.prependTransform(matrix);\n    };\n\n    /**\n     * This will rotate the group such that the handle will come to {@code pointerPosition}.\n     *\n     * @param handle - the rotator handle was dragged\n     * @param pointerPosition - the new pointer position, in screen space\n     */\n    rotateGroup = (handle: RotateHandle, pointerPosition: Point): void =>\n    {\n        this._transformType = 'rotate';\n\n        const bounds = this.groupBounds;\n        const handlePosition = this.worldTransform.apply(this.handles[handle].position, tempPoint);\n\n        this.projectionTransform.applyInverse(handlePosition, handlePosition);\n        pointerPosition = this.projectionTransform.applyInverse(pointerPosition, tempPointer);\n\n        // Center of rotation - does not change in transformation\n        const rOrigin = bounds.center;\n\n        // Original tilt\n        const orgAngle = Math.atan2(handlePosition.y - rOrigin.y, handlePosition.x - rOrigin.x);\n        // Final tilt\n        const dstAngle = Math.atan2(pointerPosition.y - rOrigin.y, pointerPosition.x - rOrigin.x);\n        // The angle by which bounds should be rotated\n        let deltaAngle = dstAngle - orgAngle;\n\n        // Snap\n        let newRotation = this.groupBounds.rotation + deltaAngle;\n\n        newRotation = this.snapAngle(newRotation, this.rotationSnapTolerance, this.rotationSnaps);\n        deltaAngle = newRotation - this.groupBounds.rotation;\n\n        // Rotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-rOrigin.x, -rOrigin.y)\n            .rotate(deltaAngle)\n            .translate(rOrigin.x, rOrigin.y);\n\n        this.prependTransform(matrix, true);\n        this.updateGroupBounds(newRotation);\n\n        // Rotation moves both skew.x & skew.y\n        this._skewX += deltaAngle;\n        this._skewY += deltaAngle;\n    };\n\n    /**\n     * This will scale the group such that the scale handle will come under {@code pointerPosition}.\n     *\n     * @param handle - the scaling handle that was dragged\n     * @param pointerPosition - the new pointer position, in screen space\n     */\n    scaleGroup = (handle: ScaleHandle, pointerPosition: Point): void =>\n    {\n        this._transformType = 'scale';\n\n        // Directions along x,y axes that will produce positive scaling\n        const xDir = SCALE_COMPONENTS[handle].x;\n        const yDir = SCALE_COMPONENTS[handle].y;\n\n        const bounds = this.groupBounds;\n        const angle = bounds.rotation;\n        const innerBounds = bounds.innerBounds;\n\n        // Position of handle in the group's world-space\n        const handlePosition = this.worldTransform.apply(this.handles[handle].position, tempPoint);\n\n        this.projectionTransform.applyInverse(handlePosition, handlePosition);\n        pointerPosition = this.projectionTransform.applyInverse(pointerPosition, tempPointer);\n\n        // Delta vector in world frame\n        const dx = pointerPosition.x - handlePosition.x;\n        const dy = pointerPosition.y - handlePosition.y;\n\n        // Unit vector along u-axis (horizontal axis after rotation) of bounds\n        const uxvec = (bounds.topRight.x - bounds.topLeft.x) / innerBounds.width;\n        const uyvec = (bounds.topRight.y - bounds.topLeft.y) / innerBounds.width;\n\n        // Unit vector along v-axis (vertical axis after rotation) of bounds\n        const vxvec = (bounds.bottomLeft.x - bounds.topLeft.x) / innerBounds.height;\n        const vyvec = (bounds.bottomLeft.y - bounds.topLeft.y) / innerBounds.height;\n\n        // Delta vector in rotated frame of bounds\n        const du = (dx * uxvec) + (dy * uyvec);\n        const dv = (dx * vxvec) + (dy * vyvec);\n\n        // Scaling factors along x,y axes\n        const sx = 1 + (du * xDir / innerBounds.width);\n        const sy = 1 + (dv * yDir / innerBounds.height);\n\n        const matrix = tempMatrix.identity();\n\n        if (xDir !== 0)\n        {\n            // Origin of horizontal scaling - a point which does not move after applying the transform\n            // eslint-disable-next-line no-nested-ternary\n            const hsOrigin = !this.centeredScaling ? (xDir === 1 ? bounds.topLeft : bounds.topRight) : bounds.center;\n\n            matrix.translate(-hsOrigin.x, -hsOrigin.y)\n                .rotate(-angle)\n                .scale(sx, 1)\n                .rotate(angle)\n                .translate(hsOrigin.x, hsOrigin.y);\n        }\n\n        if (yDir !== 0)\n        {\n            // Origin of vertical scaling - a point which does not move after applying the transform\n            // eslint-disable-next-line no-nested-ternary\n            const vsOrigin = !this.centeredScaling ? (yDir === 1 ? bounds.topLeft : bounds.bottomLeft) : bounds.center;\n\n            matrix.translate(-vsOrigin.x, -vsOrigin.y)\n                .rotate(-angle)\n                .scale(1, sy)\n                .rotate(angle)\n                .translate(vsOrigin.x, vsOrigin.y);\n        }\n\n        this.prependTransform(matrix);\n    };\n\n    /**\n     * This will skew the group such that the skew handle would move to the {@code pointerPosition}.\n     *\n     * @param handle\n     * @param pointerPosition - pointer position, in screen space\n     */\n    skewGroup = (handle: SkewHandle, pointerPosition: Point): void =>\n    {\n        this._transformType = 'skew';\n\n        const bounds = this.groupBounds;\n\n        // Destination point\n        const dst = tempPoint.copyFrom(pointerPosition);\n\n        this.projectionTransform.applyInverse(dst, dst);\n\n        // Center of skew (same as center of rotation!)\n        const sOrigin = bounds.center;\n\n        // Skew matrix\n        const matrix = tempMatrix.identity()\n            .translate(-sOrigin.x, -sOrigin.y);\n        let rotation = this.groupBounds.rotation;\n\n        if (handle === 'skewHorizontal')\n        {\n            const oldSkew = this._skewX;\n\n            // Calculate new skew\n            this._skewX = Math.atan2(dst.y - sOrigin.y, dst.x - sOrigin.x);\n            this._skewX = this.snapAngle(this._skewX, this.skewSnapTolerance, this.skewSnaps);\n\n            // Skew by new skew.x\n            matrix.prepend(createVerticalSkew(-oldSkew));\n            matrix.prepend(createVerticalSkew(this._skewX));\n        }\n        else // skewVertical\n        {\n            const oldSkew = this._skewY;\n\n            // Calculate new skew\n            const newSkew = Math.atan2(dst.y - sOrigin.y, dst.x - sOrigin.x) - (Math.PI / 2);\n\n            this._skewY = newSkew;\n            this._skewY = this.snapAngle(this._skewY, this.skewSnapTolerance, this.skewSnaps);\n\n            // HINT: skewY is applied negatively b/c y-axis is flipped\n            matrix.prepend(createHorizontalSkew(oldSkew));\n            matrix.prepend(createHorizontalSkew(-this._skewY));\n\n            rotation -= this._skewY - oldSkew;\n        }\n\n        matrix.translate(sOrigin.x, sOrigin.y);\n\n        this.prependTransform(matrix, true);\n        this.updateGroupBounds(rotation);\n    };\n\n    /**\n     * This is called after the user finishes dragging a handle. If {@link this.transientGroupTilt} is enabled, it will\n     * reset the rotation of this group (if more than one display-object is grouped).\n     */\n    commitGroup = (): void =>\n    {\n        this._transformType = 'none';\n\n        if (this.transientGroupTilt !== false && this.group.length > 1)\n        {\n            this.updateGroupBounds(0);\n        }\n\n        this.emit('transformcommit');\n    };\n\n    /**\n     * This will update the transformer's geometry and render it to the canvas.\n     *\n     * @override\n     * @param renderer\n     */\n    render(renderer: Renderer): void\n    {\n        this.draw();\n\n        super.render(renderer);\n    }\n\n    /**\n     * Recalculates the transformer's geometry. This is called on each render.\n     */\n    protected draw(): void\n    {\n        const targets = this.group;\n        const { color, thickness } = this._wireframeStyle;\n\n        // Updates occur right here!\n        this.wireframe.clear()\n            .lineStyle(thickness, color);\n\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this.drawBounds(Transformer.calculateOrientedBounds(targets[i], tempBounds));\n        }\n\n        // groupBounds may change on each render-loop b/c of any ongoing animation\n        const groupBounds = targets.length !== 1\n            ? Transformer.calculateGroupOrientedBounds(targets, this.groupBounds.rotation, tempBounds, true)\n            : Transformer.calculateOrientedBounds(targets[0], tempBounds);// Auto-detect rotation\n\n        // Redraw skeleton and position handles\n        this.drawBounds(groupBounds);\n        this.drawHandles(groupBounds);\n\n        // Update cached groupBounds\n        this.groupBounds.copyFrom(groupBounds);\n    }\n\n    /**\n     * Draws the bounding box into {@code this.wireframe}.\n     *\n     * @param bounds\n     */\n    protected drawBounds(bounds: OrientedBounds | AxisAlignedBounds): void\n    {\n        const hull = tempHull;\n\n        // Bring hull into local-space\n        for (let i = 0; i < 4; i++)\n        {\n            this.toTransformerLocal(bounds.hull[i], hull[i]);\n        }\n\n        // Fill polygon with ultra-low alpha to capture pointer events.\n        this.wireframe\n            .beginFill(0xffffff, 1e-4)\n            .drawPolygon(hull)\n            .endFill();\n    }\n\n    /**\n     * Draw the handles and any remaining parts of the wireframe.\n     *\n     * @param groupBounds\n     */\n    protected drawHandles(groupBounds: OrientedBounds): void\n    {\n        const handles = this.handles;\n        const {\n            topLeft: worldTopLeft,\n            topRight: worldTopRight,\n            bottomLeft: worldBottomLeft,\n            bottomRight: worldBottomRight,\n            center: worldCenter,\n        } = groupBounds;\n\n        const [topLeft, topRight, bottomLeft, bottomRight] = tempHull;\n        const center = tempPoint;\n\n        this.toTransformerLocal(worldTopLeft, topLeft);\n        this.toTransformerLocal(worldTopRight, topRight);\n        this.toTransformerLocal(worldBottomLeft, bottomLeft);\n        this.toTransformerLocal(worldBottomRight, bottomRight);\n        this.toTransformerLocal(worldCenter, center);\n\n        if (this._rotateEnabled)\n        {\n            // Midpoint from topLeft to topRight\n            const bx = (topLeft.x + topRight.x) / 2;\n            const by = (topLeft.y + topRight.y) / 2;\n\n            // Vector perpendicular to <bx,by>.\n            let px = -(topLeft.y - topRight.y);\n            let py = (topLeft.x - topRight.x);\n\n            // Normalize <px,py> to 32 units.\n            const pl = Math.sqrt((px * px) + (py * py));\n\n            px *= 32 / pl;\n            py *= 32 / pl;\n\n            handles.rotator.position.x = bx + px;\n            handles.rotator.position.y = by + py;\n\n            this.wireframe.moveTo(bx, by)\n                .lineTo(handles.rotator.position.x, handles.rotator.position.y);\n        }\n\n        if (this._scaleEnabled)\n        {\n            // Scale handles\n            handles.topLeft.position.copyFrom(topLeft);\n            handles.topCenter.position.set((topLeft.x + topRight.x) / 2, (topLeft.y + topRight.y) / 2);\n            handles.topRight.position.copyFrom(topRight);\n            handles.middleLeft.position.set((topLeft.x + bottomLeft.x) / 2, (topLeft.y + bottomLeft.y) / 2);\n            handles.middleCenter.position.set((topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);\n            handles.middleRight.position.set((topRight.x + bottomRight.x) / 2, (topRight.y + bottomRight.y) / 2);\n            handles.bottomLeft.position.copyFrom(bottomLeft);\n            handles.bottomCenter.position.set((bottomLeft.x + bottomRight.x) / 2, (bottomLeft.y + bottomRight.y) / 2);\n            handles.bottomRight.position.copyFrom(bottomRight);\n        }\n\n        if (this._skewEnabled)\n        {\n            const cx = center.x;\n            const cy = center.y;\n\n            // Transform center into screen space\n            this.worldTransform.apply(center, center);\n\n            // Calculate skew handle positions in screen space, and then transform back into local-space. This ensures that\n            // the handles appear at skewRadius distance, regardless of the projection.\n            handles.skewHorizontal.position.set(\n                center.x + (Math.cos(this._skewX) * this.skewRadius),\n                center.y + (Math.sin(this._skewX) * this.skewRadius));\n            handles.skewVertical.position.set( // HINT: Slope = skew.y + Math.PI / 2\n                center.x + (-Math.sin(this._skewY) * this.skewRadius),\n                center.y + (Math.cos(this._skewY) * this.skewRadius));\n            this.worldTransform.applyInverse(handles.skewHorizontal.position, handles.skewHorizontal.position);\n            this.worldTransform.applyInverse(handles.skewVertical.position, handles.skewVertical.position);\n\n            // Restore center to local-space\n            center.set(cx, cy);\n\n            this.wireframe\n                .beginFill(this.wireframeStyle.color)\n                .drawCircle(center.x, center.y, this.wireframeStyle.thickness * 2)\n                .endFill();\n            this.wireframe\n                .moveTo(center.x, center.y)\n                .lineTo(handles.skewHorizontal.x, handles.skewHorizontal.y)\n                .moveTo(center.x, center.y)\n                .lineTo(handles.skewVertical.x, handles.skewVertical.y);\n        }\n\n        // Update transforms\n        for (const handleName in handles)\n        {\n            let rotation = this.groupBounds.rotation;\n\n            if (handleName === 'skewHorizontal')\n            {\n                rotation = this._skewX;\n            }\n            else if (handleName === 'skewVertical')\n            {\n                rotation = this._skewY;\n            }\n\n            const handle: TransformerHandle = handles[handleName];\n\n            handle.rotation = rotation;\n            handle.getBounds(false, tempRect);\n        }\n    }\n\n    /**\n     * Called on the `pointerdown` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerDown(e: InteractionEvent): void\n    {\n        this._pointerDown = true;\n        this._pointerDragging = false;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Called on the `pointermove` event. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerMove(e: InteractionEvent): void\n    {\n        if (!this._pointerDown)\n        {\n            return;\n        }\n\n        const lastPointerPosition = this._pointerPosition;\n        const currentPointerPosition = tempPoint.copyFrom(e.data.global);\n\n        const cx = currentPointerPosition.x;\n        const cy = currentPointerPosition.y;\n\n        // Translate group by difference\n        if (this._pointerDragging && this.translateEnabled)\n        {\n            const [worldOrigin, worldDestination, worldDelta] = tempHull;\n\n            // HINT: The pointer has moved from lastPointerPosition to currentPointerPosition in the transformer's\n            // world space. However, we want to translate the display-object's in their world space; to do this,\n            // we project (0,0) and the delta into their world-space, and take the difference.\n            worldOrigin.set(0, 0);\n            worldDestination.set(\n                currentPointerPosition.x - lastPointerPosition.x,\n                currentPointerPosition.y - lastPointerPosition.y);\n            this.projectionTransform.applyInverse(worldOrigin, worldOrigin);\n            this.projectionTransform.applyInverse(worldDestination, worldDestination);\n\n            worldDelta.set(worldDestination.x - worldOrigin.x, worldDestination.y - worldOrigin.y);\n\n            this.translateGroup(worldDelta);\n        }\n\n        this._pointerPosition.x = cx;\n        this._pointerPosition.y = cy;\n        this._pointerDragging = true;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Called on the `pointerup` and `pointerupoutside` events. You must call the super implementation.\n     *\n     * @param e\n     */\n    protected onPointerUp(e: InteractionEvent): void\n    {\n        this._pointerDragging = false;\n        this._pointerDown = false;\n\n        e.stopPropagation();\n    }\n\n    /**\n     * Applies the given transformation matrix {@code delta} to all the display-objects in the group.\n     *\n     * @param delta - transformation matrix\n     * @param skipUpdate - whether to skip updating the group-bounds after applying the transform\n     */\n    private prependTransform(delta: Matrix, skipUpdate = false): void\n    {\n        const group = this.group;\n\n        for (let i = 0, j = group.length; i < j; i++)\n        {\n            multiplyTransform(group[i], delta, false);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateGroupBounds();\n        }\n\n        this.emit('transformchange', delta);\n    }\n\n    /**\n     * Recalculates {@code this.groupBounds} at the same angle.\n     *\n     * @param rotation - override the group's rotation\n     */\n    private updateGroupBounds(rotation: number = this.groupBounds.rotation): void\n    {\n        Transformer.calculateGroupOrientedBounds(this.group, rotation, this.groupBounds);\n    }\n\n    /**\n     * Snaps the given {@code angle} to one of the snapping angles, if possible.\n     *\n     * @param angle - the input angle\n     * @param snapTolerance - the maximum difference b/w the given angle & a snapping angle\n     * @param snaps - the snapping angles\n     * @returns the snapped angle\n     */\n    private snapAngle(angle: number, snapTolerance: number, snaps?: number[]): number\n    {\n        angle = angle % (Math.PI * 2);\n\n        if (!snaps || snaps.length === 1 || !snapTolerance)\n        {\n            return angle;\n        }\n\n        for (let i = 0, j = snaps.length; i < j; i++)\n        {\n            if (Math.abs(angle - snaps[i]) <= snapTolerance)\n            {\n                return snaps[i];\n            }\n        }\n\n        return angle;\n    }\n\n    /**\n     * Transforms {@code input} from the group's world space into the transformer's local space, and puts the result\n     * into {@code output}.\n     *\n     * @param input\n     * @param output\n     * @returns the output\n     */\n    private toTransformerLocal(input: Point, output: Point): Point\n    {\n        this.projectionTransform.apply(input, output);\n        this.worldTransform.applyInverse(output, output);\n\n        return output;\n    }\n\n    /**\n     * Calculates the positions of the four corners of the display-object. The quadrilateral formed by\n     * these points will be the tightest fit around it.\n     *\n     * @param displayObject - The display object whose corners are to be calculated\n     * @param transform - The transform applied on the display-object. By default, this is its world-transform\n     * @param corners - Optional array of four points to put the result into\n     * @param index - Optional index into \"corners\"\n     * @returns an array of four points holding the positions of the corners\n     */\n    static calculateTransformedCorners(\n        displayObject: DisplayObject,\n        transform: Matrix = displayObject.worldTransform,\n        corners?: Point[],\n        index = 0,\n    ): Point[]\n    {\n        const localBounds = displayObject.getLocalBounds();\n\n        // Don't modify transforms\n        displayObject.getBounds();\n\n        corners = corners || [new Point(), new Point(), new Point(), new Point()];\n        corners[index].set(localBounds.x, localBounds.y);\n        corners[index + 1].set(localBounds.x + localBounds.width, localBounds.y);\n        corners[index + 2].set(localBounds.x + localBounds.width, localBounds.y + localBounds.height);\n        corners[index + 3].set(localBounds.x, localBounds.y + localBounds.height);\n\n        transform.apply(corners[index], corners[index]);\n        transform.apply(corners[index + 1], corners[index + 1]);\n        transform.apply(corners[index + 2], corners[index + 2]);\n        transform.apply(corners[index + 3], corners[index + 3]);\n\n        return corners;\n    }\n\n    /**\n     * Calculates the oriented bounding box of the display-object. This would not bending with any skew\n     * applied on the display-object, i.e. it is guaranteed to be rectangular.\n     *\n     * @param displayObject\n     * @param bounds - the bounds instance to set\n     */\n    static calculateOrientedBounds(displayObject: DisplayObject, bounds?: OrientedBounds): OrientedBounds\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n\n        // Decompose displayObject.worldTransform to get its (world) rotation\n        decomposeTransform(tempTransform, displayObject.worldTransform);\n\n        tempTransform.updateLocalTransform();\n\n        const angle = tempTransform.rotation;\n        const corners = Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, tempCorners);\n\n        // Calculate centroid, which is our center of rotation\n        const cx = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;\n        const cy = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-cx, -cy)\n            .rotate(-tempTransform.rotation)\n            .translate(cx, cy);\n\n        // Calculate unrotated corners\n        matrix.apply(corners[0], corners[0]);\n        matrix.apply(corners[1], corners[1]);\n        matrix.apply(corners[2], corners[2]);\n        matrix.apply(corners[3], corners[3]);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.rotation = angle;\n        bounds.innerBounds.x = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        bounds.innerBounds.y = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        bounds.innerBounds.width = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x) - bounds.innerBounds.x;\n        bounds.innerBounds.height = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y) - bounds.innerBounds.y;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the oriented bounding box of a group of display-objects at a specific angle.\n     *\n     * @param group\n     * @param rotation\n     * @param bounds\n     * @param skipUpdate\n     */\n    static calculateGroupOrientedBounds(\n        group: DisplayObject[],\n        rotation: number,\n        bounds?: OrientedBounds,\n        skipUpdate = false,\n    ): OrientedBounds\n    {\n        const groupLength = group.length;\n        const frames = pointPool.allocateArray(groupLength * 4);// Zero allocations!\n\n        // Calculate display-object frame vertices\n        for (let i = 0; i < groupLength; i++)\n        {\n            const displayObject = group[i];\n\n            // Update worldTransform\n            if (!skipUpdate)\n            {\n                const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n                displayObject.updateTransform();\n                displayObject.disableTempParent(parent);\n            }\n\n            Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, frames, i * 4);\n        }\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .rotate(-rotation);\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = -Number.MAX_VALUE;\n        let maxY = -Number.MAX_VALUE;\n\n        // Unrotate all frame vertices, calculate minX, minY, maxX, maxY for innerBounds\n        for (let i = 0, j = frames.length; i < j; i++)\n        {\n            const point = frames[i];\n\n            matrix.apply(point, point);\n\n            const x = point.x;\n            const y = point.y;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        pointPool.releaseArray(frames);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.innerBounds.x = minX;\n        bounds.innerBounds.y = minY;\n        bounds.innerBounds.width = maxX - minX;\n        bounds.innerBounds.height = maxY - minY;\n        bounds.rotation = rotation;\n\n        matrix.applyInverse(bounds.center, tempPoint);\n        bounds.center.copyFrom(tempPoint);\n\n        return bounds;\n    }\n}\n\n/**\n * This is fired when the transformer modifies the transforms of display-objects.\n *\n * @event Transformer#transformchange\n * @type {Matrix}\n */\n\n/**\n * This is fired when the user lifts the mouse button after dragging a transformer handle. It can be used\n *\n * @event Transformer#transformcommit\n */\n"],"names":["DEFAULT_HANDLE_STYLE","color","outlineColor","outlineThickness","radius","shape","TransformerHandle","Graphics","[object Object]","handle","styleOpts","handler","commit","cursor","super","style","Object","assign","this","_handle","_style","onHandleDelta","onHandleCommit","_dirty","interactive","_pointerDown","_pointerDragging","_pointerPosition","Point","on","onPointerDown","onPointerMove","onPointerUp","value","renderer","draw","render","lineStyle","beginFill","drawRect","drawPolygon","drawCircle","Math","sqrt","endFill","e","stopPropagation","onDrag","onDragStart","onDragEnd","copyFrom","data","global","currentPosition","_","tempMatrix","Matrix","createHorizontalSkew","angle","matrix","identity","c","tan","createVerticalSkew","b","decomposeTransform","transform","rotation","pivot","a","d","skewX","atan2","skewY","set","x","y","skew","scale","position","tx","ty","tempParentMatrix","multiplyTransform","displayObject","skipUpdate","parent","enableTempParent","updateTransform","disableTempParent","worldTransform","parentTransform","IDENTITY","prepend","invert","tempTransform","Transform","tempCorners","tempPoint","tempBounds","OrientedBounds","tempRect","Rectangle","tempHull","tempPointer","pointPool","ObjectPoolFactory","build","HANDLE_TO_CURSOR","topLeft","topCenter","topRight","middleLeft","middleRight","bottomLeft","bottomCenter","bottomRight","SCALE_HANDLES","SCALE_COMPONENTS","middleCenter","HANDLES","DEFAULT_ROTATION_SNAPS","PI","DEFAULT_ROTATION_SNAP_TOLERANCE","DEFAULT_SKEW_SNAPS","DEFAULT_SKEW_SNAP_TOLERANCE","DEFAULT_WIREFRAME_STYLE","thickness","Transformer","Container","options","delta","_transformType","translate","prependTransform","pointerPosition","bounds","groupBounds","handlePosition","apply","handles","projectionTransform","applyInverse","rOrigin","center","orgAngle","deltaAngle","newRotation","snapAngle","rotationSnapTolerance","rotationSnaps","rotate","updateGroupBounds","_skewX","_skewY","xDir","yDir","innerBounds","dx","dy","uxvec","width","uyvec","dv","height","sx","sy","hsOrigin","centeredScaling","vsOrigin","dst","sOrigin","oldSkew","skewSnapTolerance","skewSnaps","newSkew","transientGroupTilt","group","length","emit","undefined","skewRadius","_rotateEnabled","rotateEnabled","_scaleEnabled","scaleEnabled","_skewEnabled","skewEnabled","translateEnabled","wireframe","addChild","_wireframeStyle","wireframeStyle","HandleConstructor","handleConstructor","handleStyle","_handleStyle","rotatorHandles","rotator","rotateGroup","commitGroup","scaleHandles","reduce","handleKey","scaleGroup","visible","skewHandles","skewHorizontal","skewGroup","skewVertical","enabledHandles","_enabledHandles","forEach","transformType","forceUpdate","targets","clear","i","j","drawBounds","calculateOrientedBounds","calculateGroupOrientedBounds","drawHandles","hull","toTransformerLocal","worldTopLeft","worldTopRight","worldBottomLeft","worldBottomRight","worldCenter","bx","by","px","py","pl","moveTo","lineTo","cx","cy","cos","sin","handleName","getBounds","lastPointerPosition","currentPointerPosition","worldOrigin","worldDestination","worldDelta","translateGroup","snapTolerance","snaps","abs","input","output","corners","index","localBounds","getLocalBounds","updateLocalTransform","calculateTransformedCorners","min","max","groupLength","frames","allocateArray","minX","Number","MAX_VALUE","minY","maxX","maxY","point","releaseArray"],"mappings":"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"}