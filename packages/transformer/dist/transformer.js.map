{"version":3,"file":"transformer.js","sources":["../src/TransformerHandle.ts","../src/utils/decomposeTransform.ts","../src/utils/multiplyTransform.ts","../src/Transformer.ts"],"sourcesContent":["/// <reference path=\"./types.d.ts\" />\n\nimport { Graphics } from '@pixi/graphics';\nimport { Point } from '@pixi/math';\n\nimport { InteractionEvent } from '@pixi/interaction';\n\n/**\n * @ignore\n */\nexport interface ITransformerHandleStyle\n{\n    color: number;\n    outlineColor: number;\n    outlineThickness: number;\n    radius: number;\n    shape: string;\n}\n\nconst tempPoint = new Point();\nconst tempDelta = new Point();\n\n/**\n * The default transfomer handle implementation.\n */\nexport class TransformerHandle extends Graphics\n{\n    onHandleDelta: (origin: Point, delta: Point) => void;\n\n    protected style: ITransformerHandleStyle;\n\n    private _pointerDown: boolean;\n    private _pointerDragging: boolean;\n    private _pointerPosition: Point;\n\n    constructor(styleOpts: Partial<ITransformerHandleStyle> = {},\n        handler?: (origin: Point, delta: Point) => void, cursor?: string)\n    {\n        super();\n\n        const style: ITransformerHandleStyle = Object.assign({\n            color: 0xffffff,\n            outlineColor: 0x000000,\n            outlineThickness: 1,\n            radius: 8,\n            shape: 'square',\n        }, styleOpts);\n\n        this.style = style;\n        this.cursor = cursor || 'move';\n        this.onHandleDelta = handler;\n\n        this.lineStyle(style.outlineThickness, style.outlineColor)\n            .beginFill(style.color);\n\n        if (style.shape === 'square')\n        {\n            this.drawRect(-style.radius / 2, -style.radius / 2, style.radius, style.radius);\n        }\n        else\n        {\n            this.drawCircle(0, 0, style.radius);\n        }\n\n        this.endFill();\n\n        this._pointerDown = false;\n        this._pointerDragging = false;\n        this._pointerPosition = new Point();\n\n        this.interactive = true;\n\n        this.on('mousedown', () => { console.log('MD'); });\n\n        this.on('mousedown', this.onPointerDown, this);\n        this.on('mousemove', this.onPointerMove, this);\n        this.on('mouseup', this.onPointerUp, this);\n        this.on('mouseupoutside', this.onPointerUp, this);\n    }\n\n    protected onPointerDown(): void\n    {\n        this._pointerDown = true;\n        this._pointerDragging = false;\n    }\n\n    protected onPointerMove(e: InteractionEvent): void\n    {\n        if (!this._pointerDown)\n        {\n            return;\n        }\n\n        if (this._pointerDragging)\n        {\n            this.onDrag(e);\n        }\n        else\n        {\n            this.onDragStart(e);\n        }\n    }\n\n    protected onPointerUp(e: InteractionEvent): void\n    {\n        if (this._pointerDragging)\n        {\n            this.onDragEnd(e);\n        }\n\n        this._pointerDown = false;\n    }\n\n    protected onDragStart(e: InteractionEvent): void\n    {\n        e.data.getLocalPosition(this.parent, this._pointerPosition);\n\n        this._pointerDragging = true;\n    }\n\n    protected onDrag(e: InteractionEvent): void\n    {\n        const lastPosition = this._pointerPosition;\n        const currentPosition = e.data.getLocalPosition(this.parent, tempPoint);\n\n        // Callback handles the rest!\n        if (this.onHandleDelta)\n        {\n            tempDelta.x = currentPosition.x - lastPosition.x;\n            tempDelta.y = currentPosition.y - lastPosition.y;\n\n            this.onHandleDelta(lastPosition, tempDelta);\n        }\n\n        this._pointerPosition.copyFrom(tempPoint);\n    }\n\n    protected onDragEnd(_: InteractionEvent): void\n    {\n        this._pointerDragging = false;\n    }\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport type { Transform, Matrix } from '@pixi/math';\n\n/**\n * Decomposes the matrix into transform, while preserving rotation & the pivot.\n *\n * @ignore\n * @param transform\n * @param matrix\n * @param rotation\n * @param pivot\n */\nexport function decomposeTransform(\n    transform: Transform,\n    matrix: Matrix,\n    rotation?: number,\n    pivot = transform.pivot,\n): Transform\n{\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n\n    rotation = rotation !== undefined && rotation !== null ? rotation : skewY;\n\n    // set pivot\n    transform.pivot.set(pivot.x, pivot.y);\n\n    // next set rotation, skew angles\n    transform.rotation = rotation;\n    transform.skew.x = rotation + skewX;\n    transform.skew.y = -rotation + skewY;\n\n    // next set scale\n    transform.scale.x = Math.sqrt((a * a) + (b * b));\n    transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n    // next set position\n    transform.position.x = matrix.tx + ((pivot.x * matrix.a) + (pivot.y * matrix.c));\n    transform.position.y = matrix.ty + ((pivot.x * matrix.b) + (pivot.y * matrix.d));\n\n    return transform;\n}\n","/// <reference path=\"../types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\nimport { decomposeTransform } from './decomposeTransform';\n\nimport type { DisplayObject } from '@pixi/display';\n\nconst tempMatrix = new Matrix();\nconst tempParentMatrix = new Matrix();\n\n/**\n * Multiplies the transformation matrix {@code transform} to the display-object's transform.\n *\n * @param displayObject\n * @param transform\n * @param skipUpdate\n */\nexport function multiplyTransform(displayObject: DisplayObject, transform: Matrix, skipUpdate?: boolean): void\n{\n    if (!skipUpdate)\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n    }\n\n    const worldTransform = displayObject.worldTransform;\n    const parentTransform = displayObject.parent\n        ? tempParentMatrix.copyFrom(displayObject.parent.worldTransform)\n        : Matrix.IDENTITY;\n\n    tempMatrix.copyFrom(worldTransform);\n    tempMatrix.prepend(transform);\n    tempMatrix.prepend(parentTransform.invert());// gets new \"local\" transform\n\n    decomposeTransform(displayObject.transform, tempMatrix);\n}\n","/// <reference path=\"./types.d.ts\" />\n\nimport { Renderer } from '@pixi/core';\nimport { DisplayObject, Container } from '@pixi/display';\nimport { Point, Matrix, Transform, Rectangle } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\nimport { AxisAlignedBounds, OrientedBounds } from '@pixi-essentials/bounds';\nimport { ObjectPoolFactory } from '@pixi-essentials/object-pool';\nimport { TransformerHandle } from './TransformerHandle';\nimport { decomposeTransform } from './utils/decomposeTransform';\nimport { multiplyTransform } from './utils/multiplyTransform';\n\nimport type { ITransformerHandleStyle } from './TransformerHandle';\n\n// Preallocated objects\nconst tempTransform = new Transform();\nconst tempCorners: [Point, Point, Point, Point] = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempBounds = new OrientedBounds();\nconst tempRect = new Rectangle();\n\n// Pool for allocating an arbitrary number of points\nconst pointPool = ObjectPoolFactory.build(Point as any);\n\n/**\n * The handles used for rotation.\n *\n * @internal\n * @ignore\n */\ntype RotatorHandle = 'rotator';\n\n/**\n * The handles used for scaling.\n *\n * @internal\n * @ignore\n */\ntype ScaleHandle = 'topLeft' |\n    'topCenter' |\n    'topRight' |\n    'middleLeft' |\n    'middleCenter' |\n    'middleRight' |\n    'bottomLeft' |\n    'bottomCenter' |\n    'bottomRight';\n\n/**\n * All the handles provided by {@link Transformer}.\n *\n * @internal\n * @ignore\n */\ntype Handle = RotatorHandle | ScaleHandle;\n\n/**\n * Specific cursors for each handle\n *\n * @internal\n * @ignore\n */\nconst HANDLE_TO_CURSOR: { [H in Handle]?: string } = {\n    topLeft: 'nw-resize',\n    topCenter: 'n-resize',\n    topRight: 'ne-resize',\n    middleLeft: 'w-resize',\n    middleRight: 'e-resize',\n    bottomLeft: 'sw-resize',\n    bottomCenter: 's-resize',\n    bottomRight: 'se-resize',\n};\n\n/**\n * An array of all {@link ScaleHandle} values.\n *\n * @internal\n * @ignore\n */\nconst SCALE_HANDLES = [\n    'topLeft',\n    'topCenter',\n    'topRight',\n    'middleLeft',\n    'middleCenter',\n    'middleRight',\n    'bottomLeft',\n    'bottomCenter',\n    'bottomRight',\n];\n\n/**\n * This maps each scaling handle to the directions in which the x, y components are outward. A value of\n * zero means that no scaling occurs along that component's axis.\n *\n * @internal\n * @ignore\n */\nconst SCALE_COMPONENTS: {\n    [H in ScaleHandle]: { x: (-1 | 0 | 1); y: (-1 | 0 | 1) };\n } = {\n     topLeft: { x: -1, y: -1 },\n     topCenter: { x: 0, y: -1 },\n     topRight: { x: 1, y: -1 },\n     middleLeft: { x: -1, y: 0 },\n     middleCenter: { x: 0, y: 0 },\n     middleRight: { x: 1, y: 0 },\n     bottomLeft: { x: -1, y: 1 },\n     bottomCenter: { x: 0, y: 1 },\n     bottomRight: { x: 1, y: 1 },\n };\n\ninterface ITransformerStyle\n{\n    color: number;\n    thickness: number;\n}\n\n/**\n * @ignore\n */\nexport interface ITransformerOptions\n{\n    group: DisplayObject[];\n    handleConstructor: typeof DisplayObject;\n    handleStyle: ITransformerHandleStyle;\n    wireframeStyle: ITransformerStyle;\n}\n\n/**\n * {@code Transformer} provides an interactive interface for editing the transforms in a group. It supports translating,\n * scaling, rotating, and skewing display-objects both through interaction and code.\n */\nexport class Transformer extends Container\n{\n    protected group: DisplayObject[];\n    protected groupBounds: OrientedBounds;\n\n    protected handles: { [H in Handle]: TransformerHandle };\n    protected handleStyle: Partial<ITransformerHandleStyle>;\n    protected wireframe: Graphics;\n    protected wireframeStyle: ITransformerStyle;\n\n    /**\n     * @param {object}[options]\n     * @param {DisplayObject[]}[options.group] - the group of display-objects being transformed\n     * @param {typeof TransformerHandle}[options.handleConstructor] - a custom transformer-handle class\n     * @param {object}[options.handleStyle] - styling options for the handle. These cannot be modified afterwards!\n     * @param {number}[options.handleStyle.color] - handle color\n     * @param {string}[options.handleStyle.outlineColor] - color of the handle outline (stroke)\n     * @param {string}[options.handleStyle.outlineThickness] - thickness of the handle outline (stroke)\n     * @param {number}[options.handleStyle.radius] - dimensions of the handle\n     * @param {string}[options.handleStyle.shape] - 'circle' or 'square'\n     * @param {object}[options.wireframeStyle] - styling options for the wireframe.\n     * @param {number}[options.wireframeStyle.color] - color of the lines\n     * @param {number}[options.wireframeStyle.thickness] - thickness of the lines\n     */\n    constructor(options: Partial<ITransformerOptions> = {})\n    {\n        super();\n\n        this.group = options.group || [];\n\n        this.interactive = true;\n        this.cursor = 'move';\n\n        /**\n         * Draws the bounding boxes\n         */\n        this.wireframe = this.addChild(new Graphics());\n\n        /**\n         * The wireframe style applied on the transformer\n         */\n        this.wireframeStyle = Object.assign({\n            color: 0x000000,\n            thickness: 2,\n        }, options.wireframeStyle || {});\n\n        const HandleConstructor = options.handleConstructor || TransformerHandle;\n        const handleStyle = options.handleStyle || {};\n\n        this.handleStyle = handleStyle;\n\n        // Initialize transformer handles\n        const rotatorHandles = {\n            rotator: this.addChild(new HandleConstructor(handleStyle,\n                (origin: Point, delta: Point) => { this.rotateGroup('rotator', origin, delta); })),\n        };\n        const scaleHandles = SCALE_HANDLES.reduce((scaleHandles, handleKey) =>\n        {\n            const handleDelta = (_: Point, delta: Point): void =>\n            {\n                this.scaleGroup(handleKey as ScaleHandle, delta);\n            };\n\n            scaleHandles[handleKey] = new HandleConstructor(handleStyle, handleDelta, HANDLE_TO_CURSOR[handleKey]);\n            this.addChild(scaleHandles[handleKey]);\n\n            return scaleHandles;\n        }, {});\n\n        this.handles = Object.assign({}, rotatorHandles, scaleHandles) as { [H in Handle]: TransformerHandle };\n        this.handles.middleCenter.visible = false;\n\n        // Update groupBounds immediately. This is because mouse events can propagate before the next animation frame.\n        this.groupBounds = new OrientedBounds();\n        this.updateGroupBounds();\n    }\n\n    /**\n     * This will rotate the group such that the {@code origin} point will move by {@code delta}.\n     *\n     * @param handle - the rotator handle was dragged\n     * @param origin - the original pointer position (before dragging)\n     * @param delta - the difference in pointer position (after dragging)\n     */\n    rotateGroup = (_: RotatorHandle, origin: Point, delta: Point): void =>\n    {\n        const bounds = this.groupBounds;\n        const destination = tempPoint.set(origin.x + delta.x, origin.y + delta.y);\n\n        // Center of rotation - does not change in transformation\n        const rOrigin = bounds.center;\n\n        // Original angle subtended by pointer\n        const orgAngle = Math.atan2(origin.y - rOrigin.y, origin.x - rOrigin.x);\n\n        // Final angle subtended by pointer\n        const dstAngle = Math.atan2(destination.y - rOrigin.y, destination.x - rOrigin.x);\n\n        // The angle by which bounds should be rotated\n        const deltaAngle = dstAngle - orgAngle;\n\n        // Rotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-rOrigin.x, -rOrigin.y)\n            .rotate(deltaAngle)\n            .translate(rOrigin.x, rOrigin.y);\n\n        this.prependTransform(matrix, true);\n        this.updateGroupBounds(bounds.rotation + deltaAngle);\n    };\n\n    /**\n     * This will scale the group such that the handle will move by {@code delta}.\n     *\n     * @param handle - the scaling handle that was dragged\n     * @param delta - the change in pointer position since the last event\n     */\n    scaleGroup = (handle: ScaleHandle, delta: Point): void =>\n    {\n        // Directions along x,y axes that will produce positive scaling\n        const xDir = SCALE_COMPONENTS[handle].x;\n        const yDir = SCALE_COMPONENTS[handle].y;\n\n        const bounds = this.groupBounds;\n        const angle = bounds.rotation;\n        const innerBounds = bounds.innerBounds;\n\n        // Delta vector in world frame\n        const dx = delta.x;\n        const dy = delta.y;\n\n        // Unit vector along u-axis (horizontal axis after rotation) of bounds\n        const uxvec = (bounds.topRight.x - bounds.topLeft.x) / innerBounds.width;\n        const uyvec = (bounds.topRight.y - bounds.topLeft.y) / innerBounds.width;\n\n        // Unit vector along v-axis (vertical axis after rotation) of bounds\n        const vxvec = (bounds.bottomLeft.x - bounds.topLeft.x) / innerBounds.height;\n        const vyvec = (bounds.bottomLeft.y - bounds.topLeft.y) / innerBounds.height;\n\n        // Delta vector in rotated frame of bounds\n        const du = (dx * uxvec) + (dy * uyvec);\n        const dv = (dx * vxvec) + (dy * vyvec);\n\n        // Scaling factors along x,y axes\n        const sx = 1 + (du * xDir / innerBounds.width);\n        const sy = 1 + (dv * yDir / innerBounds.height);\n\n        const matrix = tempMatrix.identity();\n\n        if (xDir !== 0)\n        {\n            // Origin of horizontal scaling - a point which does not move after applying the transform\n            const hsOrigin = xDir === 1 ? bounds.topLeft : bounds.topRight;\n\n            matrix.translate(-hsOrigin.x, -hsOrigin.y)\n                .rotate(-angle)\n                .scale(sx, 1)\n                .rotate(angle)\n                .translate(hsOrigin.x, hsOrigin.y);\n        }\n\n        if (yDir !== 0)\n        {\n            // Origin of vertical scaling - a point which does not move after applying the transform\n            const vsOrigin = yDir === 1 ? bounds.topLeft : bounds.bottomLeft;\n\n            matrix.translate(-vsOrigin.x, -vsOrigin.y)\n                .rotate(-angle)\n                .scale(1, sy)\n                .rotate(angle)\n                .translate(vsOrigin.x, vsOrigin.y);\n        }\n\n        this.prependTransform(matrix);\n    };\n\n    /**\n     * This will update the transformer's geometry and render it to the canvas.\n     *\n     * @override\n     * @param renderer\n     */\n    render(renderer: Renderer): void\n    {\n        const targets = this.group;\n        const { color, thickness } = this.wireframeStyle;\n\n        // Updates occur right here!\n        this.wireframe.clear()\n            .lineStyle(thickness, color);\n\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this.drawBounds(Transformer.calculateOrientedBounds(targets[i], tempBounds));\n        }\n\n        // groupBounds may change on each render-loop b/c of any ongoing animation\n        const groupBounds = Transformer.calculateGroupOrientedBounds(targets, this.groupBounds.rotation, tempBounds, true);\n\n        // Redraw skeleton and position handles\n        this.drawBounds(groupBounds);\n        this.drawHandles(groupBounds);\n\n        // Update cached groupBounds\n        this.groupBounds.copyFrom(groupBounds);\n\n        super.render(renderer);\n    }\n\n    /**\n     * Draws the bounding box into {@code this.skeleton}.\n     *\n     * @param bounds\n     */\n    protected drawBounds(bounds: OrientedBounds | AxisAlignedBounds): void\n    {\n        this.wireframe\n            .drawPolygon(bounds.hull);\n    }\n\n    /**\n     * Draw the handles and any remaining parts of the skeleton\n     *\n     * @param groupBounds\n     */\n    protected drawHandles(groupBounds: OrientedBounds): void\n    {\n        const handles = this.handles;\n\n        const { topLeft, topRight, bottomLeft, bottomRight } = groupBounds;\n\n        handles.topLeft.position.copyFrom(topLeft);\n        handles.topCenter.position.set((topLeft.x + topRight.x) / 2, (topLeft.y + topRight.y) / 2);\n        handles.topRight.position.copyFrom(topRight);\n        handles.middleLeft.position.set((topLeft.x + bottomLeft.x) / 2, (topLeft.y + bottomLeft.y) / 2);\n        handles.middleCenter.position.set((topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);\n        handles.middleRight.position.set((topRight.x + bottomRight.x) / 2, (topRight.y + bottomRight.y) / 2);\n        handles.bottomLeft.position.copyFrom(bottomLeft);\n        handles.bottomCenter.position.set((bottomLeft.x + bottomRight.x) / 2, (bottomLeft.y + bottomRight.y) / 2);\n        handles.bottomRight.position.copyFrom(bottomRight);\n\n        groupBounds.innerBounds.pad(32);\n\n        handles.rotator.position.x = (groupBounds.topLeft.x + groupBounds.topRight.x) / 2;\n        handles.rotator.position.y = (groupBounds.topLeft.y + groupBounds.topRight.y) / 2;\n\n        groupBounds.innerBounds.pad(-32);\n\n        const bx = (groupBounds.topLeft.x + groupBounds.topRight.x) / 2;\n        const by = (groupBounds.topLeft.y + groupBounds.topRight.y) / 2;\n\n        this.wireframe.moveTo(bx, by)\n            .lineTo(handles.rotator.position.x, handles.rotator.position.y);\n\n        // Update transforms\n        for (const handleName in handles)\n        {\n            const handle: TransformerHandle = handles[handleName];\n\n            handle.rotation = groupBounds.rotation;\n            handle.getBounds(false, tempRect);\n        }\n    }\n\n    /**\n     * Applies the given transformation matrix {@code delta} to all the display-objects in the group.\n     *\n     * @param delta - transformation matrix\n     * @param skipUpdate - whether to skip updating the group-bounds after applying the transform\n     */\n    private prependTransform(delta: Matrix, skipUpdate = false): void\n    {\n        const group = this.group;\n\n        for (let i = 0, j = group.length; i < j; i++)\n        {\n            multiplyTransform(group[i], delta, false);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateGroupBounds();\n        }\n    }\n\n    /**\n     * Recalculates {@code this.groupBounds} at the same angle.\n     *\n     * @param rotation - override the group's rotation\n     */\n    private updateGroupBounds(rotation: number = this.groupBounds.rotation): void\n    {\n        Transformer.calculateGroupOrientedBounds(this.group, rotation, this.groupBounds);\n    }\n\n    /**\n     * Calculates the positions of the four corners of the display-object. The quadrilateral formed by\n     * these points will be the tightest fit around it.\n     *\n     * @param displayObject - The display object whose corners are to be calculated\n     * @param transform - The transform applied on the display-object. By default, this is its world-transform\n     * @param corners - Optional array of four points to put the result into\n     * @param index - Optional index into \"corners\"\n     */\n    static calculateTransformedCorners(\n        displayObject: DisplayObject,\n        transform: Matrix = displayObject.worldTransform,\n        corners?: Point[],\n        index = 0,\n    ): Point[]\n    {\n        const localBounds = displayObject.getLocalBounds();\n\n        // Don't modify transforms\n        displayObject.getBounds();\n\n        corners = corners || [new Point(), new Point(), new Point(), new Point()];\n        corners[index].set(localBounds.x, localBounds.y);\n        corners[index + 1].set(localBounds.x + localBounds.width, localBounds.y);\n        corners[index + 2].set(localBounds.x + localBounds.width, localBounds.y + localBounds.height);\n        corners[index + 3].set(localBounds.x, localBounds.y + localBounds.height);\n\n        transform.apply(corners[index], corners[index]);\n        transform.apply(corners[index + 1], corners[index + 1]);\n        transform.apply(corners[index + 2], corners[index + 2]);\n        transform.apply(corners[index + 3], corners[index + 3]);\n\n        return corners;\n    }\n\n    /**\n     * Calculates the oriented bounding box of the display-object. This would not bending with any skew\n     * applied on the display-object, i.e. it is guaranteed to be rectangular.\n     *\n     * @param displayObject\n     * @param bounds - the bounds instance to set\n     */\n    static calculateOrientedBounds(displayObject: DisplayObject, bounds?: OrientedBounds): OrientedBounds\n    {\n        const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n        displayObject.updateTransform();\n        displayObject.disableTempParent(parent);\n\n        // Decompose displayObject.worldTransform to get its (world) rotation\n        decomposeTransform(tempTransform, displayObject.worldTransform);\n\n        tempTransform.updateLocalTransform();\n\n        const angle = tempTransform.rotation;\n        const corners = Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, tempCorners);\n\n        // Calculate centroid, which is our center of rotatation\n        const cx = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4;\n        const cy = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4;\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .translate(-cx, -cy)\n            .rotate(-tempTransform.rotation)\n            .translate(cx, cy);\n\n        // Calculate unrotated corners\n        matrix.apply(corners[0], corners[0]);\n        matrix.apply(corners[1], corners[1]);\n        matrix.apply(corners[2], corners[2]);\n        matrix.apply(corners[3], corners[3]);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.rotation = angle;\n        bounds.innerBounds.x = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        bounds.innerBounds.y = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        bounds.innerBounds.width = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x) - bounds.innerBounds.x;\n        bounds.innerBounds.height = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y) - bounds.innerBounds.y;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the oriented bounding box of a group of display-objects at a specific angle.\n     *\n     * @param group\n     * @param rotation\n     * @param bounds\n     * @param skipUpdate\n     */\n    static calculateGroupOrientedBounds(\n        group: DisplayObject[],\n        rotation: number,\n        bounds?: OrientedBounds,\n        skipUpdate = false,\n    ): OrientedBounds\n    {\n        const groupLength = group.length;\n        const frames = pointPool.allocateArray(groupLength * 4);// Zero allocations!\n\n        // Calculate display-object frame vertices\n        for (let i = 0; i < groupLength; i++)\n        {\n            const displayObject = group[i];\n\n            // Update worldTransform\n            if (!skipUpdate)\n            {\n                const parent = !displayObject.parent ? displayObject.enableTempParent() : displayObject.parent;\n\n                displayObject.updateTransform();\n                displayObject.disableTempParent(parent);\n            }\n\n            Transformer.calculateTransformedCorners(displayObject, displayObject.worldTransform, frames, i * 4);\n        }\n\n        // Unrotation matrix\n        const matrix = tempMatrix\n            .identity()\n            .rotate(-rotation);\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = -Number.MAX_VALUE;\n        let maxY = -Number.MAX_VALUE;\n\n        // Unrotate all frame vertices, calculate minX, minY, maxX, maxY for innerBounds\n        for (let i = 0, j = frames.length; i < j; i++)\n        {\n            const point = frames[i];\n\n            matrix.apply(point, point);\n\n            const x = point.x;\n            const y = point.y;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        pointPool.releaseArray(frames);\n\n        bounds = bounds || new OrientedBounds();\n        bounds.innerBounds.x = minX;\n        bounds.innerBounds.y = minY;\n        bounds.innerBounds.width = maxX - minX;\n        bounds.innerBounds.height = maxY - minY;\n        bounds.rotation = rotation;\n\n        matrix.applyInverse(bounds.center, tempPoint);\n        bounds.center.copyFrom(tempPoint);\n\n        return bounds;\n    }\n}\n"],"names":["tempPoint","Point","tempDelta","TransformerHandle","Graphics","[object Object]","styleOpts","handler","cursor","super","style","Object","assign","color","outlineColor","outlineThickness","radius","shape","this","onHandleDelta","lineStyle","beginFill","drawRect","drawCircle","endFill","_pointerDown","_pointerDragging","_pointerPosition","interactive","on","console","log","onPointerDown","onPointerMove","onPointerUp","e","onDrag","onDragStart","onDragEnd","data","getLocalPosition","parent","lastPosition","currentPosition","x","y","copyFrom","_","decomposeTransform","transform","matrix","rotation","pivot","a","b","c","d","skewX","Math","atan2","skewY","set","skew","scale","sqrt","position","tx","ty","tempMatrix","Matrix","tempParentMatrix","multiplyTransform","displayObject","skipUpdate","enableTempParent","updateTransform","disableTempParent","worldTransform","parentTransform","IDENTITY","prepend","invert","tempTransform","Transform","tempCorners","tempBounds","OrientedBounds","tempRect","Rectangle","pointPool","ObjectPoolFactory","build","HANDLE_TO_CURSOR","topLeft","topCenter","topRight","middleLeft","middleRight","bottomLeft","bottomCenter","bottomRight","SCALE_HANDLES","SCALE_COMPONENTS","middleCenter","Transformer","Container","options","origin","delta","bounds","groupBounds","destination","rOrigin","center","orgAngle","deltaAngle","identity","translate","rotate","prependTransform","updateGroupBounds","handle","xDir","yDir","angle","innerBounds","dx","dy","uxvec","width","uyvec","dv","height","sx","sy","hsOrigin","vsOrigin","group","wireframe","addChild","wireframeStyle","thickness","HandleConstructor","handleConstructor","handleStyle","rotatorHandles","rotator","rotateGroup","scaleHandles","reduce","handleKey","scaleGroup","handles","visible","renderer","targets","clear","i","j","length","drawBounds","calculateOrientedBounds","calculateGroupOrientedBounds","drawHandles","render","drawPolygon","hull","pad","bx","by","moveTo","lineTo","handleName","getBounds","corners","index","localBounds","getLocalBounds","apply","updateLocalTransform","calculateTransformedCorners","cx","cy","min","max","groupLength","frames","allocateArray","minX","Number","MAX_VALUE","minY","maxX","maxY","point","releaseArray","applyInverse"],"mappings":"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"}