/*!
 * @pixi-essentials/transformer - v2.0.1
 * Compiled Sun, 16 Aug 2020 19:22:28 UTC
 *
 * @pixi-essentials/transformer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal, All Rights Reserved
 */
this.PIXI=this.PIXI||{};var _pixi_essentials_transformer=function(t,e,i,s,n,o,r){"use strict";const a={color:16777215,outlineColor:0,outlineThickness:1,radius:8,shape:"tooth"},h=new s.Point;class d extends n.Graphics{constructor(t,e={},i,n,o){super();const r=Object.assign({},a,e);this._handle=t,this._style=r,this.onHandleDelta=i,this.onHandleCommit=n,this._dirty=!0,this.interactive=!0,this.cursor=o||"move",this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new s.Point,this.on("mousedown",this.onPointerDown,this),this.on("mousemove",this.onPointerMove,this),this.on("mouseup",this.onPointerUp,this),this.on("mouseupoutside",this.onPointerUp,this)}get style(){return this._style}set style(t){this._style=Object.assign({},a,t),this._dirty=!0}render(t){this._dirty&&(this.draw(),this._dirty=!1),super.render(t)}draw(){const t=this._handle,e=this._style;if(this.lineStyle(e.outlineThickness,e.outlineColor).beginFill(e.color),"square"===e.shape)this.drawRect(-e.radius/2,-e.radius/2,e.radius,e.radius);else if("tooth"===e.shape)switch(t){case"middleLeft":this.drawPolygon([-e.radius/2,-e.radius/2,-e.radius/2,e.radius/2,e.radius/2,e.radius/2,1.1*e.radius,0,e.radius/2,-e.radius/2]);break;case"topCenter":this.drawPolygon([-e.radius/2,-e.radius/2,e.radius/2,-e.radius/2,e.radius/2,e.radius/2,0,1.1*e.radius,-e.radius/2,e.radius/2]);break;case"middleRight":this.drawPolygon([-e.radius/2,e.radius/2,1.1*-e.radius,0,-e.radius/2,-e.radius/2,e.radius/2,-e.radius/2,e.radius/2,e.radius/2]);break;case"bottomCenter":this.drawPolygon([0,1.1*-e.radius,e.radius/2,-e.radius/2,e.radius/2,e.radius/2,-e.radius/2,e.radius/2,-e.radius/2,-e.radius/2]);break;case"rotator":this.drawCircle(0,0,e.radius/Math.sqrt(2));break;default:this.drawRect(-e.radius/2,-e.radius/2,e.radius,e.radius)}else this.drawCircle(0,0,e.radius);this.endFill()}onPointerDown(t){this._pointerDown=!0,this._pointerDragging=!1,t.stopPropagation()}onPointerMove(t){this._pointerDown&&(this._pointerDragging?this.onDrag(t):this.onDragStart(t),t.stopPropagation())}onPointerUp(t){this._pointerDragging&&this.onDragEnd(t),this._pointerDown=!1}onDragStart(t){t.data.getLocalPosition(this.parent,this._pointerPosition),this._pointerDragging=!0}onDrag(t){const e=t.data.getLocalPosition(this.parent,h);this.onHandleDelta&&this.onHandleDelta(e),this._pointerPosition.copyFrom(e)}onDragEnd(t){this._pointerDragging=!1,this.onHandleCommit&&this.onHandleCommit()}}const l=new s.Matrix;function p(t){const e=l.identity();return e.c=Math.tan(t),e}function u(t){const e=l.identity();return e.b=Math.tan(t),e}function c(t,e,i,s=t.pivot){const n=e.a,o=e.b,r=e.c,a=e.d,h=-Math.atan2(-r,a),d=Math.atan2(o,n);return i=null!=i?i:d,t.pivot.set(s.x,s.y),t.rotation=i,t.skew.x=i+h,t.skew.y=-i+d,t.scale.x=Math.sqrt(n*n+o*o),t.scale.y=Math.sqrt(r*r+a*a),t.position.x=e.tx+(s.x*e.a+s.y*e.c),t.position.y=e.ty+(s.x*e.b+s.y*e.d),t}const w=new s.Matrix,y=new s.Matrix;function g(t,e,i){if(!i){const e=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(e)}const n=t.worldTransform,o=t.parent?y.copyFrom(t.parent.worldTransform):s.Matrix.IDENTITY;w.copyFrom(n),w.prepend(e),w.prepend(o.invert()),c(t.transform,w)}const m=new s.Transform,b=[new s.Point,new s.Point,new s.Point,new s.Point],f=new s.Matrix,_=new s.Point,x=new o.OrientedBounds,k=new s.Rectangle,P=r.ObjectPoolFactory.build(s.Point),T={topLeft:"nw-resize",topCenter:"n-resize",topRight:"ne-resize",middleLeft:"w-resize",middleRight:"e-resize",bottomLeft:"sw-resize",bottomCenter:"s-resize",bottomRight:"se-resize"},B=["topLeft","topCenter","topRight","middleLeft","middleCenter","middleRight","bottomLeft","bottomCenter","bottomRight"],M={topLeft:{x:-1,y:-1},topCenter:{x:0,y:-1},topRight:{x:1,y:-1},middleLeft:{x:-1,y:0},middleCenter:{x:0,y:0},middleRight:{x:1,y:0},bottomLeft:{x:-1,y:1},bottomCenter:{x:0,y:1},bottomRight:{x:1,y:1}},E=[...B,"rotator","skewHorizontal","skewVertical"],S=[Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,-Math.PI/4,-Math.PI/2,3*-Math.PI/4],L=Math.PI/90,v=[Math.PI/4,-Math.PI/4],C=Math.PI/90,D={color:0,thickness:2};class I extends i.Container{constructor(t={}){super(),this.translateGroup=t=>{const e=f.identity().translate(t.x,t.y);this.prependTransform(e)},this.rotateGroup=(t,e)=>{const i=this.groupBounds,s=this.handles[t].position,n=e,o=i.center,r=Math.atan2(s.y-o.y,s.x-o.x);let a=Math.atan2(n.y-o.y,n.x-o.x)-r,h=this.groupBounds.rotation+a;h=this.snapAngle(h,this.rotationSnapTolerance,this.rotationSnaps),a=h-this.groupBounds.rotation;const d=f.identity().translate(-o.x,-o.y).rotate(a).translate(o.x,o.y);this.prependTransform(d,!0),this.updateGroupBounds(h),this._skewX+=a,this._skewY+=a},this.scaleGroup=(t,e)=>{const i=M[t].x,s=M[t].y,n=this.groupBounds,o=n.rotation,r=n.innerBounds,a=e.x-this.handles[t].x,h=e.y-this.handles[t].y,d=(n.topRight.x-n.topLeft.x)/r.width,l=(n.topRight.y-n.topLeft.y)/r.width,p=a*((n.bottomLeft.x-n.topLeft.x)/r.height)+h*((n.bottomLeft.y-n.topLeft.y)/r.height),u=1+(a*d+h*l)*i/r.width,c=1+p*s/r.height,w=f.identity();if(0!==i){const t=this.centeredScaling?n.center:1===i?n.topLeft:n.topRight;w.translate(-t.x,-t.y).rotate(-o).scale(u,1).rotate(o).translate(t.x,t.y)}if(0!==s){const t=this.centeredScaling?n.center:1===s?n.topLeft:n.bottomLeft;w.translate(-t.x,-t.y).rotate(-o).scale(1,c).rotate(o).translate(t.x,t.y)}this.prependTransform(w)},this.skewGroup=(t,e)=>{const i=this.groupBounds,s=_.copyFrom(e),n=i.center,o=f.identity().translate(-n.x,-n.y);let r=this.groupBounds.rotation;if("skewHorizontal"===t){const t=this._skewX;this._skewX=Math.atan2(s.y-n.y,s.x-n.x),this._skewX=this.snapAngle(this._skewX,this.skewSnapTolerance,this.skewSnaps),o.prepend(u(-t)),o.prepend(u(this._skewX))}else{const t=this._skewY,e=Math.atan2(s.y-n.y,s.x-n.x)-Math.PI/2;this._skewY=e,this._skewY=this.snapAngle(this._skewY,this.skewSnapTolerance,this.skewSnaps),o.prepend(p(t)),o.prepend(p(-this._skewY)),r-=this._skewY-t}o.translate(n.x,n.y),this.prependTransform(o,!0),this.updateGroupBounds(r)},this.commitGroup=()=>{!1!==this.transientGroupTilt&&this.group.length>1&&this.updateGroupBounds(0)},this.interactive=!0,this.cursor="move",this.group=t.group||[],this.centeredScaling=!!t.centeredScaling,this.rotationSnaps=t.rotationSnaps||S,this.rotationSnapTolerance=void 0!==t.rotationSnapTolerance?t.rotationSnapTolerance:L,this.skewRadius=t.skewRadius||64,this.skewSnaps=t.skewSnaps||v,this.skewSnapTolerance=void 0!==t.skewSnapTolerance?t.skewSnapTolerance:C,this._rotateEnabled=!1!==t.rotateEnabled,this._scaleEnabled=!1!==t.scaleEnabled,this._skewEnabled=!0===t.skewEnabled,this.translateEnabled=!1!==t.translateEnabled,this.transientGroupTilt=void 0===t.transientGroupTilt||t.transientGroupTilt,this.wireframe=this.addChild(new n.Graphics),this._skewX=0,this._skewY=0,this._wireframeStyle=Object.assign({},D,t.wireframeStyle||{});const e=t.handleConstructor||d,i=t.handleStyle||{};this._handleStyle=i;const r={rotator:this.addChild(new e("rotator",i,t=>{this.rotateGroup("rotator",t)},this.commitGroup))},a=B.reduce((t,s)=>(t[s]=new e(s,i,t=>{this.scaleGroup(s,t)},this.commitGroup,T[s]),t[s].visible=this._scaleEnabled,this.addChild(t[s]),t),{}),h={skewHorizontal:this.addChild(new e("skewHorizontal",i,t=>{this.skewGroup("skewHorizontal",t)},this.commitGroup,"pointer")),skewVertical:this.addChild(new e("skewVertical",i,t=>{this.skewGroup("skewVertical",t)},this.commitGroup,"pointer"))};this.handles=Object.assign({},r,a,h),this.handles.middleCenter.visible=!1,this.handles.skewHorizontal.visible=this._skewEnabled,this.handles.skewVertical.visible=this._skewEnabled,this.groupBounds=new o.OrientedBounds,this.updateGroupBounds(),this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new s.Point,this.on("pointerdown",this.onPointerDown,this),this.on("pointermove",this.onPointerMove,this),this.on("pointerup",this.onPointerUp,this),this.on("pointerupoutside",this.onPointerUp,this)}get enabledHandles(){return this._enabledHandles}set enabledHandles(t){(this._enabledHandles||t)&&(this._enabledHandles=t,E.forEach(t=>{this.handles[t].visible=!1}),t?t.forEach(t=>{this.handles[t].visible=!0}):(this.handles.rotator.visible=this._rotateEnabled,this.handles.skewHorizontal.visible=this._skewEnabled,this.handles.skewVertical.visible=this._skewEnabled,B.forEach(t=>{"middleCenter"!==t&&(this.handles[t].visible=this._scaleEnabled)})))}get handleStyle(){return this._handleStyle}set handleStyle(t){const e=this.handles;for(const i in e)e[i].style=t;this._handleStyle=t}get rotateEnabled(){return this._rotateEnabled}set rotateEnabled(t){if(!this._rotateEnabled!==t){if(this._rotateEnabled=t,this._enabledHandles)return;this.handles.rotator.visible=t}}get scaleEnabled(){return this._scaleEnabled}set scaleEnabled(t){if(!this._scaleEnabled!==t){if(this._scaleEnabled=t,this._enabledHandles)return;B.forEach(e=>{"middleCenter"!==e&&(this.handles[e].visible=t)})}}get skewEnabled(){return this._skewEnabled}set skewEnabled(t){if(this._skewEnabled!==t){if(this._skewEnabled=t,this._enabledHandles)return;this.handles.skewHorizontal.visible=t,this.handles.skewVertical.visible=t}}get wireframeStyle(){return this._wireframeStyle}set wireframeStyle(t){this._wireframeStyle=Object.assign({},D,t)}render(t){this.draw(),super.render(t)}draw(){const t=this.group,{color:e,thickness:i}=this._wireframeStyle;this.wireframe.clear().lineStyle(i,e);for(let e=0,i=t.length;e<i;e++)this.drawBounds(I.calculateOrientedBounds(t[e],x));const s=1!==t.length?I.calculateGroupOrientedBounds(t,this.groupBounds.rotation,x,!0):I.calculateOrientedBounds(t[0],x);this.drawBounds(s),this.drawHandles(s),this.groupBounds.copyFrom(s)}drawBounds(t){this.wireframe.beginFill(16777215,1e-4).drawPolygon(t.hull).endFill()}drawHandles(t){const e=this.handles,{topLeft:i,topRight:s,bottomLeft:n,bottomRight:o,center:r}=t;if(this._rotateEnabled){t.innerBounds.pad(32),e.rotator.position.x=(t.topLeft.x+t.topRight.x)/2,e.rotator.position.y=(t.topLeft.y+t.topRight.y)/2,t.innerBounds.pad(-32);const i=(t.topLeft.x+t.topRight.x)/2,s=(t.topLeft.y+t.topRight.y)/2;this.wireframe.moveTo(i,s).lineTo(e.rotator.position.x,e.rotator.position.y)}this._scaleEnabled&&(e.topLeft.position.copyFrom(i),e.topCenter.position.set((i.x+s.x)/2,(i.y+s.y)/2),e.topRight.position.copyFrom(s),e.middleLeft.position.set((i.x+n.x)/2,(i.y+n.y)/2),e.middleCenter.position.set((i.x+o.x)/2,(i.y+o.y)/2),e.middleRight.position.set((s.x+o.x)/2,(s.y+o.y)/2),e.bottomLeft.position.copyFrom(n),e.bottomCenter.position.set((n.x+o.x)/2,(n.y+o.y)/2),e.bottomRight.position.copyFrom(o)),this._skewEnabled&&(e.skewHorizontal.position.set(r.x+Math.cos(this._skewX)*this.skewRadius,r.y+Math.sin(this._skewX)*this.skewRadius),e.skewVertical.position.set(r.x+-Math.sin(this._skewY)*this.skewRadius,r.y+Math.cos(this._skewY)*this.skewRadius),this.wireframe.beginFill(this.wireframeStyle.color).drawCircle(r.x,r.y,2*this.wireframeStyle.thickness).endFill(),this.wireframe.moveTo(r.x,r.y).lineTo(e.skewHorizontal.x,e.skewHorizontal.y).moveTo(r.x,r.y).lineTo(e.skewVertical.x,e.skewVertical.y));for(const t in e){let i=this.groupBounds.rotation;"skewHorizontal"===t?i=this._skewX:"skewVertical"===t&&(i=this._skewY);const s=e[t];s.rotation=i,s.getBounds(!1,k)}}onPointerDown(t){this._pointerDown=!0,this._pointerDragging=!1,t.stopPropagation()}onPointerMove(t){if(!this._pointerDown)return;const e=this._pointerPosition,i=t.data.getLocalPosition(this,_),s=i.x,n=i.y;if(this._pointerDragging&&this.translateEnabled){const t=i;t.x-=e.x,t.y-=e.y,this.translateGroup(t)}this._pointerPosition.x=s,this._pointerPosition.y=n,this._pointerDragging=!0,t.stopPropagation()}onPointerUp(t){this._pointerDragging=!1,this._pointerDown=!1,t.stopPropagation()}prependTransform(t,e=!1){const i=this.group;for(let e=0,s=i.length;e<s;e++)g(i[e],t,!1);e||this.updateGroupBounds()}updateGroupBounds(t=this.groupBounds.rotation){I.calculateGroupOrientedBounds(this.group,t,this.groupBounds)}snapAngle(t,e,i){if(t%=2*Math.PI,!i||1===i.length||!e)return t;for(let s=0,n=i.length;s<n;s++)if(Math.abs(t-i[s])<=e)return i[s];return t}static calculateTransformedCorners(t,e=t.worldTransform,i,n=0){const o=t.getLocalBounds();return t.getBounds(),(i=i||[new s.Point,new s.Point,new s.Point,new s.Point])[n].set(o.x,o.y),i[n+1].set(o.x+o.width,o.y),i[n+2].set(o.x+o.width,o.y+o.height),i[n+3].set(o.x,o.y+o.height),e.apply(i[n],i[n]),e.apply(i[n+1],i[n+1]),e.apply(i[n+2],i[n+2]),e.apply(i[n+3],i[n+3]),i}static calculateOrientedBounds(t,e){const i=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(i),c(m,t.worldTransform),m.updateLocalTransform();const s=m.rotation,n=I.calculateTransformedCorners(t,t.worldTransform,b),r=(n[0].x+n[1].x+n[2].x+n[3].x)/4,a=(n[0].y+n[1].y+n[2].y+n[3].y)/4,h=f.identity().translate(-r,-a).rotate(-m.rotation).translate(r,a);return h.apply(n[0],n[0]),h.apply(n[1],n[1]),h.apply(n[2],n[2]),h.apply(n[3],n[3]),(e=e||new o.OrientedBounds).rotation=s,e.innerBounds.x=Math.min(n[0].x,n[1].x,n[2].x,n[3].x),e.innerBounds.y=Math.min(n[0].y,n[1].y,n[2].y,n[3].y),e.innerBounds.width=Math.max(n[0].x,n[1].x,n[2].x,n[3].x)-e.innerBounds.x,e.innerBounds.height=Math.max(n[0].y,n[1].y,n[2].y,n[3].y)-e.innerBounds.y,e}static calculateGroupOrientedBounds(t,e,i,s=!1){const n=t.length,r=P.allocateArray(4*n);for(let e=0;e<n;e++){const i=t[e];if(!s){const t=i.parent?i.parent:i.enableTempParent();i.updateTransform(),i.disableTempParent(t)}I.calculateTransformedCorners(i,i.worldTransform,r,4*e)}const a=f.identity().rotate(-e);let h=Number.MAX_VALUE,d=Number.MAX_VALUE,l=-Number.MAX_VALUE,p=-Number.MAX_VALUE;for(let t=0,e=r.length;t<e;t++){const e=r[t];a.apply(e,e);const i=e.x,s=e.y;h=i<h?i:h,d=s<d?s:d,l=i>l?i:l,p=s>p?s:p}return P.releaseArray(r),(i=i||new o.OrientedBounds).innerBounds.x=h,i.innerBounds.y=d,i.innerBounds.width=l-h,i.innerBounds.height=p-d,i.rotation=e,a.applyInverse(i.center,_),i.center.copyFrom(_),i}}return t.Transformer=I,t.TransformerHandle=d,t}({},0,PIXI,PIXI,PIXI,PIXI,PIXI);Object.assign(this.PIXI,_pixi_essentials_transformer);
//# sourceMappingURL=transformer.js.map
