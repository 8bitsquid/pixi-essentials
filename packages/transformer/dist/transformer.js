/*!
 * @pixi-essentials/transformer - v2.0.1
 * Compiled Sun, 16 Aug 2020 16:31:07 UTC
 *
 * @pixi-essentials/transformer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal, All Rights Reserved
 */
this.PIXI=this.PIXI||{};var _pixi_essentials_transformer=function(t,e,o,i,n,s,r){"use strict";const a={color:16777215,outlineColor:0,outlineThickness:1,radius:8,shape:"square"},h=new i.Point,p=new i.Point;class l extends n.Graphics{constructor(t={},e,o,n){super();const s=Object.assign({},a,t);this._style=s,this.cursor=n||"move",this.onHandleDelta=e,this.onHandleCommit=o,this.lineStyle(s.outlineThickness,s.outlineColor).beginFill(s.color),"square"===s.shape?this.drawRect(-s.radius/2,-s.radius/2,s.radius,s.radius):this.drawCircle(0,0,s.radius),this.endFill(),this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new i.Point,this.interactive=!0,this.on("mousedown",this.onPointerDown,this),this.on("mousemove",this.onPointerMove,this),this.on("mouseup",this.onPointerUp,this),this.on("mouseupoutside",this.onPointerUp,this)}get style(){return this._style}set style(t){this._style=Object.assign({},a,t)}onPointerDown(t){this._pointerDown=!0,this._pointerDragging=!1,t.stopPropagation()}onPointerMove(t){this._pointerDown&&(this._pointerDragging?this.onDrag(t):this.onDragStart(t),t.stopPropagation())}onPointerUp(t){this._pointerDragging&&this.onDragEnd(t),this._pointerDown=!1}onDragStart(t){t.data.getLocalPosition(this.parent,this._pointerPosition),this._pointerDragging=!0}onDrag(t){const e=this._pointerPosition,o=t.data.getLocalPosition(this.parent,h);this.onHandleDelta&&(p.x=o.x-e.x,p.y=o.y-e.y,this.onHandleDelta(e,p)),this._pointerPosition.copyFrom(h)}onDragEnd(t){this._pointerDragging=!1,this.onHandleCommit&&this.onHandleCommit()}}const d=new i.Matrix;function u(t){const e=d.identity();return e.c=Math.tan(t),e}function c(t){const e=d.identity();return e.b=Math.tan(t),e}function y(t,e,o,i=t.pivot){const n=e.a,s=e.b,r=e.c,a=e.d,h=-Math.atan2(-r,a),p=Math.atan2(s,n);return o=null!=o?o:p,t.pivot.set(i.x,i.y),t.rotation=o,t.skew.x=o+h,t.skew.y=-o+p,t.scale.x=Math.sqrt(n*n+s*s),t.scale.y=Math.sqrt(r*r+a*a),t.position.x=e.tx+(i.x*e.a+i.y*e.c),t.position.y=e.ty+(i.x*e.b+i.y*e.d),t}const w=new i.Matrix,m=new i.Matrix;function g(t,e,o){if(!o){const e=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(e)}const n=t.worldTransform,s=t.parent?m.copyFrom(t.parent.worldTransform):i.Matrix.IDENTITY;w.copyFrom(n),w.prepend(e),w.prepend(s.invert()),y(t.transform,w)}const x=new i.Transform,f=[new i.Point,new i.Point,new i.Point,new i.Point],_=new i.Matrix,P=new i.Point,k=new s.OrientedBounds,T=new i.Rectangle,b=r.ObjectPoolFactory.build(i.Point),B={topLeft:"nw-resize",topCenter:"n-resize",topRight:"ne-resize",middleLeft:"w-resize",middleRight:"e-resize",bottomLeft:"sw-resize",bottomCenter:"s-resize",bottomRight:"se-resize"},L=["topLeft","topCenter","topRight","middleLeft","middleCenter","middleRight","bottomLeft","bottomCenter","bottomRight"],D={topLeft:{x:-1,y:-1},topCenter:{x:0,y:-1},topRight:{x:1,y:-1},middleLeft:{x:-1,y:0},middleCenter:{x:0,y:0},middleRight:{x:1,y:0},bottomLeft:{x:-1,y:1},bottomCenter:{x:0,y:1},bottomRight:{x:1,y:1}},M={color:0,thickness:2};class C extends o.Container{constructor(t={}){super(),this.translateGroup=t=>{const e=_.identity().translate(t.x,t.y);this.prependTransform(e)},this.rotateGroup=(t,e,o)=>{const i=this.groupBounds,n=P.set(e.x+o.x,e.y+o.y),s=i.center,r=Math.atan2(e.y-s.y,e.x-s.x),a=Math.atan2(n.y-s.y,n.x-s.x)-r,h=_.identity().translate(-s.x,-s.y).rotate(a).translate(s.x,s.y);this.prependTransform(h,!0),this.updateGroupBounds(i.rotation+a),this._skewX+=a,this._skewY+=a},this.scaleGroup=(t,e)=>{const o=D[t].x,i=D[t].y,n=this.groupBounds,s=n.rotation,r=n.innerBounds,a=e.x,h=e.y,p=(n.topRight.x-n.topLeft.x)/r.width,l=(n.topRight.y-n.topLeft.y)/r.width,d=a*((n.bottomLeft.x-n.topLeft.x)/r.height)+h*((n.bottomLeft.y-n.topLeft.y)/r.height),u=1+(a*p+h*l)*o/r.width,c=1+d*i/r.height,y=_.identity();if(0!==o){const t=1===o?n.topLeft:n.topRight;y.translate(-t.x,-t.y).rotate(-s).scale(u,1).rotate(s).translate(t.x,t.y)}if(0!==i){const t=1===i?n.topLeft:n.bottomLeft;y.translate(-t.x,-t.y).rotate(-s).scale(1,c).rotate(s).translate(t.x,t.y)}this.prependTransform(y)},this.skewGroup=(t,e,o)=>{const i=this.groupBounds,n=P.set(e.x+o.x,e.y+o.y),s=i.center,r=_.identity().translate(-s.x,-s.y);let a=this.groupBounds.rotation;if("skewHorizontal"===t){const t=this._skewX;this._skewX=Math.atan2(n.y-s.y,n.x-s.x),r.prepend(c(-t)),r.prepend(c(this._skewX))}else{const t=this._skewY,e=Math.atan2(n.y-s.y,n.x-s.x)-Math.PI/2;this._skewY=e,r.prepend(u(t)),r.prepend(u(-this._skewY)),a-=e-t}r.translate(s.x,s.y),this.prependTransform(r,!0),this.updateGroupBounds(a)},this.commitGroup=()=>{!1!==this.transientGroupTilt&&this.group.length>1&&this.updateGroupBounds(0)},this.interactive=!0,this.cursor="move",this.group=t.group||[],this.skewRadius=t.skewRadius||64,this._skewTransform=void 0!==t.skewTransform&&t.skewTransform,this.transientGroupTilt=void 0===t.transientGroupTilt||t.transientGroupTilt,this.wireframe=this.addChild(new n.Graphics),this._skewX=0,this._skewY=0,this._wireframeStyle=Object.assign({},M,t.wireframeStyle||{});const e=t.handleConstructor||l,o=t.handleStyle||{};this._handleStyle=o;const r={rotator:this.addChild(new e(o,(t,e)=>{this.rotateGroup("rotator",t,e)},this.commitGroup))},a=L.reduce((t,i)=>(t[i]=new e(o,(t,e)=>{this.scaleGroup(i,e)},this.commitGroup,B[i]),this.addChild(t[i]),t),{}),h={skewHorizontal:this.addChild(new e(o,(t,e)=>{this.skewGroup("skewHorizontal",t,e)},this.commitGroup,"pointer")),skewVertical:this.addChild(new e(o,(t,e)=>{this.skewGroup("skewVertical",t,e)},this.commitGroup,"pointer"))};this.handles=Object.assign({},r,a,h),this.handles.middleCenter.visible=!1,this.handles.skewHorizontal.visible=this._skewTransform,this.handles.skewVertical.visible=this._skewTransform,this.groupBounds=new s.OrientedBounds,this.updateGroupBounds(),this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new i.Point,this.on("pointerdown",this.onPointerDown,this),this.on("pointermove",this.onPointerMove,this),this.on("pointerup",this.onPointerUp,this),this.on("pointerupoutside",this.onPointerUp,this)}get handleStyle(){return this._handleStyle}set handleStyle(t){const e=this.handles;for(const o in e)e[o].style=t;this._handleStyle=t}get skewTransform(){return this._skewTransform}set skewTransform(t){this._skewTransform!==t&&(this._skewTransform=t,this.handles.skewHorizontal.visible=t,this.handles.skewVertical.visible=t)}get wireframeStyle(){return this._wireframeStyle}set wireframeStyle(t){this._wireframeStyle=Object.assign({},M,t)}render(t){this.draw(),super.render(t)}draw(){const t=this.group,{color:e,thickness:o}=this._wireframeStyle;this.wireframe.clear().lineStyle(o,e);for(let e=0,o=t.length;e<o;e++)this.drawBounds(C.calculateOrientedBounds(t[e],k));const i=1!==t.length?C.calculateGroupOrientedBounds(t,this.groupBounds.rotation,k,!0):C.calculateOrientedBounds(t[0],k);this.drawBounds(i),this.drawHandles(i),this.groupBounds.copyFrom(i)}drawBounds(t){this.wireframe.beginFill(16777215,1e-4).drawPolygon(t.hull).endFill()}drawHandles(t){const e=this.handles,{topLeft:o,topRight:i,bottomLeft:n,bottomRight:s,center:r}=t;e.topLeft.position.copyFrom(o),e.topCenter.position.set((o.x+i.x)/2,(o.y+i.y)/2),e.topRight.position.copyFrom(i),e.middleLeft.position.set((o.x+n.x)/2,(o.y+n.y)/2),e.middleCenter.position.set((o.x+s.x)/2,(o.y+s.y)/2),e.middleRight.position.set((i.x+s.x)/2,(i.y+s.y)/2),e.bottomLeft.position.copyFrom(n),e.bottomCenter.position.set((n.x+s.x)/2,(n.y+s.y)/2),e.bottomRight.position.copyFrom(s),e.skewHorizontal.position.set(r.x+Math.cos(this._skewX)*this.skewRadius,r.y+Math.sin(this._skewX)*this.skewRadius),e.skewVertical.position.set(r.x+-Math.sin(this._skewY)*this.skewRadius,r.y+Math.cos(this._skewY)*this.skewRadius),t.innerBounds.pad(32),e.rotator.position.x=(t.topLeft.x+t.topRight.x)/2,e.rotator.position.y=(t.topLeft.y+t.topRight.y)/2,t.innerBounds.pad(-32);const a=(t.topLeft.x+t.topRight.x)/2,h=(t.topLeft.y+t.topRight.y)/2;this.wireframe.moveTo(a,h).lineTo(e.rotator.position.x,e.rotator.position.y),this._skewTransform&&(this.wireframe.beginFill(this.wireframeStyle.color).drawCircle(r.x,r.y,2*this.wireframeStyle.thickness).endFill(),this.wireframe.moveTo(r.x,r.y).lineTo(e.skewHorizontal.x,e.skewHorizontal.y).moveTo(r.x,r.y).lineTo(e.skewVertical.x,e.skewVertical.y));for(const t in e){let o=this.groupBounds.rotation;"skewHorizontal"===t?o=this._skewX:"skewVertical"===t&&(o=this._skewY);const i=e[t];i.rotation=o,i.getBounds(!1,T)}}onPointerDown(t){this._pointerDown=!0,this._pointerDragging=!1,t.stopPropagation()}onPointerMove(t){if(!this._pointerDown)return;const e=this._pointerPosition,o=t.data.getLocalPosition(this,P),i=o.x,n=o.y;if(this._pointerDragging){const t=o;t.x-=e.x,t.y-=e.y,this.translateGroup(t)}this._pointerPosition.x=i,this._pointerPosition.y=n,this._pointerDragging=!0,t.stopPropagation()}onPointerUp(t){this._pointerDragging=!1,this._pointerDown=!1,t.stopPropagation()}prependTransform(t,e=!1){const o=this.group;for(let e=0,i=o.length;e<i;e++)g(o[e],t,!1);e||this.updateGroupBounds()}updateGroupBounds(t=this.groupBounds.rotation){C.calculateGroupOrientedBounds(this.group,t,this.groupBounds)}static calculateTransformedCorners(t,e=t.worldTransform,o,n=0){const s=t.getLocalBounds();return t.getBounds(),(o=o||[new i.Point,new i.Point,new i.Point,new i.Point])[n].set(s.x,s.y),o[n+1].set(s.x+s.width,s.y),o[n+2].set(s.x+s.width,s.y+s.height),o[n+3].set(s.x,s.y+s.height),e.apply(o[n],o[n]),e.apply(o[n+1],o[n+1]),e.apply(o[n+2],o[n+2]),e.apply(o[n+3],o[n+3]),o}static calculateOrientedBounds(t,e){const o=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(o),y(x,t.worldTransform),x.updateLocalTransform();const i=x.rotation,n=C.calculateTransformedCorners(t,t.worldTransform,f),r=(n[0].x+n[1].x+n[2].x+n[3].x)/4,a=(n[0].y+n[1].y+n[2].y+n[3].y)/4,h=_.identity().translate(-r,-a).rotate(-x.rotation).translate(r,a);return h.apply(n[0],n[0]),h.apply(n[1],n[1]),h.apply(n[2],n[2]),h.apply(n[3],n[3]),(e=e||new s.OrientedBounds).rotation=i,e.innerBounds.x=Math.min(n[0].x,n[1].x,n[2].x,n[3].x),e.innerBounds.y=Math.min(n[0].y,n[1].y,n[2].y,n[3].y),e.innerBounds.width=Math.max(n[0].x,n[1].x,n[2].x,n[3].x)-e.innerBounds.x,e.innerBounds.height=Math.max(n[0].y,n[1].y,n[2].y,n[3].y)-e.innerBounds.y,e}static calculateGroupOrientedBounds(t,e,o,i=!1){const n=t.length,r=b.allocateArray(4*n);for(let e=0;e<n;e++){const o=t[e];if(!i){const t=o.parent?o.parent:o.enableTempParent();o.updateTransform(),o.disableTempParent(t)}C.calculateTransformedCorners(o,o.worldTransform,r,4*e)}const a=_.identity().rotate(-e);let h=Number.MAX_VALUE,p=Number.MAX_VALUE,l=-Number.MAX_VALUE,d=-Number.MAX_VALUE;for(let t=0,e=r.length;t<e;t++){const e=r[t];a.apply(e,e);const o=e.x,i=e.y;h=o<h?o:h,p=i<p?i:p,l=o>l?o:l,d=i>d?i:d}return b.releaseArray(r),(o=o||new s.OrientedBounds).innerBounds.x=h,o.innerBounds.y=p,o.innerBounds.width=l-h,o.innerBounds.height=d-p,o.rotation=e,a.applyInverse(o.center,P),o.center.copyFrom(P),o}}return t.Transformer=C,t.TransformerHandle=l,t}({},0,PIXI,PIXI,PIXI,PIXI,PIXI);Object.assign(this.PIXI,_pixi_essentials_transformer);
//# sourceMappingURL=transformer.js.map
