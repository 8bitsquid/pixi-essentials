/*!
 * @pixi-essentials/transformer - v1.0.0
 * Compiled Sat, 15 Aug 2020 19:41:52 UTC
 *
 * @pixi-essentials/transformer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal, All Rights Reserved
 */
this.PIXI=this.PIXI||{};var _pixi_essentials_transformer=function(t,o,e,n,i,r,s){"use strict";const a=new n.Point,p=new n.Point;class d extends i.Graphics{constructor(t={},o,e){super();const i=Object.assign({color:16777215,outlineColor:0,outlineThickness:1,radius:8,shape:"square"},t);this.style=i,this.cursor=e||"move",this.onHandleDelta=o,this.lineStyle(i.outlineThickness,i.outlineColor).beginFill(i.color),"square"===i.shape?this.drawRect(-i.radius/2,-i.radius/2,i.radius,i.radius):this.drawCircle(0,0,i.radius),this.endFill(),this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new n.Point,this.interactive=!0,this.on("mousedown",()=>{console.log("MD")}),this.on("mousedown",this.onPointerDown,this),this.on("mousemove",this.onPointerMove,this),this.on("mouseup",this.onPointerUp,this),this.on("mouseupoutside",this.onPointerUp,this)}onPointerDown(){this._pointerDown=!0,this._pointerDragging=!1}onPointerMove(t){this._pointerDown&&(this._pointerDragging?this.onDrag(t):this.onDragStart(t))}onPointerUp(t){this._pointerDragging&&this.onDragEnd(t),this._pointerDown=!1}onDragStart(t){t.data.getLocalPosition(this.parent,this._pointerPosition),this._pointerDragging=!0}onDrag(t){const o=this._pointerPosition,e=t.data.getLocalPosition(this.parent,a);this.onHandleDelta&&(p.x=e.x-o.x,p.y=e.y-o.y,this.onHandleDelta(o,p)),this._pointerPosition.copyFrom(a)}onDragEnd(t){this._pointerDragging=!1}}function h(t,o,e,n=t.pivot){const i=o.a,r=o.b,s=o.c,a=o.d,p=-Math.atan2(-s,a),d=Math.atan2(r,i);return e=null!=e?e:d,t.pivot.set(n.x,n.y),t.rotation=e,t.skew.x=e+p,t.skew.y=-e+d,t.scale.x=Math.sqrt(i*i+r*r),t.scale.y=Math.sqrt(s*s+a*a),t.position.x=o.tx+(n.x*o.a+n.y*o.c),t.position.y=o.ty+(n.x*o.b+n.y*o.d),t}const l=new n.Matrix,u=new n.Matrix;function c(t,o,e){if(!e){const o=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(o)}const i=t.worldTransform,r=t.parent?u.copyFrom(t.parent.worldTransform):n.Matrix.IDENTITY;l.copyFrom(i),l.prepend(o),l.prepend(r.invert()),h(t.transform,l)}const y=new n.Transform,m=[new n.Point,new n.Point,new n.Point,new n.Point],x=new n.Matrix,g=new n.Point,f=new r.OrientedBounds,w=new n.Rectangle,P=s.ObjectPoolFactory.build(n.Point),b={topLeft:"nw-resize",topCenter:"n-resize",topRight:"ne-resize",middleLeft:"w-resize",middleRight:"e-resize",bottomLeft:"sw-resize",bottomCenter:"s-resize",bottomRight:"se-resize"},B=["topLeft","topCenter","topRight","middleLeft","middleCenter","middleRight","bottomLeft","bottomCenter","bottomRight"],L={topLeft:{x:-1,y:-1},topCenter:{x:0,y:-1},topRight:{x:1,y:-1},middleLeft:{x:-1,y:0},middleCenter:{x:0,y:0},middleRight:{x:1,y:0},bottomLeft:{x:-1,y:1},bottomCenter:{x:0,y:1},bottomRight:{x:1,y:1}};class T extends e.Container{constructor(t={}){super(),this.rotateGroup=(t,o,e)=>{const n=this.groupBounds,i=g.set(o.x+e.x,o.y+e.y),r=n.center,s=Math.atan2(o.y-r.y,o.x-r.x),a=Math.atan2(i.y-r.y,i.x-r.x)-s,p=x.identity().translate(-r.x,-r.y).rotate(a).translate(r.x,r.y);this.prependTransform(p,!0),this.updateGroupBounds(n.rotation+a)},this.scaleGroup=(t,o)=>{const e=L[t].x,n=L[t].y,i=this.groupBounds,r=i.rotation,s=i.innerBounds,a=o.x,p=o.y,d=(i.topRight.x-i.topLeft.x)/s.width,h=(i.topRight.y-i.topLeft.y)/s.width,l=a*((i.bottomLeft.x-i.topLeft.x)/s.height)+p*((i.bottomLeft.y-i.topLeft.y)/s.height),u=1+(a*d+p*h)*e/s.width,c=1+l*n/s.height,y=x.identity();if(0!==e){const t=1===e?i.topLeft:i.topRight;y.translate(-t.x,-t.y).rotate(-r).scale(u,1).rotate(r).translate(t.x,t.y)}if(0!==n){const t=1===n?i.topLeft:i.bottomLeft;y.translate(-t.x,-t.y).rotate(-r).scale(1,c).rotate(r).translate(t.x,t.y)}this.prependTransform(y)},this.group=t.group||[],this.interactive=!0,this.cursor="move",this.wireframe=this.addChild(new i.Graphics),this.wireframeStyle=Object.assign({color:0,thickness:2},t.wireframeStyle||{});const o=t.handleConstructor||d,e=t.handleStyle||{};this.handleStyle=e;const n={rotator:this.addChild(new o(e,(t,o)=>{this.rotateGroup("rotator",t,o)}))},s=B.reduce((t,n)=>(t[n]=new o(e,(t,o)=>{this.scaleGroup(n,o)},b[n]),this.addChild(t[n]),t),{});this.handles=Object.assign({},n,s),this.handles.middleCenter.visible=!1,this.groupBounds=new r.OrientedBounds,this.updateGroupBounds()}render(t){const o=this.group,{color:e,thickness:n}=this.wireframeStyle;this.wireframe.clear().lineStyle(n,e);for(let t=0,e=o.length;t<e;t++)this.drawBounds(T.calculateOrientedBounds(o[t],f));const i=T.calculateGroupOrientedBounds(o,this.groupBounds.rotation,f,!0);this.drawBounds(i),this.drawHandles(i),this.groupBounds.copyFrom(i),super.render(t)}drawBounds(t){this.wireframe.drawPolygon(t.hull)}drawHandles(t){const o=this.handles,{topLeft:e,topRight:n,bottomLeft:i,bottomRight:r}=t;o.topLeft.position.copyFrom(e),o.topCenter.position.set((e.x+n.x)/2,(e.y+n.y)/2),o.topRight.position.copyFrom(n),o.middleLeft.position.set((e.x+i.x)/2,(e.y+i.y)/2),o.middleCenter.position.set((e.x+r.x)/2,(e.y+r.y)/2),o.middleRight.position.set((n.x+r.x)/2,(n.y+r.y)/2),o.bottomLeft.position.copyFrom(i),o.bottomCenter.position.set((i.x+r.x)/2,(i.y+r.y)/2),o.bottomRight.position.copyFrom(r),t.innerBounds.pad(32),o.rotator.position.x=(t.topLeft.x+t.topRight.x)/2,o.rotator.position.y=(t.topLeft.y+t.topRight.y)/2,t.innerBounds.pad(-32);const s=(t.topLeft.x+t.topRight.x)/2,a=(t.topLeft.y+t.topRight.y)/2;this.wireframe.moveTo(s,a).lineTo(o.rotator.position.x,o.rotator.position.y);for(const e in o){const n=o[e];n.rotation=t.rotation,n.getBounds(!1,w)}}prependTransform(t,o=!1){const e=this.group;for(let o=0,n=e.length;o<n;o++)c(e[o],t,!1);o||this.updateGroupBounds()}updateGroupBounds(t=this.groupBounds.rotation){T.calculateGroupOrientedBounds(this.group,t,this.groupBounds)}static calculateTransformedCorners(t,o=t.worldTransform,e,i=0){const r=t.getLocalBounds();return t.getBounds(),(e=e||[new n.Point,new n.Point,new n.Point,new n.Point])[i].set(r.x,r.y),e[i+1].set(r.x+r.width,r.y),e[i+2].set(r.x+r.width,r.y+r.height),e[i+3].set(r.x,r.y+r.height),o.apply(e[i],e[i]),o.apply(e[i+1],e[i+1]),o.apply(e[i+2],e[i+2]),o.apply(e[i+3],e[i+3]),e}static calculateOrientedBounds(t,o){const e=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(e),h(y,t.worldTransform),y.updateLocalTransform();const n=y.rotation,i=T.calculateTransformedCorners(t,t.worldTransform,m),s=(i[0].x+i[1].x+i[2].x+i[3].x)/4,a=(i[0].y+i[1].y+i[2].y+i[3].y)/4,p=x.identity().translate(-s,-a).rotate(-y.rotation).translate(s,a);return p.apply(i[0],i[0]),p.apply(i[1],i[1]),p.apply(i[2],i[2]),p.apply(i[3],i[3]),(o=o||new r.OrientedBounds).rotation=n,o.innerBounds.x=Math.min(i[0].x,i[1].x,i[2].x,i[3].x),o.innerBounds.y=Math.min(i[0].y,i[1].y,i[2].y,i[3].y),o.innerBounds.width=Math.max(i[0].x,i[1].x,i[2].x,i[3].x)-o.innerBounds.x,o.innerBounds.height=Math.max(i[0].y,i[1].y,i[2].y,i[3].y)-o.innerBounds.y,o}static calculateGroupOrientedBounds(t,o,e,n=!1){const i=t.length,s=P.allocateArray(4*i);for(let o=0;o<i;o++){const e=t[o];if(!n){const t=e.parent?e.parent:e.enableTempParent();e.updateTransform(),e.disableTempParent(t)}T.calculateTransformedCorners(e,e.worldTransform,s,4*o)}const a=x.identity().rotate(-o);let p=Number.MAX_VALUE,d=Number.MAX_VALUE,h=-Number.MAX_VALUE,l=-Number.MAX_VALUE;for(let t=0,o=s.length;t<o;t++){const o=s[t];a.apply(o,o);const e=o.x,n=o.y;p=e<p?e:p,d=n<d?n:d,h=e>h?e:h,l=n>l?n:l}return P.releaseArray(s),(e=e||new r.OrientedBounds).innerBounds.x=p,e.innerBounds.y=d,e.innerBounds.width=h-p,e.innerBounds.height=l-d,e.rotation=o,a.applyInverse(e.center,g),e.center.copyFrom(g),e}}return t.Transformer=T,t.TransformerHandle=d,t}({},0,PIXI,PIXI,PIXI,bounds,objectPool);Object.assign(this.PIXI,_pixi_essentials_transformer);
//# sourceMappingURL=transformer.js.map
