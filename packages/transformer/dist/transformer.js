/*!
 * @pixi-essentials/transformer - v2.0.0
 * Compiled Sat, 15 Aug 2020 21:31:08 UTC
 *
 * @pixi-essentials/transformer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal, All Rights Reserved
 */
this.PIXI=this.PIXI||{};var _pixi_essentials_transformer=function(t,e,o,n,i,r,s){"use strict";const a={color:16777215,outlineColor:0,outlineThickness:1,radius:8,shape:"square"},h=new n.Point,d=new n.Point;class p extends i.Graphics{constructor(t={},e,o){super();const i=Object.assign({},a,t);this._style=i,this.cursor=o||"move",this.onHandleDelta=e,this.lineStyle(i.outlineThickness,i.outlineColor).beginFill(i.color),"square"===i.shape?this.drawRect(-i.radius/2,-i.radius/2,i.radius,i.radius):this.drawCircle(0,0,i.radius),this.endFill(),this._pointerDown=!1,this._pointerDragging=!1,this._pointerPosition=new n.Point,this.interactive=!0,this.on("mousedown",this.onPointerDown,this),this.on("mousemove",this.onPointerMove,this),this.on("mouseup",this.onPointerUp,this),this.on("mouseupoutside",this.onPointerUp,this)}get style(){return this._style}set style(t){this._style=Object.assign({},a,t)}onPointerDown(){this._pointerDown=!0,this._pointerDragging=!1}onPointerMove(t){this._pointerDown&&(this._pointerDragging?this.onDrag(t):this.onDragStart(t))}onPointerUp(t){this._pointerDragging&&this.onDragEnd(t),this._pointerDown=!1}onDragStart(t){t.data.getLocalPosition(this.parent,this._pointerPosition),this._pointerDragging=!0}onDrag(t){const e=this._pointerPosition,o=t.data.getLocalPosition(this.parent,h);this.onHandleDelta&&(d.x=o.x-e.x,d.y=o.y-e.y,this.onHandleDelta(e,d)),this._pointerPosition.copyFrom(h)}onDragEnd(t){this._pointerDragging=!1}}function l(t,e,o,n=t.pivot){const i=e.a,r=e.b,s=e.c,a=e.d,h=-Math.atan2(-s,a),d=Math.atan2(r,i);return o=null!=o?o:d,t.pivot.set(n.x,n.y),t.rotation=o,t.skew.x=o+h,t.skew.y=-o+d,t.scale.x=Math.sqrt(i*i+r*r),t.scale.y=Math.sqrt(s*s+a*a),t.position.x=e.tx+(n.x*e.a+n.y*e.c),t.position.y=e.ty+(n.x*e.b+n.y*e.d),t}const u=new n.Matrix,y=new n.Matrix;function c(t,e,o){if(!o){const e=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(e)}const i=t.worldTransform,r=t.parent?y.copyFrom(t.parent.worldTransform):n.Matrix.IDENTITY;u.copyFrom(i),u.prepend(e),u.prepend(r.invert()),l(t.transform,u)}const m=new n.Transform,g=[new n.Point,new n.Point,new n.Point,new n.Point],x=new n.Matrix,f=new n.Point,w=new r.OrientedBounds,P=new n.Rectangle,b=s.ObjectPoolFactory.build(n.Point),B={topLeft:"nw-resize",topCenter:"n-resize",topRight:"ne-resize",middleLeft:"w-resize",middleRight:"e-resize",bottomLeft:"sw-resize",bottomCenter:"s-resize",bottomRight:"se-resize"},L=["topLeft","topCenter","topRight","middleLeft","middleCenter","middleRight","bottomLeft","bottomCenter","bottomRight"],_={topLeft:{x:-1,y:-1},topCenter:{x:0,y:-1},topRight:{x:1,y:-1},middleLeft:{x:-1,y:0},middleCenter:{x:0,y:0},middleRight:{x:1,y:0},bottomLeft:{x:-1,y:1},bottomCenter:{x:0,y:1},bottomRight:{x:1,y:1}},T={color:0,thickness:2};class C extends o.Container{constructor(t={}){super(),this.rotateGroup=(t,e,o)=>{const n=this.groupBounds,i=f.set(e.x+o.x,e.y+o.y),r=n.center,s=Math.atan2(e.y-r.y,e.x-r.x),a=Math.atan2(i.y-r.y,i.x-r.x)-s,h=x.identity().translate(-r.x,-r.y).rotate(a).translate(r.x,r.y);this.prependTransform(h,!0),this.updateGroupBounds(n.rotation+a)},this.scaleGroup=(t,e)=>{const o=_[t].x,n=_[t].y,i=this.groupBounds,r=i.rotation,s=i.innerBounds,a=e.x,h=e.y,d=(i.topRight.x-i.topLeft.x)/s.width,p=(i.topRight.y-i.topLeft.y)/s.width,l=a*((i.bottomLeft.x-i.topLeft.x)/s.height)+h*((i.bottomLeft.y-i.topLeft.y)/s.height),u=1+(a*d+h*p)*o/s.width,y=1+l*n/s.height,c=x.identity();if(0!==o){const t=1===o?i.topLeft:i.topRight;c.translate(-t.x,-t.y).rotate(-r).scale(u,1).rotate(r).translate(t.x,t.y)}if(0!==n){const t=1===n?i.topLeft:i.bottomLeft;c.translate(-t.x,-t.y).rotate(-r).scale(1,y).rotate(r).translate(t.x,t.y)}this.prependTransform(c)},this.group=t.group||[],this.interactive=!0,this.cursor="move",this.wireframe=this.addChild(new i.Graphics),this._wireframeStyle=Object.assign({},T,t.wireframeStyle||{});const e=t.handleConstructor||p,o=t.handleStyle||{};this._handleStyle=o;const n={rotator:this.addChild(new e(o,(t,e)=>{this.rotateGroup("rotator",t,e)}))},s=L.reduce((t,n)=>(t[n]=new e(o,(t,e)=>{this.scaleGroup(n,e)},B[n]),this.addChild(t[n]),t),{});this.handles=Object.assign({},n,s),this.handles.middleCenter.visible=!1,this.groupBounds=new r.OrientedBounds,this.updateGroupBounds()}get handleStyle(){return this._handleStyle}set handleStyle(t){const e=this.handles;for(const o in e)e[o].style=t}get wireframeStyle(){return this._wireframeStyle}set wireframeStyle(t){this._wireframeStyle=Object.assign({},T,t)}render(t){const e=this.group,{color:o,thickness:n}=this._wireframeStyle;this.wireframe.clear().lineStyle(n,o);for(let t=0,o=e.length;t<o;t++)this.drawBounds(C.calculateOrientedBounds(e[t],w));const i=C.calculateGroupOrientedBounds(e,this.groupBounds.rotation,w,!0);this.drawBounds(i),this.drawHandles(i),this.groupBounds.copyFrom(i),super.render(t)}drawBounds(t){this.wireframe.drawPolygon(t.hull)}drawHandles(t){const e=this.handles,{topLeft:o,topRight:n,bottomLeft:i,bottomRight:r}=t;e.topLeft.position.copyFrom(o),e.topCenter.position.set((o.x+n.x)/2,(o.y+n.y)/2),e.topRight.position.copyFrom(n),e.middleLeft.position.set((o.x+i.x)/2,(o.y+i.y)/2),e.middleCenter.position.set((o.x+r.x)/2,(o.y+r.y)/2),e.middleRight.position.set((n.x+r.x)/2,(n.y+r.y)/2),e.bottomLeft.position.copyFrom(i),e.bottomCenter.position.set((i.x+r.x)/2,(i.y+r.y)/2),e.bottomRight.position.copyFrom(r),t.innerBounds.pad(32),e.rotator.position.x=(t.topLeft.x+t.topRight.x)/2,e.rotator.position.y=(t.topLeft.y+t.topRight.y)/2,t.innerBounds.pad(-32);const s=(t.topLeft.x+t.topRight.x)/2,a=(t.topLeft.y+t.topRight.y)/2;this.wireframe.moveTo(s,a).lineTo(e.rotator.position.x,e.rotator.position.y);for(const o in e){const n=e[o];n.rotation=t.rotation,n.getBounds(!1,P)}}prependTransform(t,e=!1){const o=this.group;for(let e=0,n=o.length;e<n;e++)c(o[e],t,!1);e||this.updateGroupBounds()}updateGroupBounds(t=this.groupBounds.rotation){C.calculateGroupOrientedBounds(this.group,t,this.groupBounds)}static calculateTransformedCorners(t,e=t.worldTransform,o,i=0){const r=t.getLocalBounds();return t.getBounds(),(o=o||[new n.Point,new n.Point,new n.Point,new n.Point])[i].set(r.x,r.y),o[i+1].set(r.x+r.width,r.y),o[i+2].set(r.x+r.width,r.y+r.height),o[i+3].set(r.x,r.y+r.height),e.apply(o[i],o[i]),e.apply(o[i+1],o[i+1]),e.apply(o[i+2],o[i+2]),e.apply(o[i+3],o[i+3]),o}static calculateOrientedBounds(t,e){const o=t.parent?t.parent:t.enableTempParent();t.updateTransform(),t.disableTempParent(o),l(m,t.worldTransform),m.updateLocalTransform();const n=m.rotation,i=C.calculateTransformedCorners(t,t.worldTransform,g),s=(i[0].x+i[1].x+i[2].x+i[3].x)/4,a=(i[0].y+i[1].y+i[2].y+i[3].y)/4,h=x.identity().translate(-s,-a).rotate(-m.rotation).translate(s,a);return h.apply(i[0],i[0]),h.apply(i[1],i[1]),h.apply(i[2],i[2]),h.apply(i[3],i[3]),(e=e||new r.OrientedBounds).rotation=n,e.innerBounds.x=Math.min(i[0].x,i[1].x,i[2].x,i[3].x),e.innerBounds.y=Math.min(i[0].y,i[1].y,i[2].y,i[3].y),e.innerBounds.width=Math.max(i[0].x,i[1].x,i[2].x,i[3].x)-e.innerBounds.x,e.innerBounds.height=Math.max(i[0].y,i[1].y,i[2].y,i[3].y)-e.innerBounds.y,e}static calculateGroupOrientedBounds(t,e,o,n=!1){const i=t.length,s=b.allocateArray(4*i);for(let e=0;e<i;e++){const o=t[e];if(!n){const t=o.parent?o.parent:o.enableTempParent();o.updateTransform(),o.disableTempParent(t)}C.calculateTransformedCorners(o,o.worldTransform,s,4*e)}const a=x.identity().rotate(-e);let h=Number.MAX_VALUE,d=Number.MAX_VALUE,p=-Number.MAX_VALUE,l=-Number.MAX_VALUE;for(let t=0,e=s.length;t<e;t++){const e=s[t];a.apply(e,e);const o=e.x,n=e.y;h=o<h?o:h,d=n<d?n:d,p=o>p?o:p,l=n>l?n:l}return b.releaseArray(s),(o=o||new r.OrientedBounds).innerBounds.x=h,o.innerBounds.y=d,o.innerBounds.width=p-h,o.innerBounds.height=l-d,o.rotation=e,a.applyInverse(o.center,f),o.center.copyFrom(f),o}}return t.Transformer=C,t.TransformerHandle=p,t}({},0,PIXI,PIXI,PIXI,PIXI,PIXI);Object.assign(this.PIXI,_pixi_essentials_transformer);
//# sourceMappingURL=transformer.js.map
