{"version":3,"file":"cull.js","sources":["../src/Cull.ts"],"sourcesContent":["import type { DisplayObject } from 'pixi.js';\nimport { Rectangle } from 'pixi.js';\n\nconst tempRect = new Rectangle();\n\ninterface ICullOptions\n{\n    toggle: 'visible' | 'renderable';\n}\n\n/**\n * WIP: Better culling than pixi-cull\n */\nexport class Cull\n{\n    private _toggle: 'visible' | 'renderable';\n\n    private _targetList: Set<DisplayObject>;\n\n    constructor(options: Partial<ICullOptions> = {})\n    {\n        this._toggle = options.toggle || 'visible';\n        this._targetList = new Set<DisplayObject>();\n    }\n\n    add(target: DisplayObject): void\n    {\n        this._targetList.add(target);\n    }\n\n    addAll(targets: DisplayObject[]): void\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.add(targets[i]);\n        }\n    }\n\n    remove(target: DisplayObject): void\n    {\n        this._targetList.delete(target);\n    }\n\n    removeAll(targets: DisplayObject[]): void\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.delete(targets[i]);\n        }\n    }\n\n    clear(): void\n    {\n        this._targetList.clear();\n    }\n\n    /**\n     * @param rect - the rectangle outside of which display-objects should be culled\n     * @param skipUpdate - whether to skip transform update\n     */\n    cull(rect: Rectangle, skipUpdate = false): void\n    {\n        this._targetList.forEach((target) =>\n        {\n            if (!skipUpdate)\n            {\n                const parent = target.parent;\n\n                // TODO: pixi.js 5.3.0 use enableTempParent()\n                if (!target.parent)\n                {\n                    target.parent = target._tempDisplayObjectParent;\n                }\n\n                target.updateTransform();\n                target.parent = parent;\n            }\n\n            this.cullRecursive(rect, target);\n        });\n    }\n\n    protected cullRecursive(rect: Rectangle, displayObject: DisplayObject): void\n    {\n        // NOTE: getBounds can skipUpdate because updateTransform is invoked before culling.\n        const bounds = displayObject.getBounds(true, tempRect);\n\n        displayObject[this._toggle] = bounds.right > rect.left\n            && bounds.left < rect.right\n            && bounds.bottom > rect.top\n            && bounds.top < rect.bottom;\n\n        // Only cull children if this display-object is visible. It is expected that the bounds\n        // of children lie inside of its own.\n        if (displayObject[this._toggle])\n        {\n            this.cullRecursive(rect, displayObject);\n        }\n    }\n}\n"],"names":["tempRect","options","this","_toggle","toggle","_targetList","Set","Cull","target","add","targets","i","j","length","delete","clear","rect","skipUpdate","forEach","parent","_tempDisplayObjectParent","updateTransform","_this","cullRecursive","displayObject","bounds","getBounds","right","left","bottom","top"],"mappings":";;;;;;;6EAGA,IAAMA,EAAW,gCAgBb,WAAYC,gBAAAA,MAERC,KAAKC,QAAUF,EAAQG,QAAU,UACjCF,KAAKG,YAAc,IAAIC,IA6E/B,OA1EIC,gBAAA,SAAIC,GAEAN,KAAKG,YAAYI,IAAID,IAGzBD,mBAAA,SAAOG,GAEH,IAAK,IAAIC,EAAI,EAAGC,EAAIF,EAAQG,OAAQF,EAAIC,EAAGD,IAEvCT,KAAKG,YAAYI,IAAIC,EAAQC,KAIrCJ,mBAAA,SAAOC,GAEHN,KAAKG,YAAYS,OAAON,IAG5BD,sBAAA,SAAUG,GAEN,IAAK,IAAIC,EAAI,EAAGC,EAAIF,EAAQG,OAAQF,EAAIC,EAAGD,IAEvCT,KAAKG,YAAYS,OAAOJ,EAAQC,KAIxCJ,kBAAA,WAEIL,KAAKG,YAAYU,SAOrBR,iBAAA,SAAKS,EAAiBC,GAAtB,wBAAsBA,MAElBf,KAAKG,YAAYa,SAAQ,SAACV,GAEtB,IAAKS,EACL,CACI,IAAME,EAASX,EAAOW,OAGjBX,EAAOW,SAERX,EAAOW,OAASX,EAAOY,0BAG3BZ,EAAOa,kBACPb,EAAOW,OAASA,EAGpBG,EAAKC,cAAcP,EAAMR,OAIvBD,0BAAV,SAAwBS,EAAiBQ,GAGrC,IAAMC,EAASD,EAAcE,WAAU,EAAM1B,GAE7CwB,EAActB,KAAKC,SAAWsB,EAAOE,MAAQX,EAAKY,MAC3CH,EAAOG,KAAOZ,EAAKW,OACnBF,EAAOI,OAASb,EAAKc,KACrBL,EAAOK,IAAMd,EAAKa,OAIrBL,EAActB,KAAKC,UAEnBD,KAAKqB,cAAcP,EAAMQ"}