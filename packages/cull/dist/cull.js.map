{"version":3,"file":"cull.js","sources":["../src/Cull.ts"],"sourcesContent":["import { DisplayObject, Container, Rectangle } from 'pixi.js';\n\nconst tempRect = new Rectangle();\n\n/**\n * The culling options for {@code Cull}\n *\n * @public\n */\nexport interface ICullOptions\n{\n    recursive: boolean;\n    toggle: 'visible' | 'renderable';\n}\n\n/**\n * Provides a simple, configurable mechanism for culling a subtree of your scene graph.\n *\n * If your scene graph is not static, culling needs to be done before rendering. You\n * can run it on the `prerender` event fired by the renderer.\n *\n * @public\n */\nexport class Cull\n{\n    private _recursive: boolean;\n    private _toggle: 'visible' | 'renderable';\n    private _targetList: Set<DisplayObject>;\n\n    /**\n     * @param options\n     * @param [options.recursive] - whether culling should be recursive\n     * @param [options.toggle='renderable'] - which property of display-object was be set to indicate\n     *      its culling state. It should be one of `renderable`, `visible`.\n     */\n    constructor(options: Partial<ICullOptions> = {})\n    {\n        this._recursive = typeof options.recursive === 'boolean' ? options.recursive : true;\n        this._toggle = options.toggle || 'visible';\n        this._targetList = new Set<DisplayObject>();\n    }\n\n    /**\n     * Adds a display-object to the culling list\n     *\n     * @param target - the display-object to be culled\n     * @return this\n     */\n    add(target: DisplayObject): this\n    {\n        this._targetList.add(target);\n\n        return this;\n    }\n\n    /**\n     * Adds all the display-objects to the culling list\n     *\n     * @param targets - the display-objects to be culled\n     * @return this\n     */\n    addAll(targets: DisplayObject[]): this\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.add(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the culling list\n     *\n     * @param target - the display-object to be removed\n     * @return this\n     */\n    remove(target: DisplayObject): this\n    {\n        this._targetList.delete(target);\n\n        return this;\n    }\n\n    /**\n     * Removes all the passed display-objects from the culling list\n     *\n     * @param targets - the display-objects to be removed\n     * @return this\n     */\n    removeAll(targets: DisplayObject[]): this\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.delete(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the culling list\n     *\n     * @return this\n     */\n    clear(): this\n    {\n        this._targetList.clear();\n\n        return this;\n    }\n\n    /**\n     * @param rect - the rectangle outside of which display-objects should be culled\n     * @param skipUpdate - whether to skip transform update\n     * @return this\n     */\n    cull(rect: Rectangle, skipUpdate = false): this\n    {\n        this.uncull();\n\n        this._targetList.forEach((target) =>\n        {\n            if (!skipUpdate)\n            {\n                // Update the transforms of display-objects in this target's subtree\n                target.getBounds(false, tempRect);\n            }\n\n            if (this._recursive)\n            {\n                this.cullRecursive(rect, target);\n            }\n            else\n            {\n                // NOTE: If skip-update is false, then tempRect already contains the bounds of the target\n                if (skipUpdate)\n                {\n                    target.getBounds(true, tempRect);\n                }\n\n                target[this._toggle] = tempRect.right > rect.left\n                    && tempRect.left < rect.right\n                    && tempRect.bottom > rect.top\n                    && tempRect.top < rect.bottom;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets all display-objects to the unculled state.\n     *\n     * @return this\n     */\n    uncull(): this\n    {\n        this._targetList.forEach((target) =>\n        {\n            if (this._recursive)\n            {\n                this.uncullRecursive(target);\n            }\n            else\n            {\n                target[this._toggle] = false;\n            }\n        });\n\n        return this;\n    }\n\n    protected cullRecursive(rect: Rectangle, displayObject: DisplayObject): void\n    {\n        // NOTE: getBounds can skipUpdate because updateTransform is invoked before culling.\n        const bounds = displayObject.getBounds(true, tempRect);\n\n        displayObject[this._toggle] = bounds.right > rect.left\n            && bounds.left < rect.right\n            && bounds.bottom > rect.top\n            && bounds.top < rect.bottom;\n\n        const fullyVisible = bounds.left >= rect.left\n            && bounds.top >= rect.top\n            && bounds.right <= rect.right\n            && bounds.bottom >= rect.bottom;\n\n        // Only cull children if this display-object is fully-visible. It is expected that the bounds\n        // of children lie inside of its own. Hence, further culling is only required if the display-object\n        // intersects with the boundaries of \"rect\".\n        if (!fullyVisible\n                && (displayObject as Container).children\n                && (displayObject as Container).children.length)\n        {\n            const children = (displayObject as Container).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.cullRecursive(rect, children[i]);\n            }\n        }\n    }\n\n    protected uncullRecursive(displayObject: DisplayObject): void\n    {\n        displayObject[this._toggle] = true;\n\n        if ((displayObject as Container).children && (displayObject as Container).children.length)\n        {\n            const children = (displayObject as Container).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.uncullRecursive(children[i]);\n            }\n        }\n    }\n}\n"],"names":["Rectangle"],"mappings":"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"}