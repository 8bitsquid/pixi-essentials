{"version":3,"file":"shader-preprocessor.js","sources":["../src/ProgramTemplate.ts","../src/ShaderPreprocessor.ts"],"sourcesContent":["import { Program } from '@pixi/core';\n\ntype TemplateData = Array<{\n    id: string;\n    args: string[];\n    position: { start: number; end: number };\n    type: 'field' | 'function';\n}>;\n\nexport type MacroData = {\n    [id: string]: string | ((...args: string[]) => string);\n};\n\nconst MACRO_PATTERN = /%([\\w$]+)(\\([\\w$, ]*\\))?%/g;\n\n/**\n * Helper class to create and manage a program template.\n *\n * @public\n */\nexport class ProgramTemplate\n{\n    public vertexTemplateSrc: string;\n    public fragmentTemplateSrc: string;\n    public name: string;\n\n    protected programCache: Map<string, Program>;\n    protected vertexMacroData: TemplateData;\n    protected fragmentMacroData: TemplateData;\n\n    /**\n     * @param vertexTemplateSrc - vertex shader template\n     * @param fragmentTemplateSrc - fragment shader template\n     * @param name - name of the shader template. This is used to generate the names for generated programs.\n     */\n    constructor(vertexTemplateSrc?: string, fragmentTemplateSrc?: string, name = 'pixi-shader-template')\n    {\n        /**\n         * The vertex shader template\n         */\n        this.vertexTemplateSrc = vertexTemplateSrc || Program.defaultVertexSrc;\n\n        /**\n         * The fragment shader template\n         */\n        this.fragmentTemplateSrc = fragmentTemplateSrc || Program.defaultFragmentSrc;\n\n        /**\n         * The name for generated programs\n         */\n        this.name = name;\n\n        /**\n         * The cache of generated programs for each passed macro value.\n         */\n        this.programCache = new Map<string, Program>();\n\n        /**\n         * The macros used in the vertex shader\n         */\n        this.vertexMacroData = this.extractData(this.vertexTemplateSrc);\n\n        /**\n         * The macros used in the fragment shader\n         */\n        this.fragmentMacroData = this.extractData(this.fragmentTemplateSrc);\n    }\n\n    /**\n     * Generates a shader program from this template and passed macro-data.\n     *\n     * @param data - data providing the values of the macros in the shader template\n     * @param name - optional name, if another name is desired\n     * @return the generated shader program\n     */\n    generateProgram(data: MacroData, name: string): Program\n    {\n        const vertexSrc = this.processData(this.vertexTemplateSrc, this.vertexMacroData, data);\n        const fragmentSrc = this.processData(this.fragmentTemplateSrc, this.fragmentMacroData, data);\n        const key = vertexSrc + fragmentSrc;\n        const memo = this.programCache.get(key);\n\n        if (memo)\n        {\n            return memo;\n        }\n\n        const program = new Program(vertexSrc, fragmentSrc, name || this.name || 'pixi-processed-shader');\n\n        this.programCache.set(key, program);\n\n        return program;\n    }\n\n    /**\n     * Extracts the macros used in the template source.\n     *\n     * @param templateSrc - the shader template source\n     */\n    protected extractData(templateSrc: string): TemplateData\n    {\n        const data = [];\n        const pattern = new RegExp(MACRO_PATTERN);\n\n        let macroMatch;\n\n        while ((macroMatch = pattern.exec(templateSrc)) !== null)\n        {\n            const id = macroMatch[1];\n            let args = macroMatch[2];\n\n            if (args)\n            {\n                args = args.slice(1, -1).split(',').map((arg) => arg.trim());\n            }\n\n            data.push({\n                id,\n                args,\n                position: { start: macroMatch.index, end: macroMatch.index + macroMatch[0].length },\n                type: args ? 'function' : 'field',\n            });\n        }\n\n        return data;\n    }\n\n    /**\n     * Evaluates the macros in the template and generates the shader's source.\n     *\n     * @param templateSrc - template source\n     * @param macros - data defining the macros in the template source\n     * @param data - data providing the values for the macros\n     * @return the generated shader source\n     */\n    protected processData(templateSrc: string, macros: TemplateData, data: MacroData): string\n    {\n        let generatedSrc = templateSrc;\n\n        // Process the last macros first so that positions of the unevaluated macros don't change\n        for (let i = macros.length - 1; i >= 0; i--)\n        {\n            const macro = macros[i];\n            const id = macro.id;\n            const value = data[id];\n\n            let macroValue = '';\n\n            if (typeof value === 'function')\n            {\n                macroValue = value(...macro.args);\n            }\n            else\n            {\n                // Coerce the value to a string\n                macroValue = `${value}`;\n            }\n\n            generatedSrc = generatedSrc.slice(0, macro.position.start)\n                + macroValue\n                + generatedSrc.slice(macro.position.end);\n        }\n\n        return generatedSrc;\n    }\n}\n","import { MacroData, ProgramTemplate } from './ProgramTemplate';\nimport { Shader } from '@pixi/core';\n\n/**\n * Provides a high-level API to manage program template and generate shaders by passing macro data\n * for the shader templates.\n *\n * @public\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * @param vertexTemplateSrc - the vertex shader template source\n     * @param fragmentTemplateSrc  - the fragment shader template source\n     * @param name - custom name of the shader, if desired\n     */\n    static generateShader(vertexTemplateSrc: string,\n        fragmentTemplateSrc: string,\n        uniforms: Record<string, any>,\n        data: MacroData, name?: string): Shader\n    {\n        const programTemplate = ShaderPreprocessor.from(vertexTemplateSrc, fragmentTemplateSrc, name);\n        const program = programTemplate.generateProgram(data, name);\n\n        return new Shader(program, uniforms);\n    }\n\n    /**\n     * Creates a program template for given shader template sources. It will return a memoized instance if\n     * the same sources are used together twice.\n     *\n     * @param vertexTemplateSrc - vertex template source\n     * @param fragmentTemplateSrc - fragment template source\n     * @param name - the name of the template\n     */\n    static from(vertexTemplateSrc: string, fragmentTemplateSrc: string, name?: string): ProgramTemplate\n    {\n        const key = vertexTemplateSrc + fragmentTemplateSrc;\n        let template = ShaderPreprocessor.managedTemplates[key];\n\n        if (!template)\n        {\n            template\n                = ShaderPreprocessor.managedTemplates[key]\n                = new ProgramTemplate(vertexTemplateSrc, fragmentTemplateSrc, name);\n        }\n\n        return template;\n    }\n\n    static managedTemplates: { [id: string]: ProgramTemplate } = {};\n}\n"],"names":["MACRO_PATTERN","vertexTemplateSrc","fragmentTemplateSrc","name","this","Program","defaultVertexSrc","defaultFragmentSrc","programCache","Map","vertexMacroData","extractData","fragmentMacroData","ProgramTemplate","data","vertexSrc","processData","fragmentSrc","key","memo","get","program","set","templateSrc","macroMatch","pattern","RegExp","exec","id","args","slice","split","map","arg","trim","push","position","start","index","end","length","type","macros","generatedSrc","i","macro","value","macroValue","ShaderPreprocessor","uniforms","from","generateProgram","Shader","template","managedTemplates"],"mappings":";;;;;;;;;;4FAaA,IAAMA,EAAgB,0CAsBlB,WAAYC,EAA4BC,EAA8BC,gBAAAA,0BAKlEC,KAAKH,kBAAoBA,GAAqBI,UAAQC,iBAKtDF,KAAKF,oBAAsBA,GAAuBG,UAAQE,mBAK1DH,KAAKD,KAAOA,EAKZC,KAAKI,aAAe,IAAIC,IAKxBL,KAAKM,gBAAkBN,KAAKO,YAAYP,KAAKH,mBAK7CG,KAAKQ,kBAAoBR,KAAKO,YAAYP,KAAKF,qBAoGvD,OA1FIW,4BAAA,SAAgBC,EAAiBX,GAE7B,IAAMY,EAAYX,KAAKY,YAAYZ,KAAKH,kBAAmBG,KAAKM,gBAAiBI,GAC3EG,EAAcb,KAAKY,YAAYZ,KAAKF,oBAAqBE,KAAKQ,kBAAmBE,GACjFI,EAAMH,EAAYE,EAClBE,EAAOf,KAAKI,aAAaY,IAAIF,GAEnC,GAAIC,EAEA,OAAOA,EAGX,IAAME,EAAU,IAAIhB,UAAQU,EAAWE,EAAad,GAAQC,KAAKD,MAAQ,yBAIzE,OAFAC,KAAKI,aAAac,IAAIJ,EAAKG,GAEpBA,GAQDR,wBAAV,SAAsBU,GAOlB,IALA,IAGIC,EAHEV,EAAO,GACPW,EAAU,IAAIC,OAAO1B,GAIyB,QAA5CwB,EAAaC,EAAQE,KAAKJ,KAClC,CACI,IAAMK,EAAKJ,EAAW,GAClBK,EAAOL,EAAW,GAElBK,IAEAA,EAAOA,EAAKC,MAAM,GAAI,GAAGC,MAAM,KAAKC,KAAI,SAACC,GAAQ,OAAAA,EAAIC,WAGzDpB,EAAKqB,KAAK,CACNP,KACAC,OACAO,SAAU,CAAEC,MAAOb,EAAWc,MAAOC,IAAKf,EAAWc,MAAQd,EAAW,GAAGgB,QAC3EC,KAAMZ,EAAO,WAAa,UAIlC,OAAOf,GAWDD,wBAAV,SAAsBU,EAAqBmB,EAAsB5B,GAK7D,IAHA,IAAI6B,EAAepB,EAGVqB,EAAIF,EAAOF,OAAS,EAAGI,GAAK,EAAGA,IACxC,CACI,IAAMC,EAAQH,EAAOE,GAEfE,EAAQhC,EADH+B,EAAMjB,IAGbmB,EAAa,GAIbA,EAFiB,mBAAVD,EAEMA,eAASD,EAAMhB,MAKf,GAAGiB,EAGpBH,EAAeA,EAAab,MAAM,EAAGe,EAAMT,SAASC,OAC9CU,EACAJ,EAAab,MAAMe,EAAMT,SAASG,KAG5C,OAAOI,qBC1Jf,cA0CA,OAnCWK,iBAAP,SAAsB/C,EAClBC,EACA+C,EACAnC,EAAiBX,GAEjB,IACMkB,EADkB2B,EAAmBE,KAAKjD,EAAmBC,EAAqBC,GACxDgD,gBAAgBrC,EAAMX,GAEtD,OAAO,IAAIiD,SAAO/B,EAAS4B,IAWxBD,OAAP,SAAY/C,EAA2BC,EAA6BC,GAEhE,IAAMe,EAAMjB,EAAoBC,EAC5BmD,EAAWL,EAAmBM,iBAAiBpC,GASnD,OAPKmC,IAEDA,EACML,EAAmBM,iBAAiBpC,GACpC,IAAIL,EAAgBZ,EAAmBC,EAAqBC,IAG/DkD,GAGJL,mBAAsD"}