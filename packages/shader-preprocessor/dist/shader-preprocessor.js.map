{"version":3,"file":"shader-preprocessor.js","sources":["../src/ProgramTemplate.ts","../src/ShaderPreprocessor.ts"],"sourcesContent":["import { Program } from '@pixi/core';\n\ntype TemplateData = Array<{\n    id: string;\n    args: string[];\n    position: { start: number; end: number };\n    type: 'field' | 'function';\n}>;\n\nexport type MacroData = {\n    [id: string]: string | ((...args: string[]) => string);\n};\n\nconst MACRO_PATTERN = /%([\\w$]+)(\\([\\w$, ]*\\))?%/g;\n\n/**\n * Helper class to create and manage a program template.\n *\n * @public\n */\nexport class ProgramTemplate\n{\n    public vertexTemplateSrc: string;\n    public fragmentTemplateSrc: string;\n    public name: string;\n\n    protected programCache: Map<string, Program>;\n    protected vertexMacroData: TemplateData;\n    protected fragmentMacroData: TemplateData;\n\n    /**\n     * @param vertexTemplateSrc - vertex shader template\n     * @param fragmentTemplateSrc - fragment shader template\n     * @param name - name of the shader template. This is used to generate the names for generated programs.\n     */\n    constructor(vertexTemplateSrc?: string, fragmentTemplateSrc?: string, name = 'pixi-shader-template')\n    {\n        /**\n         * The vertex shader template\n         */\n        this.vertexTemplateSrc = vertexTemplateSrc || Program.defaultVertexSrc;\n\n        /**\n         * The fragment shader template\n         */\n        this.fragmentTemplateSrc = fragmentTemplateSrc || Program.defaultFragmentSrc;\n\n        /**\n         * The name for generated programs\n         */\n        this.name = name;\n\n        /**\n         * The cache of generated programs for each passed macro value.\n         */\n        this.programCache = new Map<string, Program>();\n\n        /**\n         * The macros used in the vertex shader\n         */\n        this.vertexMacroData = this.extractData(this.vertexTemplateSrc);\n\n        /**\n         * The macros used in the fragment shader\n         */\n        this.fragmentMacroData = this.extractData(this.fragmentTemplateSrc);\n    }\n\n    /**\n     * Generates a shader program from this template and passed macro-data.\n     *\n     * @param data - data providing the values of the macros in the shader template\n     * @param name - optional name, if another name is desired\n     * @return the generated shader program\n     */\n    generateProgram(data: MacroData, name: string): Program\n    {\n        const vertexSrc = this.processData(this.vertexTemplateSrc, this.vertexMacroData, data);\n        const fragmentSrc = this.processData(this.fragmentTemplateSrc, this.fragmentMacroData, data);\n        const key = vertexSrc + fragmentSrc;\n        const memo = this.programCache.get(key);\n\n        if (memo)\n        {\n            return memo;\n        }\n\n        const program = new Program(vertexSrc, fragmentSrc, name || this.name || 'pixi-processed-shader');\n\n        this.programCache.set(key, program);\n\n        return program;\n    }\n\n    /**\n     * Extracts the macros used in the template source.\n     *\n     * @param templateSrc - the shader template source\n     */\n    protected extractData(templateSrc: string): TemplateData\n    {\n        const data = [];\n        const pattern = new RegExp(MACRO_PATTERN);\n\n        let macroMatch;\n\n        while ((macroMatch = pattern.exec(templateSrc)) !== null)\n        {\n            const id = macroMatch[1];\n            let args = macroMatch[2];\n\n            if (args)\n            {\n                args = args.slice(1, -1).split(',').map((arg) => arg.trim());\n            }\n\n            data.push({\n                id,\n                args,\n                position: { start: macroMatch.index, end: macroMatch.index + macroMatch[0].length },\n                type: args ? 'function' : 'field',\n            });\n        }\n\n        return data;\n    }\n\n    /**\n     * Evaluates the macros in the template and generates the shader's source.\n     *\n     * @param templateSrc - template source\n     * @param macros - data defining the macros in the template source\n     * @param data - data providing the values for the macros\n     * @return the generated shader source\n     */\n    protected processData(templateSrc: string, macros: TemplateData, data: MacroData): string\n    {\n        let generatedSrc = templateSrc;\n\n        // Process the last macros first so that positions of the unevaluated macros don't change\n        for (let i = macros.length - 1; i >= 0; i--)\n        {\n            const macro = macros[i];\n            const id = macro.id;\n            const value = data[id];\n\n            let macroValue = '';\n\n            if (typeof value === 'function')\n            {\n                macroValue = value(...macro.args);\n            }\n            else\n            {\n                // Coerce the value to a string\n                macroValue = `${value}`;\n            }\n\n            generatedSrc = generatedSrc.slice(0, macro.position.start)\n                + macroValue\n                + generatedSrc.slice(macro.position.end);\n        }\n\n        return generatedSrc;\n    }\n}\n","import { MacroData, ProgramTemplate } from './ProgramTemplate';\nimport { Shader } from '@pixi/core';\n\n/**\n * Provides a high-level API to manage program template and generate shaders by passing macro data\n * for the shader templates.\n *\n * @public\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * @param vertexTemplateSrc - the vertex shader template source\n     * @param fragmentTemplateSrc  - the fragment shader template source\n     * @param name - custom name of the shader, if desired\n     */\n    static generateShader(vertexTemplateSrc: string,\n        fragmentTemplateSrc: string,\n        uniforms: Record<string, any>,\n        data: MacroData, name?: string): Shader\n    {\n        const programTemplate = ShaderPreprocessor.from(vertexTemplateSrc, fragmentTemplateSrc, name);\n        const program = programTemplate.generateProgram(data, name);\n\n        return new Shader(program, uniforms);\n    }\n\n    /**\n     * Creates a program template for given shader template sources. It will return a memoized instance if\n     * the same sources are used together twice.\n     *\n     * @param vertexTemplateSrc - vertex template source\n     * @param fragmentTemplateSrc - fragment template source\n     * @param name - the name of the template\n     */\n    static from(vertexTemplateSrc: string, fragmentTemplateSrc: string, name?: string): ProgramTemplate\n    {\n        const key = vertexTemplateSrc + fragmentTemplateSrc;\n        let template = ShaderPreprocessor.managedTemplates[key];\n\n        if (!template)\n        {\n            template\n                = ShaderPreprocessor.managedTemplates[key]\n                = new ProgramTemplate(vertexTemplateSrc, fragmentTemplateSrc, name);\n        }\n\n        return template;\n    }\n\n    static managedTemplates: { [id: string]: ProgramTemplate } = {};\n}\n"],"names":["MACRO_PATTERN","ProgramTemplate","[object Object]","vertexTemplateSrc","fragmentTemplateSrc","name","this","Program","defaultVertexSrc","defaultFragmentSrc","programCache","Map","vertexMacroData","extractData","fragmentMacroData","data","vertexSrc","processData","fragmentSrc","key","memo","get","program","set","templateSrc","pattern","RegExp","macroMatch","exec","id","args","slice","split","map","arg","trim","push","position","start","index","end","length","type","macros","generatedSrc","i","macro","value","macroValue","ShaderPreprocessor","uniforms","from","generateProgram","Shader","template","managedTemplates"],"mappings":";;;;;;;;;;4FAaA,MAAMA,EAAgB,mCAOTC,EAeTC,YAAYC,EAA4BC,EAA8BC,EAAO,wBAKzEC,KAAKH,kBAAoBA,GAAqBI,UAAQC,iBAKtDF,KAAKF,oBAAsBA,GAAuBG,UAAQE,mBAK1DH,KAAKD,KAAOA,EAKZC,KAAKI,aAAe,IAAIC,IAKxBL,KAAKM,gBAAkBN,KAAKO,YAAYP,KAAKH,mBAK7CG,KAAKQ,kBAAoBR,KAAKO,YAAYP,KAAKF,qBAUnDF,gBAAgBa,EAAiBV,GAE7B,MAAMW,EAAYV,KAAKW,YAAYX,KAAKH,kBAAmBG,KAAKM,gBAAiBG,GAC3EG,EAAcZ,KAAKW,YAAYX,KAAKF,oBAAqBE,KAAKQ,kBAAmBC,GACjFI,EAAMH,EAAYE,EAClBE,EAAOd,KAAKI,aAAaW,IAAIF,GAEnC,GAAIC,EAEA,OAAOA,EAGX,MAAME,EAAU,IAAIf,UAAQS,EAAWE,EAAab,GAAQC,KAAKD,MAAQ,yBAIzE,OAFAC,KAAKI,aAAaa,IAAIJ,EAAKG,GAEpBA,EAQDpB,YAAYsB,GAElB,MAAMT,EAAO,GACPU,EAAU,IAAIC,OAAO1B,GAE3B,IAAI2B,EAEJ,KAAoD,QAA5CA,EAAaF,EAAQG,KAAKJ,KAClC,CACI,MAAMK,EAAKF,EAAW,GACtB,IAAIG,EAAOH,EAAW,GAElBG,IAEAA,EAAOA,EAAKC,MAAM,GAAI,GAAGC,MAAM,KAAKC,IAAKC,GAAQA,EAAIC,SAGzDpB,EAAKqB,KAAK,CACNP,GAAAA,EACAC,KAAAA,EACAO,SAAU,CAAEC,MAAOX,EAAWY,MAAOC,IAAKb,EAAWY,MAAQZ,EAAW,GAAGc,QAC3EC,KAAMZ,EAAO,WAAa,UAIlC,OAAOf,EAWDb,YAAYsB,EAAqBmB,EAAsB5B,GAE7D,IAAI6B,EAAepB,EAGnB,IAAK,IAAIqB,EAAIF,EAAOF,OAAS,EAAGI,GAAK,EAAGA,IACxC,CACI,MAAMC,EAAQH,EAAOE,GAEfE,EAAQhC,EADH+B,EAAMjB,IAGjB,IAAImB,EAAa,GAIbA,EAFiB,mBAAVD,EAEMA,KAASD,EAAMhB,MAKf,GAAGiB,EAGpBH,EAAeA,EAAab,MAAM,EAAGe,EAAMT,SAASC,OAC9CU,EACAJ,EAAab,MAAMe,EAAMT,SAASG,KAG5C,OAAOI,SC1JFK,EAOT/C,sBAAsBC,EAClBC,EACA8C,EACAnC,EAAiBV,GAEjB,MACMiB,EADkB2B,EAAmBE,KAAKhD,EAAmBC,EAAqBC,GACxD+C,gBAAgBrC,EAAMV,GAEtD,OAAO,IAAIgD,SAAO/B,EAAS4B,GAW/BhD,YAAYC,EAA2BC,EAA6BC,GAEhE,MAAMc,EAAMhB,EAAoBC,EAChC,IAAIkD,EAAWL,EAAmBM,iBAAiBpC,GASnD,OAPKmC,IAEDA,EACML,EAAmBM,iBAAiBpC,GACpC,IAAIlB,EAAgBE,EAAmBC,EAAqBC,IAG/DiD,UAGJL,mBAAsD"}